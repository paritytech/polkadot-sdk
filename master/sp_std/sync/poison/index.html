<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Synchronization objects that employ poisoning."><title>sp_std::sync::poison - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-1a91846b.css"><script id="default-settings" 
data-use_system_theme="false"
data-theme="ayu"></script><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="sp_std" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="stylesheet" href="../../../theme.css"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"><script>
	function createToC() {
		let sidebar = document.querySelector(".sidebar");
		let headers = document.querySelectorAll("#main-content h2, #main-content h3, #main-content h4");
		console.log(`detected polkadot_sdk_docs: headers: ${headers.length}`);

		let toc = document.createElement("div");
		toc.classList.add("sidebar-table-of-contents");
		toc.appendChild(document.createElement("h2").appendChild(document.createTextNode("Table of Contents")).parentNode);

		let modules = document.querySelectorAll("main .item-table a.mod");

		// the first two headers are always junk
		headers.forEach(header => {
			let link = document.createElement("a");
			link.href = "#" + header.id;
			const headerTextContent = header.textContent.replace("¬ß", "")
			link.textContent = headerTextContent;
			link.className = header.tagName.toLowerCase();

			toc.appendChild(link);

			if (header.id == "modules" && headerTextContent == "Modules") {
				modules.forEach(module => {
					let link = document.createElement("a");
					link.href = module.href;
					link.textContent = module.textContent;
					link.className = "h3";

					toc.appendChild(link);
				});
			}
		});

		// insert toc as the second child in sidebar
		let sidebar_children = sidebar.children;
		if (sidebar_children.length > 1) {
			sidebar.insertBefore(toc, sidebar_children[1]);
		} else {
			sidebar.appendChild(toc);
		}
	}

	function hideSidebarElements() {
		// Create the 'Expand for More' button
		var expandButton = document.createElement('button');
		expandButton.innerText = 'Expand More Items';
		expandButton.classList.add('expand-button');

		// Insert the button at the top of the sidebar or before the '.sidebar-elems'
		var sidebarElems = document.querySelector('.sidebar-elems');
		sidebarElems.parentNode.insertBefore(expandButton, sidebarElems);

		// Initially hide the '.sidebar-elems'
		sidebarElems.style.display = 'none';

		// Add click event listener to the button
		expandButton.addEventListener('click', function () {
			// Toggle the display of the '.sidebar-elems'
			if (sidebarElems.style.display === 'none') {
				sidebarElems.style.display = 'block';
				expandButton.innerText = 'Collapse';
			} else {
				sidebarElems.style.display = 'none';
				expandButton.innerText = 'Expand for More';
			}
		});
	}

	window.addEventListener("DOMContentLoaded", (event) => {
		// if the crate is one that starts with `polkadot_sdk_docs`
		let crate_name = document.querySelector("#main-content > div > h1 > a:nth-child(1)");
		if (!crate_name.textContent.startsWith("polkadot_sdk_docs")) {
			console.log("skipping -- not `polkadot_sdk_docs`");
			return;
		} else {
			// insert class 'sdk-docs' to the body, so it enables the custom css rules.
			document.body.classList.add("sdk-docs");
		}

		createToC();
		hideSidebarElements();

		console.log("updating page based on being `polkadot_sdk_docs` crate");
	});
</script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<style>
	body.sdk-docs {
		nav.side-bar {
			width: 300px;
		}

		.sidebar-table-of-contents {
			margin-bottom: 1em;
			padding: 0.5em;
		}

		.sidebar-table-of-contents a {
			display: block;
			margin: 0.2em 0;
		}

		.sidebar-table-of-contents .h2 {
			font-weight: bold;
			margin-left: 0;
		}

		.sidebar-table-of-contents .h3 {
			margin-left: 1em;
		}

		.sidebar-table-of-contents .h4 {
			margin-left: 2em;
		}

		.sidebar h2.location {
			display: none;
		}

		.sidebar-elems {
			display: none;
		}

		/* Center the 'Expand for More' button */
		.expand-button {
			display: inline-block;
			/* Use inline-block for sizing */
			margin: 10px auto;
			/* Auto margins for horizontal centering */
			padding: 5px 10px;
			background-color: #007bff;
			color: white;
			text-align: center;
			cursor: pointer;
			border: none;
			border-radius: 5px;
			width: auto;
			/* Centering the button within its parent container */
			position: relative;
			left: 50%;
			transform: translateX(-50%);
		}
	}
</style>

<script async defer src=https://apisa.parity.io/latest.js></script><noscript><img src=https://apisa.parity.io/latest.js alt= referrerpolicy=no-referrer-when-downgrade /></noscript></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../sp_std/index.html">sp_std</a><span class="version">14.0.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module poison</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#poisoning" title="Poisoning">Poisoning</a></li><li><a href="#overview" title="Overview">Overview</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In sp_<wbr>std::<wbr>sync</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">sp_std</a>::<wbr><a href="../index.html">sync</a></div><h1>Module <span>poison</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="https://doc.rust-lang.org/1.88.0/src/std/sync/mod.rs.html#229">Source</a> </span></div><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>sync_poison_mod</code>)</span></div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Synchronization objects that employ poisoning.</p>
<h2 id="poisoning"><a class="doc-anchor" href="#poisoning">¬ß</a>Poisoning</h2>
<p>All synchronization objects in this module implement a strategy called ‚Äúpoisoning‚Äù
where if a thread panics while holding the exclusive access granted by the primitive,
the state of the primitive is set to ‚Äúpoisoned‚Äù.
This information is then propagated to all other threads
to signify that the data protected by this primitive is likely tainted
(some invariant is not being upheld).</p>
<p>The specifics of how this ‚Äúpoisoned‚Äù state affects other threads
depend on the primitive. See [#Overview] bellow.</p>
<p>For the alternative implementations that do not employ poisoning,
see <code>std::sys::nonpoisoning</code>.</p>
<h2 id="overview"><a class="doc-anchor" href="#overview">¬ß</a>Overview</h2>
<p>Below is a list of synchronization objects provided by this module
with a high-level overview for each object and a description
of how it employs ‚Äúpoisoning‚Äù.</p>
<ul>
<li>
<p><a href="../struct.Condvar.html" title="struct sp_std::sync::Condvar"><code>Condvar</code></a>: Condition Variable, providing the ability to block
a thread while waiting for an event to occur.</p>
<p>Condition variables are typically associated with
a boolean predicate (a condition) and a mutex.
This implementation is associated with <a href="../struct.Mutex.html" title="struct sp_std::sync::Mutex"><code>poison::Mutex</code></a>,
which employs poisoning.
For this reason, <a href="../struct.Condvar.html#method.wait" title="method sp_std::sync::Condvar::wait"><code>Condvar::wait()</code></a> will return a <a href="../type.LockResult.html" title="type sp_std::sync::LockResult"><code>LockResult</code></a>,
just like <a href="../struct.Mutex.html#method.lock" title="method sp_std::sync::Mutex::lock"><code>poison::Mutex::lock()</code></a> does.</p>
</li>
<li>
<p><a href="../struct.Mutex.html" title="struct sp_std::sync::Mutex"><code>Mutex</code></a>: Mutual Exclusion mechanism, which ensures that at
most one thread at a time is able to access some data.</p>
<p><a href="../struct.Mutex.html#method.lock" title="method sp_std::sync::Mutex::lock"><code>Mutex::lock()</code></a> returns a <a href="../type.LockResult.html" title="type sp_std::sync::LockResult"><code>LockResult</code></a>,
providing a way to deal with the poisoned state.
See <a href="../struct.Mutex.html#poisoning" title="struct sp_std::sync::Mutex"><code>Mutex</code>‚Äôs documentation</a> for more.</p>
</li>
<li>
<p><a href="../struct.Once.html" title="struct sp_std::sync::Once"><code>Once</code></a>: A thread-safe way to run a piece of code only once.
Mostly useful for implementing one-time global initialization.</p>
<p><a href="../struct.Once.html" title="struct sp_std::sync::Once"><code>Once</code></a> is poisoned if the piece of code passed to
<a href="../struct.Once.html#method.call_once" title="method sp_std::sync::Once::call_once"><code>Once::call_once()</code></a> or <a href="../struct.Once.html#method.call_once_force" title="method sp_std::sync::Once::call_once_force"><code>Once::call_once_force()</code></a> panics.
When in poisoned state, subsequent calls to <a href="../struct.Once.html#method.call_once" title="method sp_std::sync::Once::call_once"><code>Once::call_once()</code></a> will panic too.
<a href="../struct.Once.html#method.call_once_force" title="method sp_std::sync::Once::call_once_force"><code>Once::call_once_force()</code></a> can be used to clear the poisoned state.</p>
</li>
<li>
<p><a href="../struct.RwLock.html" title="struct sp_std::sync::RwLock"><code>RwLock</code></a>: Provides a mutual exclusion mechanism which allows
multiple readers at the same time, while allowing only one
writer at a time. In some cases, this can be more efficient than
a mutex.</p>
<p>This implementation, like <a href="../struct.Mutex.html" title="struct sp_std::sync::Mutex"><code>Mutex</code></a>, will become poisoned on a panic.
Note, however, that an <code>RwLock</code> may only be poisoned if a panic occurs
while it is locked exclusively (write mode). If a panic occurs in any reader,
then the lock will not be poisoned.</p>
</li>
</ul>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Condvar.html" title="struct sp_std::sync::poison::Condvar">Condvar</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>A Condition Variable</dd><dt><a class="struct" href="struct.MappedMutexGuard.html" title="struct sp_std::sync::poison::MappedMutexGuard">Mapped<wbr>Mutex<wbr>Guard</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>An RAII mutex guard returned by <code>MutexGuard::map</code>, which can point to a
subfield of the protected data. When this structure is dropped (falls out
of scope), the lock will be unlocked.</dd><dt><a class="struct" href="struct.MappedRwLockReadGuard.html" title="struct sp_std::sync::poison::MappedRwLockReadGuard">Mapped<wbr>RwLock<wbr>Read<wbr>Guard</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>RAII structure used to release the shared read access of a lock when
dropped, which can point to a subfield of the protected data.</dd><dt><a class="struct" href="struct.MappedRwLockWriteGuard.html" title="struct sp_std::sync::poison::MappedRwLockWriteGuard">Mapped<wbr>RwLock<wbr>Write<wbr>Guard</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>RAII structure used to release the exclusive write access of a lock when
dropped, which can point to a subfield of the protected data.</dd><dt><a class="struct" href="struct.Mutex.html" title="struct sp_std::sync::poison::Mutex">Mutex</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>A mutual exclusion primitive useful for protecting shared data</dd><dt><a class="struct" href="struct.MutexGuard.html" title="struct sp_std::sync::poison::MutexGuard">Mutex<wbr>Guard</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>An RAII implementation of a ‚Äúscoped lock‚Äù of a mutex. When this structure is
dropped (falls out of scope), the lock will be unlocked.</dd><dt><a class="struct" href="struct.Once.html" title="struct sp_std::sync::poison::Once">Once</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>A low-level synchronization primitive for one-time global execution.</dd><dt><a class="struct" href="struct.OnceState.html" title="struct sp_std::sync::poison::OnceState">Once<wbr>State</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>State yielded to <a href="../struct.Once.html#method.call_once_force" title="method sp_std::sync::Once::call_once_force"><code>Once::call_once_force()</code></a>‚Äôs closure parameter. The state
can be used to query the poison status of the <a href="../struct.Once.html" title="struct sp_std::sync::Once"><code>Once</code></a>.</dd><dt><a class="struct" href="struct.PoisonError.html" title="struct sp_std::sync::poison::PoisonError">Poison<wbr>Error</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>A type of error which can be returned whenever a lock is acquired.</dd><dt><a class="struct" href="struct.RwLock.html" title="struct sp_std::sync::poison::RwLock">RwLock</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>A reader-writer lock</dd><dt><a class="struct" href="struct.RwLockReadGuard.html" title="struct sp_std::sync::poison::RwLockReadGuard">RwLock<wbr>Read<wbr>Guard</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>RAII structure used to release the shared read access of a lock when
dropped.</dd><dt><a class="struct" href="struct.RwLockWriteGuard.html" title="struct sp_std::sync::poison::RwLockWriteGuard">RwLock<wbr>Write<wbr>Guard</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>RAII structure used to release the exclusive write access of a lock when
dropped.</dd><dt><a class="struct" href="struct.WaitTimeoutResult.html" title="struct sp_std::sync::poison::WaitTimeoutResult">Wait<wbr>Timeout<wbr>Result</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>A type indicating whether a timed wait on a condition variable returned
due to a time out or not.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="enum" href="enum.TryLockError.html" title="enum sp_std::sync::poison::TryLockError">TryLock<wbr>Error</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>An enumeration of possible errors associated with a <a href="../type.TryLockResult.html" title="type sp_std::sync::TryLockResult"><code>TryLockResult</code></a> which
can occur while trying to acquire a lock, from the <a href="../struct.Mutex.html#method.try_lock" title="method sp_std::sync::Mutex::try_lock"><code>try_lock</code></a> method on a
<a href="../struct.Mutex.html" title="struct sp_std::sync::Mutex"><code>Mutex</code></a> or the <a href="../struct.RwLock.html#method.try_read" title="method sp_std::sync::RwLock::try_read"><code>try_read</code></a> and <a href="../struct.RwLock.html#method.try_write" title="method sp_std::sync::RwLock::try_write"><code>try_write</code></a> methods on an <a href="../struct.RwLock.html" title="struct sp_std::sync::RwLock"><code>RwLock</code></a>.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="constant" href="constant.ONCE_INIT.html" title="constant sp_std::sync::poison::ONCE_INIT">ONCE_<wbr>INIT</a><wbr><span class="stab deprecated" title="">Deprecated</span><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>Initialization value for static <a href="../struct.Once.html" title="struct sp_std::sync::Once"><code>Once</code></a> values.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="type" href="type.LockResult.html" title="type sp_std::sync::poison::LockResult">Lock<wbr>Result</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>A type alias for the result of a lock method which can be poisoned.</dd><dt><a class="type" href="type.TryLockResult.html" title="type sp_std::sync::poison::TryLockResult">TryLock<wbr>Result</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>A type alias for the result of a nonblocking locking method.</dd></dl></section></div></main><script> mermaid.init({ startOnLoad: true, theme: "dark" }, "pre.language-mermaid > code");</script>


</body></html>