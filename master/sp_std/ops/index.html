<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Overloadable operators."><title>sp_std::ops - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><script id="default-settings" 
data-theme="ayu"
data-use_system_theme="false"></script><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="sp_std" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="stylesheet" href="../../theme.css"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"><script>
	function createToC() {
		let sidebar = document.querySelector(".sidebar");
		let headers = document.querySelectorAll("#main-content h2, #main-content h3, #main-content h4");
		console.log(`detected polkadot_sdk_docs: headers: ${headers.length}`);

		let toc = document.createElement("div");
		toc.classList.add("sidebar-table-of-contents");
		toc.appendChild(document.createElement("h2").appendChild(document.createTextNode("Table of Contents")).parentNode);

		let modules = document.querySelectorAll("main .item-table a.mod");

		// the first two headers are always junk
		headers.forEach(header => {
			let link = document.createElement("a");
			link.href = "#" + header.id;
			const headerTextContent = header.textContent.replace("§", "")
			link.textContent = headerTextContent;
			link.className = header.tagName.toLowerCase();

			toc.appendChild(link);

			if (header.id == "modules" && headerTextContent == "Modules") {
				modules.forEach(module => {
					let link = document.createElement("a");
					link.href = module.href;
					link.textContent = module.textContent;
					link.className = "h3";

					toc.appendChild(link);
				});
			}
		});

		// insert toc as the second child in sidebar
		let sidebar_children = sidebar.children;
		if (sidebar_children.length > 1) {
			sidebar.insertBefore(toc, sidebar_children[1]);
		} else {
			sidebar.appendChild(toc);
		}
	}

	function hideSidebarElements() {
		// Create the 'Expand for More' button
		var expandButton = document.createElement('button');
		expandButton.innerText = 'Expand More Items';
		expandButton.classList.add('expand-button');

		// Insert the button at the top of the sidebar or before the '.sidebar-elems'
		var sidebarElems = document.querySelector('.sidebar-elems');
		sidebarElems.parentNode.insertBefore(expandButton, sidebarElems);

		// Initially hide the '.sidebar-elems'
		sidebarElems.style.display = 'none';

		// Add click event listener to the button
		expandButton.addEventListener('click', function () {
			// Toggle the display of the '.sidebar-elems'
			if (sidebarElems.style.display === 'none') {
				sidebarElems.style.display = 'block';
				expandButton.innerText = 'Collapse';
			} else {
				sidebarElems.style.display = 'none';
				expandButton.innerText = 'Expand for More';
			}
		});
	}

	window.addEventListener("DOMContentLoaded", (event) => {
		// if the crate is one that starts with `polkadot_sdk_docs`
		let crate_name = document.querySelector("#main-content > div > h1 > a:nth-child(1)");
		if (!crate_name.textContent.startsWith("polkadot_sdk_docs")) {
			console.log("skipping -- not `polkadot_sdk_docs`");
			return;
		} else {
			// insert class 'sdk-docs' to the body, so it enables the custom css rules.
			document.body.classList.add("sdk-docs");
		}

		createToC();
		hideSidebarElements();

		console.log("updating page based on being `polkadot_sdk_docs` crate");
	});
</script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<style>
	body.sdk-docs {
		nav.side-bar {
			width: 300px;
		}

		.sidebar-table-of-contents {
			margin-bottom: 1em;
			padding: 0.5em;
		}

		.sidebar-table-of-contents a {
			display: block;
			margin: 0.2em 0;
		}

		.sidebar-table-of-contents .h2 {
			font-weight: bold;
			margin-left: 0;
		}

		.sidebar-table-of-contents .h3 {
			margin-left: 1em;
		}

		.sidebar-table-of-contents .h4 {
			margin-left: 2em;
		}

		.sidebar h2.location {
			display: none;
		}

		.sidebar-elems {
			display: none;
		}

		/* Center the 'Expand for More' button */
		.expand-button {
			display: inline-block;
			/* Use inline-block for sizing */
			margin: 10px auto;
			/* Auto margins for horizontal centering */
			padding: 5px 10px;
			background-color: #007bff;
			color: white;
			text-align: center;
			cursor: pointer;
			border: none;
			border-radius: 5px;
			width: auto;
			/* Centering the button within its parent container */
			position: relative;
			left: 50%;
			transform: translateX(-50%);
		}
	}
</style>

<script async defer src=https://apisa.parity.io/latest.js></script><noscript><img src=https://apisa.parity.io/latest.js alt= referrerpolicy=no-referrer-when-downgrade /></noscript></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../sp_std/index.html">sp_std</a><span class="version">14.0.0</span></h2></div><h2 class="location"><a href="#">Module ops</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section><h2><a href="../index.html">In crate sp_std</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">sp_std</a>::<wbr><a class="mod" href="#">ops</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/lib.rs.html#374">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Overloadable operators.</p>
<p>Implementing these traits allows you to overload certain operators.</p>
<p>Some of these traits are imported by the prelude, so they are available in
every Rust program. Only operators backed by traits can be overloaded. For
example, the addition operator (<code>+</code>) can be overloaded through the <a href="trait.Add.html" title="trait sp_std::ops::Add"><code>Add</code></a>
trait, but since the assignment operator (<code>=</code>) has no backing trait, there
is no way of overloading its semantics. Additionally, this module does not
provide any mechanism to create new operators. If traitless overloading or
custom operators are required, you should look toward macros to extend
Rust’s syntax.</p>
<p>Implementations of operator traits should be unsurprising in their
respective contexts, keeping in mind their usual meanings and
<a href="../../reference/expressions.html#expression-precedence">operator precedence</a>. For example, when implementing <a href="trait.Mul.html" title="trait sp_std::ops::Mul"><code>Mul</code></a>, the operation
should have some resemblance to multiplication (and share expected
properties like associativity).</p>
<p>Note that the <code>&amp;&amp;</code> and <code>||</code> operators are currently not supported for
overloading. Due to their short circuiting nature, they require a different
design from traits for other operators like <a href="trait.BitAnd.html" title="trait sp_std::ops::BitAnd"><code>BitAnd</code></a>. Designs for them are
under discussion.</p>
<p>Many of the operators take their operands by value. In non-generic
contexts involving built-in types, this is usually not a problem.
However, using these operators in generic code, requires some
attention if values have to be reused as opposed to letting the operators
consume them. One option is to occasionally use <a href="../clone/trait.Clone.html#tymethod.clone" title="method sp_std::clone::Clone::clone"><code>clone</code></a>.
Another option is to rely on the types involved providing additional
operator implementations for references. For example, for a user-defined
type <code>T</code> which is supposed to support addition, it is probably a good
idea to have both <code>T</code> and <code>&amp;T</code> implement the traits <a href="trait.Add.html" title="trait sp_std::ops::Add"><code>Add&lt;T&gt;</code></a> and
<a href="trait.Add.html" title="trait sp_std::ops::Add"><code>Add&lt;&amp;T&gt;</code></a> so that generic code can be written without unnecessary
cloning.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>This example creates a <code>Point</code> struct that implements <a href="trait.Add.html" title="trait sp_std::ops::Add"><code>Add</code></a> and <a href="trait.Sub.html" title="trait sp_std::ops::Sub"><code>Sub</code></a>,
and then demonstrates adding and subtracting two <code>Point</code>s.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ops::{Add, Sub};

<span class="attr">#[derive(Debug, Copy, Clone, PartialEq)]
</span><span class="kw">struct </span>Point {
    x: i32,
    y: i32,
}

<span class="kw">impl </span>Add <span class="kw">for </span>Point {
    <span class="kw">type </span>Output = <span class="self">Self</span>;

    <span class="kw">fn </span>add(<span class="self">self</span>, other: <span class="self">Self</span>) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{x: <span class="self">self</span>.x + other.x, y: <span class="self">self</span>.y + other.y}
    }
}

<span class="kw">impl </span>Sub <span class="kw">for </span>Point {
    <span class="kw">type </span>Output = <span class="self">Self</span>;

    <span class="kw">fn </span>sub(<span class="self">self</span>, other: <span class="self">Self</span>) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{x: <span class="self">self</span>.x - other.x, y: <span class="self">self</span>.y - other.y}
    }
}

<span class="macro">assert_eq!</span>(Point {x: <span class="number">3</span>, y: <span class="number">3</span>}, Point {x: <span class="number">1</span>, y: <span class="number">0</span>} + Point {x: <span class="number">2</span>, y: <span class="number">3</span>});
<span class="macro">assert_eq!</span>(Point {x: -<span class="number">1</span>, y: -<span class="number">3</span>}, Point {x: <span class="number">1</span>, y: <span class="number">0</span>} - Point {x: <span class="number">2</span>, y: <span class="number">3</span>});</code></pre></div>
<p>See the documentation for each trait for an example implementation.</p>
<p>The <a href="trait.Fn.html" title="trait sp_std::ops::Fn"><code>Fn</code></a>, <a href="trait.FnMut.html" title="trait sp_std::ops::FnMut"><code>FnMut</code></a>, and <a href="trait.FnOnce.html" title="trait sp_std::ops::FnOnce"><code>FnOnce</code></a> traits are implemented by types that can be
invoked like functions. Note that <a href="trait.Fn.html" title="trait sp_std::ops::Fn"><code>Fn</code></a> takes <code>&amp;self</code>, <a href="trait.FnMut.html" title="trait sp_std::ops::FnMut"><code>FnMut</code></a> takes <code>&amp;mut self</code> and <a href="trait.FnOnce.html" title="trait sp_std::ops::FnOnce"><code>FnOnce</code></a> takes <code>self</code>. These correspond to the three kinds of
methods that can be invoked on an instance: call-by-reference,
call-by-mutable-reference, and call-by-value. The most common use of these
traits is to act as bounds to higher-level functions that take functions or
closures as arguments.</p>
<p>Taking a <a href="trait.Fn.html" title="trait sp_std::ops::Fn"><code>Fn</code></a> as a parameter:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>call_with_one&lt;F&gt;(func: F) -&gt; usize
    <span class="kw">where </span>F: Fn(usize) -&gt; usize
{
    func(<span class="number">1</span>)
}

<span class="kw">let </span>double = |x| x * <span class="number">2</span>;
<span class="macro">assert_eq!</span>(call_with_one(double), <span class="number">2</span>);</code></pre></div>
<p>Taking a <a href="trait.FnMut.html" title="trait sp_std::ops::FnMut"><code>FnMut</code></a> as a parameter:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>do_twice&lt;F&gt;(<span class="kw-2">mut </span>func: F)
    <span class="kw">where </span>F: FnMut()
{
    func();
    func();
}

<span class="kw">let </span><span class="kw-2">mut </span>x: usize = <span class="number">1</span>;
{
    <span class="kw">let </span>add_two_to_x = || x += <span class="number">2</span>;
    do_twice(add_two_to_x);
}

<span class="macro">assert_eq!</span>(x, <span class="number">5</span>);</code></pre></div>
<p>Taking a <a href="trait.FnOnce.html" title="trait sp_std::ops::FnOnce"><code>FnOnce</code></a> as a parameter:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>consume_with_relish&lt;F&gt;(func: F)
    <span class="kw">where </span>F: FnOnce() -&gt; String
{
    <span class="comment">// `func` consumes its captured variables, so it cannot be run more
    // than once
    </span><span class="macro">println!</span>(<span class="string">"Consumed: {}"</span>, func());

    <span class="macro">println!</span>(<span class="string">"Delicious!"</span>);

    <span class="comment">// Attempting to invoke `func()` again will throw a `use of moved
    // value` error for `func`
</span>}

<span class="kw">let </span>x = String::from(<span class="string">"x"</span>);
<span class="kw">let </span>consume_and_return_x = <span class="kw">move </span>|| x;
consume_with_relish(consume_and_return_x);

<span class="comment">// `consume_and_return_x` can no longer be invoked at this point</span></code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Range.html" title="struct sp_std::ops::Range">Range</a></div><div class="desc docblock-short">A (half-open) range bounded inclusively below and exclusively above
(<code>start..end</code>).</div></li><li><div class="item-name"><a class="struct" href="struct.RangeFrom.html" title="struct sp_std::ops::RangeFrom">RangeFrom</a></div><div class="desc docblock-short">A range only bounded inclusively below (<code>start..</code>).</div></li><li><div class="item-name"><a class="struct" href="struct.RangeFull.html" title="struct sp_std::ops::RangeFull">RangeFull</a></div><div class="desc docblock-short">An unbounded range (<code>..</code>).</div></li><li><div class="item-name"><a class="struct" href="struct.RangeInclusive.html" title="struct sp_std::ops::RangeInclusive">RangeInclusive</a></div><div class="desc docblock-short">A range bounded inclusively below and above (<code>start..=end</code>).</div></li><li><div class="item-name"><a class="struct" href="struct.RangeTo.html" title="struct sp_std::ops::RangeTo">RangeTo</a></div><div class="desc docblock-short">A range only bounded exclusively above (<code>..end</code>).</div></li><li><div class="item-name"><a class="struct" href="struct.RangeToInclusive.html" title="struct sp_std::ops::RangeToInclusive">RangeToInclusive</a></div><div class="desc docblock-short">A range only bounded inclusively above (<code>..=end</code>).</div></li><li><div class="item-name"><a class="struct" href="struct.Yeet.html" title="struct sp_std::ops::Yeet">Yeet</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Implement <code>FromResidual&lt;Yeet&lt;T&gt;&gt;</code> on your type to enable
<code>do yeet expr</code> syntax in functions returning your type.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Bound.html" title="enum sp_std::ops::Bound">Bound</a></div><div class="desc docblock-short">An endpoint of a range of keys.</div></li><li><div class="item-name"><a class="enum" href="enum.ControlFlow.html" title="enum sp_std::ops::ControlFlow">ControlFlow</a></div><div class="desc docblock-short">Used to tell an operation whether it should exit early or go on as usual.</div></li><li><div class="item-name"><a class="enum" href="enum.CoroutineState.html" title="enum sp_std::ops::CoroutineState">CoroutineState</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">The result of a coroutine resumption.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Add.html" title="trait sp_std::ops::Add">Add</a></div><div class="desc docblock-short">The addition operator <code>+</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.AddAssign.html" title="trait sp_std::ops::AddAssign">AddAssign</a></div><div class="desc docblock-short">The addition assignment operator <code>+=</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.BitAnd.html" title="trait sp_std::ops::BitAnd">BitAnd</a></div><div class="desc docblock-short">The bitwise AND operator <code>&amp;</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.BitAndAssign.html" title="trait sp_std::ops::BitAndAssign">BitAndAssign</a></div><div class="desc docblock-short">The bitwise AND assignment operator <code>&amp;=</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.BitOr.html" title="trait sp_std::ops::BitOr">BitOr</a></div><div class="desc docblock-short">The bitwise OR operator <code>|</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.BitOrAssign.html" title="trait sp_std::ops::BitOrAssign">BitOrAssign</a></div><div class="desc docblock-short">The bitwise OR assignment operator <code>|=</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.BitXor.html" title="trait sp_std::ops::BitXor">BitXor</a></div><div class="desc docblock-short">The bitwise XOR operator <code>^</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.BitXorAssign.html" title="trait sp_std::ops::BitXorAssign">BitXorAssign</a></div><div class="desc docblock-short">The bitwise XOR assignment operator <code>^=</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.Deref.html" title="trait sp_std::ops::Deref">Deref</a></div><div class="desc docblock-short">Used for immutable dereferencing operations, like <code>*v</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.DerefMut.html" title="trait sp_std::ops::DerefMut">DerefMut</a></div><div class="desc docblock-short">Used for mutable dereferencing operations, like in <code>*v = 1;</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.Div.html" title="trait sp_std::ops::Div">Div</a></div><div class="desc docblock-short">The division operator <code>/</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.DivAssign.html" title="trait sp_std::ops::DivAssign">DivAssign</a></div><div class="desc docblock-short">The division assignment operator <code>/=</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.Drop.html" title="trait sp_std::ops::Drop">Drop</a></div><div class="desc docblock-short">Custom code within the destructor.</div></li><li><div class="item-name"><a class="trait" href="trait.Fn.html" title="trait sp_std::ops::Fn">Fn</a></div><div class="desc docblock-short">The version of the call operator that takes an immutable receiver.</div></li><li><div class="item-name"><a class="trait" href="trait.FnMut.html" title="trait sp_std::ops::FnMut">FnMut</a></div><div class="desc docblock-short">The version of the call operator that takes a mutable receiver.</div></li><li><div class="item-name"><a class="trait" href="trait.FnOnce.html" title="trait sp_std::ops::FnOnce">FnOnce</a></div><div class="desc docblock-short">The version of the call operator that takes a by-value receiver.</div></li><li><div class="item-name"><a class="trait" href="trait.Index.html" title="trait sp_std::ops::Index">Index</a></div><div class="desc docblock-short">Used for indexing operations (<code>container[index]</code>) in immutable contexts.</div></li><li><div class="item-name"><a class="trait" href="trait.IndexMut.html" title="trait sp_std::ops::IndexMut">IndexMut</a></div><div class="desc docblock-short">Used for indexing operations (<code>container[index]</code>) in mutable contexts.</div></li><li><div class="item-name"><a class="trait" href="trait.Mul.html" title="trait sp_std::ops::Mul">Mul</a></div><div class="desc docblock-short">The multiplication operator <code>*</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.MulAssign.html" title="trait sp_std::ops::MulAssign">MulAssign</a></div><div class="desc docblock-short">The multiplication assignment operator <code>*=</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.Neg.html" title="trait sp_std::ops::Neg">Neg</a></div><div class="desc docblock-short">The unary negation operator <code>-</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.Not.html" title="trait sp_std::ops::Not">Not</a></div><div class="desc docblock-short">The unary logical negation operator <code>!</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.RangeBounds.html" title="trait sp_std::ops::RangeBounds">RangeBounds</a></div><div class="desc docblock-short"><code>RangeBounds</code> is implemented by Rust’s built-in range types, produced
by range syntax like <code>..</code>, <code>a..</code>, <code>..b</code>, <code>..=c</code>, <code>d..e</code>, or <code>f..=g</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.Rem.html" title="trait sp_std::ops::Rem">Rem</a></div><div class="desc docblock-short">The remainder operator <code>%</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.RemAssign.html" title="trait sp_std::ops::RemAssign">RemAssign</a></div><div class="desc docblock-short">The remainder assignment operator <code>%=</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.Shl.html" title="trait sp_std::ops::Shl">Shl</a></div><div class="desc docblock-short">The left shift operator <code>&lt;&lt;</code>. Note that because this trait is implemented
for all integer types with multiple right-hand-side types, Rust’s type
checker has special handling for <code>_ &lt;&lt; _</code>, setting the result type for
integer operations to the type of the left-hand-side operand. This means
that though <code>a &lt;&lt; b</code> and <code>a.shl(b)</code> are one and the same from an evaluation
standpoint, they are different when it comes to type inference.</div></li><li><div class="item-name"><a class="trait" href="trait.ShlAssign.html" title="trait sp_std::ops::ShlAssign">ShlAssign</a></div><div class="desc docblock-short">The left shift assignment operator <code>&lt;&lt;=</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.Shr.html" title="trait sp_std::ops::Shr">Shr</a></div><div class="desc docblock-short">The right shift operator <code>&gt;&gt;</code>. Note that because this trait is implemented
for all integer types with multiple right-hand-side types, Rust’s type
checker has special handling for <code>_ &gt;&gt; _</code>, setting the result type for
integer operations to the type of the left-hand-side operand. This means
that though <code>a &gt;&gt; b</code> and <code>a.shr(b)</code> are one and the same from an evaluation
standpoint, they are different when it comes to type inference.</div></li><li><div class="item-name"><a class="trait" href="trait.ShrAssign.html" title="trait sp_std::ops::ShrAssign">ShrAssign</a></div><div class="desc docblock-short">The right shift assignment operator <code>&gt;&gt;=</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.Sub.html" title="trait sp_std::ops::Sub">Sub</a></div><div class="desc docblock-short">The subtraction operator <code>-</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.SubAssign.html" title="trait sp_std::ops::SubAssign">SubAssign</a></div><div class="desc docblock-short">The subtraction assignment operator <code>-=</code>.</div></li><li><div class="item-name"><a class="trait" href="trait.AsyncFn.html" title="trait sp_std::ops::AsyncFn">AsyncFn</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">An async-aware version of the <a href="trait.Fn.html" title="trait sp_std::ops::Fn"><code>Fn</code></a> trait.</div></li><li><div class="item-name"><a class="trait" href="trait.AsyncFnMut.html" title="trait sp_std::ops::AsyncFnMut">AsyncFnMut</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">An async-aware version of the <a href="trait.FnMut.html" title="trait sp_std::ops::FnMut"><code>FnMut</code></a> trait.</div></li><li><div class="item-name"><a class="trait" href="trait.AsyncFnOnce.html" title="trait sp_std::ops::AsyncFnOnce">AsyncFnOnce</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">An async-aware version of the <a href="trait.FnOnce.html" title="trait sp_std::ops::FnOnce"><code>FnOnce</code></a> trait.</div></li><li><div class="item-name"><a class="trait" href="trait.CoerceUnsized.html" title="trait sp_std::ops::CoerceUnsized">CoerceUnsized</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Trait that indicates that this is a pointer or a wrapper for one,
where unsizing can be performed on the pointee.</div></li><li><div class="item-name"><a class="trait" href="trait.Coroutine.html" title="trait sp_std::ops::Coroutine">Coroutine</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">The trait implemented by builtin coroutine types.</div></li><li><div class="item-name"><a class="trait" href="trait.DerefPure.html" title="trait sp_std::ops::DerefPure">DerefPure</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Perma-unstable marker trait. Indicates that the type has a well-behaved <a href="trait.Deref.html" title="trait sp_std::ops::Deref"><code>Deref</code></a>
(and, if applicable, <a href="trait.DerefMut.html" title="trait sp_std::ops::DerefMut"><code>DerefMut</code></a>) implementation. This is relied on for soundness
of deref patterns.</div></li><li><div class="item-name"><a class="trait" href="trait.DispatchFromDyn.html" title="trait sp_std::ops::DispatchFromDyn">DispatchFromDyn</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short"><code>DispatchFromDyn</code> is used in the implementation of object safety checks (specifically allowing
arbitrary self types), to guarantee that a method’s receiver type can be dispatched on.</div></li><li><div class="item-name"><a class="trait" href="trait.FromResidual.html" title="trait sp_std::ops::FromResidual">FromResidual</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Used to specify which residuals can be converted into which <a href="trait.Try.html" title="trait sp_std::ops::Try"><code>crate::ops::Try</code></a> types.</div></li><li><div class="item-name"><a class="trait" href="trait.OneSidedRange.html" title="trait sp_std::ops::OneSidedRange">OneSidedRange</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short"><code>OneSidedRange</code> is implemented for built-in range types that are unbounded
on one side. For example, <code>a..</code>, <code>..b</code> and <code>..=c</code> implement <code>OneSidedRange</code>,
but <code>..</code>, <code>d..e</code>, and <code>f..=g</code> do not.</div></li><li><div class="item-name"><a class="trait" href="trait.Residual.html" title="trait sp_std::ops::Residual">Residual</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Allows retrieving the canonical type implementing <a href="trait.Try.html" title="trait sp_std::ops::Try"><code>Try</code></a> that has this type
as its residual and allows it to hold an <code>O</code> as its output.</div></li><li><div class="item-name"><a class="trait" href="trait.Try.html" title="trait sp_std::ops::Try">Try</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">The <code>?</code> operator and <code>try {}</code> blocks.</div></li></ul></section></div></main><script> mermaid.init({ startOnLoad: true, theme: "dark" }, "pre.language-mermaid > code");</script>


</body></html>