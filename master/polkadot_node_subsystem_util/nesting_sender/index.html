<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Nested message sending"><title>polkadot_node_subsystem_util::nesting_sender - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-42caa33d.css"><script id="default-settings" 
data-use_system_theme="false"
data-theme="ayu"></script><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="polkadot_node_subsystem_util" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.1 (e71f9a9a9 2025-01-27)" data-channel="1.84.1" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="stylesheet" href="../../theme.css"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"><script>
	function createToC() {
		let sidebar = document.querySelector(".sidebar");
		let headers = document.querySelectorAll("#main-content h2, #main-content h3, #main-content h4");
		console.log(`detected polkadot_sdk_docs: headers: ${headers.length}`);

		let toc = document.createElement("div");
		toc.classList.add("sidebar-table-of-contents");
		toc.appendChild(document.createElement("h2").appendChild(document.createTextNode("Table of Contents")).parentNode);

		let modules = document.querySelectorAll("main .item-table a.mod");

		// the first two headers are always junk
		headers.forEach(header => {
			let link = document.createElement("a");
			link.href = "#" + header.id;
			const headerTextContent = header.textContent.replace("§", "")
			link.textContent = headerTextContent;
			link.className = header.tagName.toLowerCase();

			toc.appendChild(link);

			if (header.id == "modules" && headerTextContent == "Modules") {
				modules.forEach(module => {
					let link = document.createElement("a");
					link.href = module.href;
					link.textContent = module.textContent;
					link.className = "h3";

					toc.appendChild(link);
				});
			}
		});

		// insert toc as the second child in sidebar
		let sidebar_children = sidebar.children;
		if (sidebar_children.length > 1) {
			sidebar.insertBefore(toc, sidebar_children[1]);
		} else {
			sidebar.appendChild(toc);
		}
	}

	function hideSidebarElements() {
		// Create the 'Expand for More' button
		var expandButton = document.createElement('button');
		expandButton.innerText = 'Expand More Items';
		expandButton.classList.add('expand-button');

		// Insert the button at the top of the sidebar or before the '.sidebar-elems'
		var sidebarElems = document.querySelector('.sidebar-elems');
		sidebarElems.parentNode.insertBefore(expandButton, sidebarElems);

		// Initially hide the '.sidebar-elems'
		sidebarElems.style.display = 'none';

		// Add click event listener to the button
		expandButton.addEventListener('click', function () {
			// Toggle the display of the '.sidebar-elems'
			if (sidebarElems.style.display === 'none') {
				sidebarElems.style.display = 'block';
				expandButton.innerText = 'Collapse';
			} else {
				sidebarElems.style.display = 'none';
				expandButton.innerText = 'Expand for More';
			}
		});
	}

	window.addEventListener("DOMContentLoaded", (event) => {
		// if the crate is one that starts with `polkadot_sdk_docs`
		let crate_name = document.querySelector("#main-content > div > h1 > a:nth-child(1)");
		if (!crate_name.textContent.startsWith("polkadot_sdk_docs")) {
			console.log("skipping -- not `polkadot_sdk_docs`");
			return;
		} else {
			// insert class 'sdk-docs' to the body, so it enables the custom css rules.
			document.body.classList.add("sdk-docs");
		}

		createToC();
		hideSidebarElements();

		console.log("updating page based on being `polkadot_sdk_docs` crate");
	});
</script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<style>
	body.sdk-docs {
		nav.side-bar {
			width: 300px;
		}

		.sidebar-table-of-contents {
			margin-bottom: 1em;
			padding: 0.5em;
		}

		.sidebar-table-of-contents a {
			display: block;
			margin: 0.2em 0;
		}

		.sidebar-table-of-contents .h2 {
			font-weight: bold;
			margin-left: 0;
		}

		.sidebar-table-of-contents .h3 {
			margin-left: 1em;
		}

		.sidebar-table-of-contents .h4 {
			margin-left: 2em;
		}

		.sidebar h2.location {
			display: none;
		}

		.sidebar-elems {
			display: none;
		}

		/* Center the 'Expand for More' button */
		.expand-button {
			display: inline-block;
			/* Use inline-block for sizing */
			margin: 10px auto;
			/* Auto margins for horizontal centering */
			padding: 5px 10px;
			background-color: #007bff;
			color: white;
			text-align: center;
			cursor: pointer;
			border: none;
			border-radius: 5px;
			width: auto;
			/* Centering the button within its parent container */
			position: relative;
			left: 50%;
			transform: translateX(-50%);
		}
	}
</style>

<script async defer src=https://apisa.parity.io/latest.js></script><noscript><img src=https://apisa.parity.io/latest.js alt= referrerpolicy=no-referrer-when-downgrade /></noscript></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../polkadot_node_subsystem_util/index.html">polkadot_<wbr>node_<wbr>subsystem_<wbr>util</a><span class="version">7.0.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module nesting_<wbr>sender</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#background" title="Background">Background</a></li><li><a href="#architecture" title="Architecture">Architecture</a></li><li><a href="#limitations" title="Limitations">Limitations</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate polkadot_<wbr>node_<wbr>subsystem_<wbr>util</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">polkadot_node_subsystem_util</a></span><h1>Module <span>nesting_sender</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/polkadot_node_subsystem_util/nesting_sender.rs.html#17-208">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Nested message sending</p>
<p>Useful for having mostly synchronous code, with submodules spawning short lived asynchronous
tasks, sending messages back.</p>
<h3 id="background"><a class="doc-anchor" href="#background">§</a>Background</h3>
<p>Writing concurrent and even multithreaded by default is inconvenient and slow: No references
hence lots of needless cloning and data duplication, locks, mutexes, … We should reach
for concurrency and parallelism when there is an actual need, not just because we can and it is
reasonably safe in Rust.</p>
<p>I very much agree with many points in this blog post for example:</p>
<p><a href="https://maciej.codes/2022-06-09-local-async.html">https://maciej.codes/2022-06-09-local-async.html</a></p>
<p>Another very good post by Pierre (Tomaka):</p>
<p><a href="https://tomaka.medium.com/a-look-back-at-asynchronous-rust-d54d63934a1c">https://tomaka.medium.com/a-look-back-at-asynchronous-rust-d54d63934a1c</a></p>
<h3 id="architecture"><a class="doc-anchor" href="#architecture">§</a>Architecture</h3>
<p>This module helps with this in part. It does not break the multithreaded by default approach,
but it breaks the <code>spawn everything</code> approach. So once you <code>spawn</code> you will still be
multithreaded by default, despite that for most tasks we spawn (which just wait for network or
some message to arrive), that is very much pointless and needless overhead. You will just spawn
less in the first place.</p>
<p>By default your code is single threaded, except when actually needed:
- need to wait for long running synchronous IO (a threaded runtime is actually useful here)
- need to wait for some async event (message to arrive)
- need to do some hefty CPU bound processing (a thread is required here as well)</p>
<p>and it is not acceptable to block the main task for waiting for the result, because we actually
really have other things to do or at least need to stay responsive just in case.</p>
<p>With the types and traits in this module you can achieve exactly that: You write modules which
just execute logic and can call into the functions of other modules - yes we are calling normal
functions. For the case a module you are calling into requires an occasional background task,
you provide it with a <code>NestingSender&lt;M, ChildModuleMessage&gt;</code> that it can pass to any spawned
tasks.</p>
<p>This way you don’t have to spawn a task for each module just for it to be able to handle
asynchronous events. The module relies on the using/enclosing code/module to forward it any
asynchronous messages in a structured way.</p>
<p>What makes this architecture nice is the separation of concerns - at the top you only have to
provide a sender and dispatch received messages to the root module - it is completely
irrelevant how complex that module is, it might consist of child modules also having the need
to spawn and receive messages, which in turn do the same, still the root logic stays unchanged.
Everything is isolated to the level where it belongs, while we still keep a single task scope
in all non blocking/not CPU intensive parts, which allows us to share data via references for
example.</p>
<p>Because the wrapping is optional and transparent to the lower modules, each module can also be
used at the top directly without any wrapping, e.g. for standalone use or for testing purposes.</p>
<p>Checkout the documentation of <a href="struct.NestingSender.html" title="struct polkadot_node_subsystem_util::nesting_sender::NestingSender"><code>NestingSender</code></a> below for a basic
usage example. For a real world usage I would like to point you to the dispute-distribution
subsystem which makes use of this architecture.</p>
<h3 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h3>
<p>Nothing is ever for free of course: Each level adds an indirect function call to message
sending. which should be cheap enough for most applications, but something to keep in mind. In
particular we avoided the use of of async traits, which would have required memory allocations
on each send. Also cloning of <a href="struct.NestingSender.html" title="struct polkadot_node_subsystem_util::nesting_sender::NestingSender"><code>NestingSender</code></a> is more
expensive than cloning a plain mpsc::Sender, the overhead should be negligible though.</p>
<p>Further limitations: Because everything is routed to the same channel, it is not possible with
this approach to put back pressure on only a single source (as all are the same). If a module
has a task that requires this, it indeed has to spawn a long running task which can do the
back-pressure on that message source or we make it its own subsystem. This is just one of the
situations that justifies the complexity of asynchrony.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.NestingSender.html" title="struct polkadot_node_subsystem_util::nesting_sender::NestingSender">Nesting<wbr>Sender</a></div><div class="desc docblock-short">A message sender that supports sending nested messages.</div></li></ul></section></div></main><script> mermaid.init({ startOnLoad: true, theme: "dark" }, "pre.language-mermaid > code");</script>


</body></html>