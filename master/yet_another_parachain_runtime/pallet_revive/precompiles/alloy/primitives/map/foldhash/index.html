<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides foldhash, a fast, non-cryptographic, minimally DoS-resistant hashing algorithm designed for computational uses such as hashmaps, bloom filters, count sketching, etc."><title>yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../../../static.files/rustdoc-1a91846b.css"><script id="default-settings" 
data-use_system_theme="false"
data-theme="ayu"></script><meta name="rustdoc-vars" data-root-path="../../../../../../../" data-static-root-path="../../../../../../../static.files/" data-current-crate="yet_another_parachain_runtime" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../../../../../../static.files/storage-4e99c027.js"></script><script defer src="../../../../../../../crates.js"></script><script defer src="../../../../../../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../../../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="stylesheet" href="../../../../../../../theme.css"><link rel="alternate icon" type="image/png" href="../../../../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../static.files/favicon-044be391.svg"><script>
	function createToC() {
		let sidebar = document.querySelector(".sidebar");
		let headers = document.querySelectorAll("#main-content h2, #main-content h3, #main-content h4");
		console.log(`detected polkadot_sdk_docs: headers: ${headers.length}`);

		let toc = document.createElement("div");
		toc.classList.add("sidebar-table-of-contents");
		toc.appendChild(document.createElement("h2").appendChild(document.createTextNode("Table of Contents")).parentNode);

		let modules = document.querySelectorAll("main .item-table a.mod");

		// the first two headers are always junk
		headers.forEach(header => {
			let link = document.createElement("a");
			link.href = "#" + header.id;
			const headerTextContent = header.textContent.replace("§", "")
			link.textContent = headerTextContent;
			link.className = header.tagName.toLowerCase();

			toc.appendChild(link);

			if (header.id == "modules" && headerTextContent == "Modules") {
				modules.forEach(module => {
					let link = document.createElement("a");
					link.href = module.href;
					link.textContent = module.textContent;
					link.className = "h3";

					toc.appendChild(link);
				});
			}
		});

		// insert toc as the second child in sidebar
		let sidebar_children = sidebar.children;
		if (sidebar_children.length > 1) {
			sidebar.insertBefore(toc, sidebar_children[1]);
		} else {
			sidebar.appendChild(toc);
		}
	}

	function hideSidebarElements() {
		// Create the 'Expand for More' button
		var expandButton = document.createElement('button');
		expandButton.innerText = 'Expand More Items';
		expandButton.classList.add('expand-button');

		// Insert the button at the top of the sidebar or before the '.sidebar-elems'
		var sidebarElems = document.querySelector('.sidebar-elems');
		sidebarElems.parentNode.insertBefore(expandButton, sidebarElems);

		// Initially hide the '.sidebar-elems'
		sidebarElems.style.display = 'none';

		// Add click event listener to the button
		expandButton.addEventListener('click', function () {
			// Toggle the display of the '.sidebar-elems'
			if (sidebarElems.style.display === 'none') {
				sidebarElems.style.display = 'block';
				expandButton.innerText = 'Collapse';
			} else {
				sidebarElems.style.display = 'none';
				expandButton.innerText = 'Expand for More';
			}
		});
	}

	window.addEventListener("DOMContentLoaded", (event) => {
		// if the crate is one that starts with `polkadot_sdk_docs`
		let crate_name = document.querySelector("#main-content > div > h1 > a:nth-child(1)");
		if (!crate_name.textContent.startsWith("polkadot_sdk_docs")) {
			console.log("skipping -- not `polkadot_sdk_docs`");
			return;
		} else {
			// insert class 'sdk-docs' to the body, so it enables the custom css rules.
			document.body.classList.add("sdk-docs");
		}

		createToC();
		hideSidebarElements();

		console.log("updating page based on being `polkadot_sdk_docs` crate");
	});
</script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<style>
	body.sdk-docs {
		nav.side-bar {
			width: 300px;
		}

		.sidebar-table-of-contents {
			margin-bottom: 1em;
			padding: 0.5em;
		}

		.sidebar-table-of-contents a {
			display: block;
			margin: 0.2em 0;
		}

		.sidebar-table-of-contents .h2 {
			font-weight: bold;
			margin-left: 0;
		}

		.sidebar-table-of-contents .h3 {
			margin-left: 1em;
		}

		.sidebar-table-of-contents .h4 {
			margin-left: 2em;
		}

		.sidebar h2.location {
			display: none;
		}

		.sidebar-elems {
			display: none;
		}

		/* Center the 'Expand for More' button */
		.expand-button {
			display: inline-block;
			/* Use inline-block for sizing */
			margin: 10px auto;
			/* Auto margins for horizontal centering */
			padding: 5px 10px;
			background-color: #007bff;
			color: white;
			text-align: center;
			cursor: pointer;
			border: none;
			border-radius: 5px;
			width: auto;
			/* Centering the button within its parent container */
			position: relative;
			left: 50%;
			transform: translateX(-50%);
		}
	}
</style>

<script async defer src=https://apisa.parity.io/latest.js></script><noscript><img src=https://apisa.parity.io/latest.js alt= referrerpolicy=no-referrer-when-downgrade /></noscript></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../../../../yet_another_parachain_runtime/index.html">yet_<wbr>another_<wbr>parachain_<wbr>runtime</a><span class="version">0.6.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#usage" title="Usage">Usage</a><ul><li><a href="#seeding" title="Seeding">Seeding</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In yet_<wbr>another_<wbr>parachain_<wbr>runtime::<wbr>pallet_<wbr>revive::<wbr>precompiles::<wbr>alloy::<wbr>primitives::<wbr>map</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../../../../index.html">yet_another_parachain_runtime</a>::<wbr><a href="../../../../../index.html">pallet_revive</a>::<wbr><a href="../../../../index.html">precompiles</a>::<wbr><a href="../../../index.html">alloy</a>::<wbr><a href="../../index.html">primitives</a>::<wbr><a href="../index.html">map</a></div><h1>Crate <span>foldhash</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides foldhash, a fast, non-cryptographic, minimally
DoS-resistant hashing algorithm designed for computational uses such as
hashmaps, bloom filters, count sketching, etc.</p>
<p>When should you <strong>not</strong> use foldhash:</p>
<ul>
<li>
<p>You are afraid of people studying your long-running program’s behavior
to reverse engineer its internal random state and using this knowledge to
create many colliding inputs for computational complexity attacks.</p>
</li>
<li>
<p>You expect foldhash to have a consistent output across versions or
platforms, such as for persistent file formats or communication protocols.</p>
</li>
<li>
<p>You are relying on foldhash’s properties for any kind of security.
Foldhash is <strong>not appropriate for any cryptographic purpose</strong>.</p>
</li>
</ul>
<p>Foldhash has two variants, one optimized for speed which is ideal for data
structures such as hash maps and bloom filters, and one optimized for
statistical quality which is ideal for algorithms such as
<a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a> and
<a href="https://en.wikipedia.org/wiki/MinHash">MinHash</a>.</p>
<p>Foldhash can be used in a <code>#![no_std]</code> environment by disabling its default
<code>"std"</code> feature.</p>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<p>The easiest way to use this crate with the standard library <a href="type.HashMap.html" title="type yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::HashMap"><code>HashMap</code></a> or
<a href="type.HashSet.html" title="type yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::HashSet"><code>HashSet</code></a> is to import them from <code>foldhash</code> instead, along with the
extension traits to make <a href="../../../../../../emulated_integration_tests_common/xcm_emulator/struct.HashMap.html#method.new" title="associated function yet_another_parachain_runtime::emulated_integration_tests_common::xcm_emulator::HashMap::new"><code>HashMap::new</code></a> and <a href="../../../../../../emulated_integration_tests_common/xcm_emulator/struct.HashMap.html#method.with_capacity" title="associated function yet_another_parachain_runtime::emulated_integration_tests_common::xcm_emulator::HashMap::with_capacity"><code>HashMap::with_capacity</code></a>
work out-of-the-box:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>foldhash::{HashMap, HashMapExt};

<span class="kw">let </span><span class="kw-2">mut </span>hm = HashMap::new();
hm.insert(<span class="number">42</span>, <span class="string">"hello"</span>);</code></pre></div>
<p>You can also avoid the convenience types and do it manually by initializing
a <a href="fast/struct.RandomState.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::fast::RandomState"><code>RandomState</code></a>, for example if you are using a different hash map
implementation like <a href="https://docs.rs/hashbrown/"><code>hashbrown</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>hashbrown::HashMap;
<span class="kw">use </span>foldhash::fast::RandomState;

<span class="kw">let </span><span class="kw-2">mut </span>hm = HashMap::with_hasher(RandomState::default());
hm.insert(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</code></pre></div>
<p>The above methods are the recommended way to use foldhash, which will
automatically generate a randomly generated hasher instance for you. If you
absolutely must have determinism you can use <a href="fast/struct.FixedState.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::fast::FixedState"><code>FixedState</code></a>
instead, but note that this makes you trivially vulnerable to HashDoS
attacks and might lead to quadratic runtime when moving data from one
hashmap/set into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::HashSet;
<span class="kw">use </span>foldhash::fast::FixedState;

<span class="kw">let </span><span class="kw-2">mut </span>hm = HashSet::with_hasher(FixedState::with_seed(<span class="number">42</span>));
hm.insert([<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>]);</code></pre></div>
<p>If you rely on statistical properties of the hash for the correctness of
your algorithm, such as in <a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a>,
it is suggested to use the <a href="quality/struct.RandomState.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::quality::RandomState"><code>RandomState</code></a>
or <a href="quality/struct.FixedState.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::quality::FixedState"><code>FixedState</code></a> from the <a href="quality/index.html" title="mod yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::quality"><code>quality</code></a> module instead
of the <a href="fast/index.html" title="mod yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::fast"><code>fast</code></a> module. The latter is optimized purely for speed in hash
tables and has known statistical imperfections.</p>
<p>Finally, you can also directly use the <a href="quality/struct.RandomState.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::quality::RandomState"><code>RandomState</code></a>
or <a href="quality/struct.FixedState.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::quality::FixedState"><code>FixedState</code></a> to manually hash items using the
<a href="https://doc.rust-lang.org/1.88.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher"><code>BuildHasher</code></a> trait:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::hash::BuildHasher;
<span class="kw">use </span>foldhash::quality::RandomState;

<span class="kw">let </span>random_state = RandomState::default();
<span class="kw">let </span>hash = random_state.hash_one(<span class="string">"hello world"</span>);</code></pre></div>
<h3 id="seeding"><a class="doc-anchor" href="#seeding">§</a>Seeding</h3>
<p>Foldhash relies on a single 8-byte per-hasher seed which should be ideally
be different from each instance to instance, and also a larger
<a href="struct.SharedSeed.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::SharedSeed"><code>SharedSeed</code></a> which may be shared by many different instances.</p>
<p>To reduce overhead, this <a href="struct.SharedSeed.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::SharedSeed"><code>SharedSeed</code></a> is typically initialized once and
stored. To prevent each hashmap unnecessarily containing a reference to this
value there are three kinds of <a href="https://doc.rust-lang.org/1.88.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher"><code>BuildHasher</code></a>s
foldhash provides (both for <a href="fast/index.html" title="mod yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::fast"><code>fast</code></a> and <a href="quality/index.html" title="mod yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::quality"><code>quality</code></a>):</p>
<ol>
<li><a href="fast/struct.RandomState.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::fast::RandomState"><code>RandomState</code></a>, which always generates a
random per-hasher seed and implicitly stores a reference to <a href="struct.SharedSeed.html#method.global_random" title="associated function yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::SharedSeed::global_random"><code>SharedSeed::global_random</code></a>.</li>
<li><a href="fast/struct.FixedState.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::fast::FixedState"><code>FixedState</code></a>, which by default uses a fixed
per-hasher seed and implicitly stores a reference to <a href="struct.SharedSeed.html#method.global_fixed" title="associated function yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::SharedSeed::global_fixed"><code>SharedSeed::global_fixed</code></a>.</li>
<li><a href="fast/struct.SeedableRandomState.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::fast::SeedableRandomState"><code>SeedableRandomState</code></a>, which works like
<a href="fast/struct.RandomState.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::fast::RandomState"><code>RandomState</code></a> by default but can be seeded in any manner.
This state must include an explicit reference to a <a href="struct.SharedSeed.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::SharedSeed"><code>SharedSeed</code></a>, and thus
this struct is 16 bytes as opposed to just 8 bytes for the previous two.</li>
</ol>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="fast/index.html" title="mod yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::fast">fast</a></dt><dd>The foldhash implementation optimized for speed.</dd><dt><a class="mod" href="quality/index.html" title="mod yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::quality">quality</a></dt><dd>The foldhash implementation optimized for quality.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.SharedSeed.html" title="struct yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::SharedSeed">Shared<wbr>Seed</a></dt><dd>A random seed intended to be shared by many different foldhash instances.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.HashMapExt.html" title="trait yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::HashMapExt">Hash<wbr>MapExt</a></dt><dd>A convenience extension trait to enable <a href="../../../../../../emulated_integration_tests_common/xcm_emulator/struct.HashMap.html#method.new" title="associated function yet_another_parachain_runtime::emulated_integration_tests_common::xcm_emulator::HashMap::new"><code>HashMap::new</code></a> for hash maps that use <code>foldhash</code>.</dd><dt><a class="trait" href="trait.HashSetExt.html" title="trait yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::HashSetExt">Hash<wbr>SetExt</a></dt><dd>A convenience extension trait to enable <a href="https://doc.rust-lang.org/1.88.0/std/collections/hash/set/struct.HashSet.html#method.new" title="associated function std::collections::hash::set::HashSet::new"><code>HashSet::new</code></a> for hash sets that use <code>foldhash</code>.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.HashMap.html" title="type yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::HashMap">HashMap</a></dt><dd>Type alias for <a href="../../../../../../emulated_integration_tests_common/xcm_emulator/struct.HashMap.html" title="struct yet_another_parachain_runtime::emulated_integration_tests_common::xcm_emulator::HashMap"><code>std::collections::HashMap&lt;K, V, foldhash::fast::RandomState&gt;</code></a>.</dd><dt><a class="type" href="type.HashSet.html" title="type yet_another_parachain_runtime::pallet_revive::precompiles::alloy::primitives::map::foldhash::HashSet">HashSet</a></dt><dd>Type alias for <a href="https://doc.rust-lang.org/1.88.0/std/collections/hash/set/struct.HashSet.html" title="struct std::collections::hash::set::HashSet"><code>std::collections::HashSet&lt;T, foldhash::fast::RandomState&gt;</code></a>.</dd></dl></section></div></main><script> mermaid.init({ startOnLoad: true, theme: "dark" }, "pre.language-mermaid > code");</script>


</body></html>