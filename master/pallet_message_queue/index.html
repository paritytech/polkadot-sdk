<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Generalized Message Queue Pallet"><title>pallet_message_queue - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-1a91846b.css"><script id="default-settings" 
data-use_system_theme="false"
data-theme="ayu"></script><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="pallet_message_queue" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="stylesheet" href="../theme.css"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"><script>
	function createToC() {
		let sidebar = document.querySelector(".sidebar");
		let headers = document.querySelectorAll("#main-content h2, #main-content h3, #main-content h4");
		console.log(`detected polkadot_sdk_docs: headers: ${headers.length}`);

		let toc = document.createElement("div");
		toc.classList.add("sidebar-table-of-contents");
		toc.appendChild(document.createElement("h2").appendChild(document.createTextNode("Table of Contents")).parentNode);

		let modules = document.querySelectorAll("main .item-table a.mod");

		// the first two headers are always junk
		headers.forEach(header => {
			let link = document.createElement("a");
			link.href = "#" + header.id;
			const headerTextContent = header.textContent.replace("ยง", "")
			link.textContent = headerTextContent;
			link.className = header.tagName.toLowerCase();

			toc.appendChild(link);

			if (header.id == "modules" && headerTextContent == "Modules") {
				modules.forEach(module => {
					let link = document.createElement("a");
					link.href = module.href;
					link.textContent = module.textContent;
					link.className = "h3";

					toc.appendChild(link);
				});
			}
		});

		// insert toc as the second child in sidebar
		let sidebar_children = sidebar.children;
		if (sidebar_children.length > 1) {
			sidebar.insertBefore(toc, sidebar_children[1]);
		} else {
			sidebar.appendChild(toc);
		}
	}

	function hideSidebarElements() {
		// Create the 'Expand for More' button
		var expandButton = document.createElement('button');
		expandButton.innerText = 'Expand More Items';
		expandButton.classList.add('expand-button');

		// Insert the button at the top of the sidebar or before the '.sidebar-elems'
		var sidebarElems = document.querySelector('.sidebar-elems');
		sidebarElems.parentNode.insertBefore(expandButton, sidebarElems);

		// Initially hide the '.sidebar-elems'
		sidebarElems.style.display = 'none';

		// Add click event listener to the button
		expandButton.addEventListener('click', function () {
			// Toggle the display of the '.sidebar-elems'
			if (sidebarElems.style.display === 'none') {
				sidebarElems.style.display = 'block';
				expandButton.innerText = 'Collapse';
			} else {
				sidebarElems.style.display = 'none';
				expandButton.innerText = 'Expand for More';
			}
		});
	}

	window.addEventListener("DOMContentLoaded", (event) => {
		// if the crate is one that starts with `polkadot_sdk_docs`
		let crate_name = document.querySelector("#main-content > div > h1 > a:nth-child(1)");
		if (!crate_name.textContent.startsWith("polkadot_sdk_docs")) {
			console.log("skipping -- not `polkadot_sdk_docs`");
			return;
		} else {
			// insert class 'sdk-docs' to the body, so it enables the custom css rules.
			document.body.classList.add("sdk-docs");
		}

		createToC();
		hideSidebarElements();

		console.log("updating page based on being `polkadot_sdk_docs` crate");
	});
</script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<style>
	body.sdk-docs {
		nav.side-bar {
			width: 300px;
		}

		.sidebar-table-of-contents {
			margin-bottom: 1em;
			padding: 0.5em;
		}

		.sidebar-table-of-contents a {
			display: block;
			margin: 0.2em 0;
		}

		.sidebar-table-of-contents .h2 {
			font-weight: bold;
			margin-left: 0;
		}

		.sidebar-table-of-contents .h3 {
			margin-left: 1em;
		}

		.sidebar-table-of-contents .h4 {
			margin-left: 2em;
		}

		.sidebar h2.location {
			display: none;
		}

		.sidebar-elems {
			display: none;
		}

		/* Center the 'Expand for More' button */
		.expand-button {
			display: inline-block;
			/* Use inline-block for sizing */
			margin: 10px auto;
			/* Auto margins for horizontal centering */
			padding: 5px 10px;
			background-color: #007bff;
			color: white;
			text-align: center;
			cursor: pointer;
			border: none;
			border-radius: 5px;
			width: auto;
			/* Centering the button within its parent container */
			position: relative;
			left: 50%;
			transform: translateX(-50%);
		}
	}
</style>

<script async defer src=https://apisa.parity.io/latest.js></script><noscript><img src=https://apisa.parity.io/latest.js alt= referrerpolicy=no-referrer-when-downgrade /></noscript></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../pallet_message_queue/index.html">pallet_<wbr>message_<wbr>queue</a><span class="version">31.0.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#generalized-message-queue-pallet" title="Generalized Message Queue Pallet">Generalized Message Queue Pallet</a></li><li><a href="#design-goals" title="Design Goals">Design Goals</a></li><li><a href="#design" title="Design">Design</a></li><li><a href="#scenario-message-enqueuing" title="Scenario: Message enqueuing">Scenario: Message enqueuing</a></li><li><a href="#scenario-message-processing" title="Scenario: Message processing">Scenario: Message processing</a></li><li><a href="#scenario-overweight-execution" title="Scenario: Overweight execution">Scenario: Overweight execution</a></li><li><a href="#terminology" title="Terminology">Terminology</a></li><li><a href="#properties" title="Properties">Properties</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>pallet_message_queue</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/pallet_message_queue/lib.rs.html#18-1878">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="generalized-message-queue-pallet"><a class="doc-anchor" href="#generalized-message-queue-pallet">ยง</a>Generalized Message Queue Pallet</h2>
<p>Provides generalized message queuing and processing capabilities on a per-queue basis for
arbitrary use-cases.</p>
<h2 id="design-goals"><a class="doc-anchor" href="#design-goals">ยง</a>Design Goals</h2>
<ol>
<li>Minimal assumptions about <code>Message</code>s and <code>MessageOrigin</code>s. Both should be MEL bounded blobs.
This ensures the generality and reusability of the pallet.</li>
<li>Well known and tightly limited pre-dispatch PoV weights, especially for message execution.
This is paramount for the success of the pallet since message execution is done in
<code>on_initialize</code> which must <em>never</em> under-estimate its PoV weight. It also needs a frugal PoV
footprint since PoV is scarce and this is (possibly) done in every block. This must also hold
in  the presence of unpredictable message size distributions.</li>
<li>Usable as XCMP, DMP and UMP message/dispatch queue - possibly through adapter types.</li>
</ol>
<h2 id="design"><a class="doc-anchor" href="#design">ยง</a>Design</h2>
<p>The pallet has means to enqueue, store and process messages. This is implemented by having
<em>queues</em> which store enqueued messages and can be <em>served</em> to process said messages. A queue is
identified by its origin in the <code>BookStateFor</code>. Each message has an origin which defines into
which queue it will be stored. Messages are stored by being appended to the last <a href="struct.Page.html" title="struct pallet_message_queue::Page"><code>Page</code></a> of a
book. Each book keeps track of its pages by indexing <code>Pages</code>. The <code>ReadyRing</code> contains all
queues which hold at least one unprocessed message and are thereby <em>ready</em> to be serviced. The
<code>ServiceHead</code> indicates which <em>ready</em> queue is the next to be serviced.
The pallet implements [<code>frame_support::traits::EnqueueMessage</code>],
[<code>frame_support::traits::ServiceQueues</code>] and has [<code>frame_support::traits::ProcessMessage</code>] and
<a href="trait.OnQueueChanged.html" title="trait pallet_message_queue::OnQueueChanged"><code>OnQueueChanged</code></a> hooks to communicate with the outside world.</p>
<p>NOTE: The storage items are not linked since they are not public.</p>
<p><strong>Message Execution</strong></p>
<p>Executing a message is offloaded to the <a href="pallet/trait.Config.html#associatedtype.MessageProcessor" title="associated type pallet_message_queue::pallet::Config::MessageProcessor"><code>Config::MessageProcessor</code></a> which contains the actual
logic of how to handle the message since they are blobs. Storage changes are not rolled back on
error.</p>
<p>A failed message can be temporarily or permanently overweight. The pallet will perpetually try
to execute a temporarily overweight message. A permanently overweight message is skipped and
must be executed manually.</p>
<p><strong>Reentrancy</strong></p>
<p>This pallet has two entry points for executing (possibly recursive) logic;
<a href="pallet/struct.Pallet.html#method.service_queues" title="associated function pallet_message_queue::pallet::Pallet::service_queues"><code>Pallet::service_queues</code></a> and <a href="pallet/struct.Pallet.html#method.execute_overweight" title="associated function pallet_message_queue::pallet::Pallet::execute_overweight"><code>Pallet::execute_overweight</code></a>. Both entry points are guarded by
the same mutex to error on reentrancy. The only functions that are explicitly <strong>allowed</strong> to be
called by a message processor are: <a href="pallet/struct.Pallet.html#method.enqueue_message" title="associated function pallet_message_queue::pallet::Pallet::enqueue_message"><code>Pallet::enqueue_message</code></a> and
<a href="pallet/struct.Pallet.html#method.enqueue_messages" title="associated function pallet_message_queue::pallet::Pallet::enqueue_messages"><code>Pallet::enqueue_messages</code></a>. All other functions are forbidden and error with
<a href="pallet/enum.Error.html#variant.RecursiveDisallowed" title="variant pallet_message_queue::pallet::Error::RecursiveDisallowed"><code>Error::RecursiveDisallowed</code></a>.</p>
<p><strong>Pagination</strong></p>
<p>Queues are stored in a <em>paged</em> manner by splitting their messages into <a href="struct.Page.html" title="struct pallet_message_queue::Page"><code>Page</code></a>s. This results
in a lot of complexity when implementing the pallet but is completely necessary to achieve the
second #<a href="design-goals">Design Goal</a>. The problem comes from the fact a message can <em>possibly</em> be
quite large, lets say 64KiB. This then results in a <em>MEL</em> of at least 64KiB which results in a
PoV of at least 64KiB. Now we have the assumption that most messages are much shorter than their
maximum allowed length. This would result in most messages having a pre-dispatch PoV size which
is much larger than their post-dispatch PoV size, possibly by a factor of thousand. Disregarding
this observation would cripple the processing power of the pallet since it cannot straighten out
this discrepancy at runtime. Conceptually, the implementation is packing as many messages into a
single bounded vec, as actually fit into the bounds. This reduces the wasted PoV.</p>
<p><strong>Page Data Layout</strong></p>
<p>A Page contains a heap which holds all its messages. The heap is built by concatenating
<code>(ItemHeader, Message)</code> pairs. The <a href="struct.ItemHeader.html" title="struct pallet_message_queue::ItemHeader"><code>ItemHeader</code></a> contains the length of the message which is
needed for retrieving it. This layout allows for constant access time of the next message and
linear access time for any message in the page. The header must remain minimal to reduce its PoV
impact.</p>
<p><strong>Weight Metering</strong></p>
<p>The pallet utilizes the [<code>sp_weights::WeightMeter</code>] to manually track its consumption to always
stay within the required limit. This implies that the message processor hook can calculate the
weight of a message without executing it. This restricts the possible use-cases but is necessary
since the pallet runs in <code>on_initialize</code> which has a hard weight limit. The weight meter is used
in a way that <code>can_accrue</code> and <code>check_accrue</code> are always used to check the remaining weight of
an operation before committing to it. The process of exiting due to insufficient weight is
termed โbailingโ.</p>
<h2 id="scenario-message-enqueuing"><a class="doc-anchor" href="#scenario-message-enqueuing">ยง</a>Scenario: Message enqueuing</h2>
<p>A message <code>m</code> is enqueued for origin <code>o</code> into queue <code>Q[o]</code> through
[<code>frame_support::traits::EnqueueMessage::enqueue_message</code>]<code>(m, o)</code>.</p>
<p>First the queue is either loaded if it exists or otherwise created with empty default values.
The message is then inserted to the queue by appended it into its last <code>Page</code> or by creating a
new <code>Page</code> just for <code>m</code> if it does not fit in there. The number of messages in the <code>Book</code> is
incremented.</p>
<p><code>Q[o]</code> is now <em>ready</em> which will eventually result in <code>m</code> being processed.</p>
<h2 id="scenario-message-processing"><a class="doc-anchor" href="#scenario-message-processing">ยง</a>Scenario: Message processing</h2>
<p>The pallet runs each block in <code>on_initialize</code> or when being manually called through
[<code>frame_support::traits::ServiceQueues::service_queues</code>].</p>
<p>First it tries to โrotateโ the <code>ReadyRing</code> by one through advancing the <code>ServiceHead</code> to the
next <em>ready</em> queue. It then starts to service this queue by servicing as many pages of it as
possible. Servicing a page means to execute as many message of it as possible. Each executed
message is marked as <em>processed</em> if the <a href="pallet/trait.Config.html#associatedtype.MessageProcessor" title="associated type pallet_message_queue::pallet::Config::MessageProcessor"><code>Config::MessageProcessor</code></a> return Ok. An event
<a href="pallet/enum.Event.html#variant.Processed" title="variant pallet_message_queue::pallet::Event::Processed"><code>Event::Processed</code></a> is emitted afterwards. It is possible that the weight limit of the pallet
will never allow a specific message to be executed. In this case it remains as unprocessed and
is skipped. This process stops if either there are no more messages in the queue or the
remaining weight became insufficient to service this queue. If there is enough weight it tries
to advance to the next <em>ready</em> queue and service it. This continues until there are no more
queues on which it can make progress or not enough weight to check that.</p>
<h2 id="scenario-overweight-execution"><a class="doc-anchor" href="#scenario-overweight-execution">ยง</a>Scenario: Overweight execution</h2>
<p>A permanently over-weight message which was skipped by the message processing will never be
executed automatically through <code>on_initialize</code> nor by calling
[<code>frame_support::traits::ServiceQueues::service_queues</code>].</p>
<p>Manual intervention in the form of
[<code>frame_support::traits::ServiceQueues::execute_overweight</code>] is necessary. Overweight messages
emit an <a href="pallet/enum.Event.html#variant.OverweightEnqueued" title="variant pallet_message_queue::pallet::Event::OverweightEnqueued"><code>Event::OverweightEnqueued</code></a> event which can be used to extract the arguments for
manual execution. This only works on permanently overweight messages. There is no guarantee that
this will work since the message could be part of a stale page and be reaped before execution
commences.</p>
<h2 id="terminology"><a class="doc-anchor" href="#terminology">ยง</a>Terminology</h2>
<ul>
<li><code>Message</code>: A blob of data into which the pallet has no introspection, defined as
[<code>BoundedSlice&lt;u8, MaxMessageLenOf&lt;T&gt;&gt;</code>]. The message length is limited by <a href="type.MaxMessageLenOf.html" title="type pallet_message_queue::MaxMessageLenOf"><code>MaxMessageLenOf</code></a>
which is calculated from <a href="pallet/trait.Config.html#associatedtype.HeapSize" title="associated type pallet_message_queue::pallet::Config::HeapSize"><code>Config::HeapSize</code></a> and <a href="struct.ItemHeader.html#method.max_encoded_len" title="associated function pallet_message_queue::ItemHeader::max_encoded_len"><code>ItemHeader::max_encoded_len()</code></a>.</li>
<li><code>MessageOrigin</code>: A generic <em>origin</em> of a message, defined as <a href="type.MessageOriginOf.html" title="type pallet_message_queue::MessageOriginOf"><code>MessageOriginOf</code></a>. The
requirements for it are kept minimal to remain as generic as possible. The type is defined in
[<code>frame_support::traits::ProcessMessage::Origin</code>].</li>
<li><code>Page</code>: An array of <code>Message</code>s, see <a href="struct.Page.html" title="struct pallet_message_queue::Page"><code>Page</code></a>. Can never be empty.</li>
<li><code>Book</code>: A list of <code>Page</code>s, see <a href="struct.BookState.html" title="struct pallet_message_queue::BookState"><code>BookState</code></a>. Can be empty.</li>
<li><code>Queue</code>: A <code>Book</code> together with an <code>MessageOrigin</code> which can be part of the <code>ReadyRing</code>. Can
be empty.</li>
<li><code>ReadyRing</code>: A double-linked list which contains all <em>ready</em> <code>Queue</code>s. It chains together the
queues via their <code>ready_neighbours</code> fields. A <code>Queue</code> is <em>ready</em> if it contains at least one
<code>Message</code> which can be processed. Can be empty.</li>
<li><code>ServiceHead</code>: A pointer into the <code>ReadyRing</code> to the next <code>Queue</code> to be serviced.</li>
<li>(<code>un</code>)<code>processed</code>: A message is marked as <em>processed</em> after it was executed by the pallet. A
message which was either: not yet executed or could not be executed remains as <code>unprocessed</code>
which is the default state for a message after being enqueued.</li>
<li><code>knitting</code>/<code>unknitting</code>: The means of adding or removing a <code>Queue</code> from the <code>ReadyRing</code>.</li>
<li><code>MEL</code>: The Max Encoded Length of a type, see [<code>codec::MaxEncodedLen</code>].</li>
<li><code>Reentrance</code>: To enter an execution context again before it has completed.</li>
</ul>
<h2 id="properties"><a class="doc-anchor" href="#properties">ยง</a>Properties</h2>
<p><strong>Liveness - Enqueueing</strong></p>
<p>It is always possible to enqueue any message for any <code>MessageOrigin</code>.</p>
<p><strong>Liveness - Processing</strong></p>
<p><code>on_initialize</code> always respects its finite weight-limit.</p>
<p><strong>Progress - Enqueueing</strong></p>
<p>An enqueued message immediately becomes <em>unprocessed</em> and thereby eligible for execution.</p>
<p><strong>Progress - Processing</strong></p>
<p>The pallet will execute at least one unprocessed message per block, if there is any. Ensuring
this property needs careful consideration of the concrete weights, since it is possible that the
weight limit of <code>on_initialize</code> never allows for the execution of even one message; trivially if
the limit is set to zero. <code>integrity_test</code> can be used to ensure that this property holds.</p>
<p><strong>Fairness - Enqueuing</strong></p>
<p>Enqueueing a message for a specific <code>MessageOrigin</code> does not influence the ability to enqueue a
message for the same of any other <code>MessageOrigin</code>; guaranteed by <strong>Liveness - Enqueueing</strong>.</p>
<p><strong>Fairness - Processing</strong></p>
<p>The average amount of weight available for message processing is the same for each queue if the
number of queues is constant. Creating a new queue must therefore be, possibly economically,
expensive. Currently this is archived by having one queue per para-chain/thread, which keeps the
number of queues within <code>O(n)</code> and should be โgood enoughโ.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">ยง</a></h2><dl class="item-table reexports"><dt id="reexport.WeightInfo"><code>pub use weights::<a class="trait" href="weights/trait.WeightInfo.html" title="trait pallet_message_queue::weights::WeightInfo">WeightInfo</a>;</code></dt><dt><code>pub use <a class="mod" href="pallet/index.html" title="mod pallet_message_queue::pallet">pallet</a>::*;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="mod" href="mock_helpers/index.html" title="mod pallet_message_queue::mock_helpers">mock_<wbr>helpers</a></dt><dd>Std setup helpers for testing and benchmarking.</dd><dt><a class="mod" href="pallet/index.html" title="mod pallet_message_queue::pallet">pallet</a></dt><dd>The <code>pallet</code> module in each FRAME pallet hosts the most important items needed
to construct this pallet.</dd><dt><a class="mod" href="weights/index.html" title="mod pallet_message_queue::weights">weights</a></dt><dd>Autogenerated weights for <code>pallet_message_queue</code></dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BookState.html" title="struct pallet_message_queue::BookState">Book<wbr>State</a></dt><dd>The state of a queue as represented by a book of its pages.</dd><dt><a class="struct" href="struct.IntoU32.html" title="struct pallet_message_queue::IntoU32">IntoU32</a></dt><dd>Converts a [<code>sp_core::Get</code>] with returns a type that can be cast into an <code>u32</code> into a <code>Get</code>
which returns an <code>u32</code>.</dd><dt><a class="struct" href="struct.ItemHeader.html" title="struct pallet_message_queue::ItemHeader">Item<wbr>Header</a></dt><dd>Data encoded and prefixed to the encoded <code>MessageItem</code>.</dd><dt><a class="struct" href="struct.MaxEncodedLenOf.html" title="struct pallet_message_queue::MaxEncodedLenOf">MaxEncoded<wbr>LenOf</a></dt><dd>Provides a [<code>sp_core::Get</code>] to access the <code>MEL</code> of a [<code>codec::MaxEncodedLen</code>] type.</dd><dt><a class="struct" href="struct.MaxMessageLen.html" title="struct pallet_message_queue::MaxMessageLen">MaxMessage<wbr>Len</a></dt><dd>Calculates the maximum message length and exposed it through the [<code>codec::MaxEncodedLen</code>] trait.</dd><dt><a class="struct" href="struct.Neighbours.html" title="struct pallet_message_queue::Neighbours">Neighbours</a></dt><dd>A single link in the double-linked Ready Ring list.</dd><dt><a class="struct" href="struct.Page.html" title="struct pallet_message_queue::Page">Page</a></dt><dd>A page of messages. Pages always contain at least one item.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="trait" href="trait.ForceSetHead.html" title="trait pallet_message_queue::ForceSetHead">Force<wbr>SetHead</a></dt><dd>Allows to force the processing head to a specific queue.</dd><dt><a class="trait" href="trait.OnQueueChanged.html" title="trait pallet_message_queue::OnQueueChanged">OnQueue<wbr>Changed</a></dt><dd>Handler code for when the items in a queue change.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="type" href="type.BookStateOf.html" title="type pallet_message_queue::BookStateOf">Book<wbr>State<wbr>Of</a></dt><dd>The <a href="struct.BookState.html" title="struct pallet_message_queue::BookState"><code>BookState</code></a> of this pallet.</dd><dt><a class="type" href="type.HeapSizeU32Of.html" title="type pallet_message_queue::HeapSizeU32Of">Heap<wbr>Size<wbr>U32Of</a></dt><dd>The maximal heap size of a page.</dd><dt><a class="type" href="type.MaxMessageLenOf.html" title="type pallet_message_queue::MaxMessageLenOf">MaxMessage<wbr>LenOf</a></dt><dd>The maximal message length.</dd><dt><a class="type" href="type.MaxOriginLenOf.html" title="type pallet_message_queue::MaxOriginLenOf">MaxOrigin<wbr>LenOf</a></dt><dd>The maximal encoded origin length.</dd><dt><a class="type" href="type.MessageOriginOf.html" title="type pallet_message_queue::MessageOriginOf">Message<wbr>Origin<wbr>Of</a></dt><dd>The <code>MessageOrigin</code> of this pallet.</dd><dt><a class="type" href="type.PageOf.html" title="type pallet_message_queue::PageOf">PageOf</a></dt><dd>The <a href="struct.Page.html" title="struct pallet_message_queue::Page"><code>Page</code></a> of this pallet.</dd></dl><script type="text/json" id="notable-traits-data">{"&'static [u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.u8.html\">u8</a>]</div>","Vec<u8>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.88.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.88.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.u8.html\">u8</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div>"}</script></section></div></main><script> mermaid.init({ startOnLoad: true, theme: "dark" }, "pre.language-mermaid > code");</script>


</body></html>