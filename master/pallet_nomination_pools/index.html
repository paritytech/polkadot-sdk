<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Nomination Pools for Staking Delegation"><title>pallet_nomination_pools - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-1a91846b.css"><script id="default-settings" 
data-use_system_theme="false"
data-theme="ayu"></script><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="pallet_nomination_pools" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="stylesheet" href="../theme.css"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"><script>
	function createToC() {
		let sidebar = document.querySelector(".sidebar");
		let headers = document.querySelectorAll("#main-content h2, #main-content h3, #main-content h4");
		console.log(`detected polkadot_sdk_docs: headers: ${headers.length}`);

		let toc = document.createElement("div");
		toc.classList.add("sidebar-table-of-contents");
		toc.appendChild(document.createElement("h2").appendChild(document.createTextNode("Table of Contents")).parentNode);

		let modules = document.querySelectorAll("main .item-table a.mod");

		// the first two headers are always junk
		headers.forEach(header => {
			let link = document.createElement("a");
			link.href = "#" + header.id;
			const headerTextContent = header.textContent.replace("§", "")
			link.textContent = headerTextContent;
			link.className = header.tagName.toLowerCase();

			toc.appendChild(link);

			if (header.id == "modules" && headerTextContent == "Modules") {
				modules.forEach(module => {
					let link = document.createElement("a");
					link.href = module.href;
					link.textContent = module.textContent;
					link.className = "h3";

					toc.appendChild(link);
				});
			}
		});

		// insert toc as the second child in sidebar
		let sidebar_children = sidebar.children;
		if (sidebar_children.length > 1) {
			sidebar.insertBefore(toc, sidebar_children[1]);
		} else {
			sidebar.appendChild(toc);
		}
	}

	function hideSidebarElements() {
		// Create the 'Expand for More' button
		var expandButton = document.createElement('button');
		expandButton.innerText = 'Expand More Items';
		expandButton.classList.add('expand-button');

		// Insert the button at the top of the sidebar or before the '.sidebar-elems'
		var sidebarElems = document.querySelector('.sidebar-elems');
		sidebarElems.parentNode.insertBefore(expandButton, sidebarElems);

		// Initially hide the '.sidebar-elems'
		sidebarElems.style.display = 'none';

		// Add click event listener to the button
		expandButton.addEventListener('click', function () {
			// Toggle the display of the '.sidebar-elems'
			if (sidebarElems.style.display === 'none') {
				sidebarElems.style.display = 'block';
				expandButton.innerText = 'Collapse';
			} else {
				sidebarElems.style.display = 'none';
				expandButton.innerText = 'Expand for More';
			}
		});
	}

	window.addEventListener("DOMContentLoaded", (event) => {
		// if the crate is one that starts with `polkadot_sdk_docs`
		let crate_name = document.querySelector("#main-content > div > h1 > a:nth-child(1)");
		if (!crate_name.textContent.startsWith("polkadot_sdk_docs")) {
			console.log("skipping -- not `polkadot_sdk_docs`");
			return;
		} else {
			// insert class 'sdk-docs' to the body, so it enables the custom css rules.
			document.body.classList.add("sdk-docs");
		}

		createToC();
		hideSidebarElements();

		console.log("updating page based on being `polkadot_sdk_docs` crate");
	});
</script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<style>
	body.sdk-docs {
		nav.side-bar {
			width: 300px;
		}

		.sidebar-table-of-contents {
			margin-bottom: 1em;
			padding: 0.5em;
		}

		.sidebar-table-of-contents a {
			display: block;
			margin: 0.2em 0;
		}

		.sidebar-table-of-contents .h2 {
			font-weight: bold;
			margin-left: 0;
		}

		.sidebar-table-of-contents .h3 {
			margin-left: 1em;
		}

		.sidebar-table-of-contents .h4 {
			margin-left: 2em;
		}

		.sidebar h2.location {
			display: none;
		}

		.sidebar-elems {
			display: none;
		}

		/* Center the 'Expand for More' button */
		.expand-button {
			display: inline-block;
			/* Use inline-block for sizing */
			margin: 10px auto;
			/* Auto margins for horizontal centering */
			padding: 5px 10px;
			background-color: #007bff;
			color: white;
			text-align: center;
			cursor: pointer;
			border: none;
			border-radius: 5px;
			width: auto;
			/* Centering the button within its parent container */
			position: relative;
			left: 50%;
			transform: translateX(-50%);
		}
	}
</style>

<script async defer src=https://apisa.parity.io/latest.js></script><noscript><img src=https://apisa.parity.io/latest.js alt= referrerpolicy=no-referrer-when-downgrade /></noscript></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../pallet_nomination_pools/index.html">pallet_<wbr>nomination_<wbr>pools</a><span class="version">25.0.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#nomination-pools-for-staking-delegation" title="Nomination Pools for Staking Delegation">Nomination Pools for Staking Delegation</a></li><li><a href="#index" title="Index">Index</a><ul><li><a href="#key-terms" title="Key Terms">Key Terms</a></li><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#implementors-guide" title="Implementor’s Guide">Implementor’s Guide</a></li><li><a href="#design" title="Design">Design</a></li></ul></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>pallet_nomination_pools</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/pallet_nomination_pools/lib.rs.html#18-4278">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="nomination-pools-for-staking-delegation"><a class="doc-anchor" href="#nomination-pools-for-staking-delegation">§</a>Nomination Pools for Staking Delegation</h2>
<p>A pallet that allows members to delegate their stake to nominating pools. A nomination pool acts
as nominator and nominates validators on the members’ behalf.</p>
<h2 id="index"><a class="doc-anchor" href="#index">§</a>Index</h2>
<ul>
<li><a href="#key-terms">Key terms</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#implementors-guide">Implementor’s Guide</a></li>
<li><a href="#design">Design</a></li>
</ul>
<h3 id="key-terms"><a class="doc-anchor" href="#key-terms">§</a>Key Terms</h3>
<ul>
<li>pool id: A unique identifier of each pool. Set to u32.</li>
<li>bonded pool: Tracks the distribution of actively staked funds. See <a href="struct.BondedPool.html" title="struct pallet_nomination_pools::BondedPool"><code>BondedPool</code></a> and
<a href="struct.BondedPoolInner.html" title="struct pallet_nomination_pools::BondedPoolInner"><code>BondedPoolInner</code></a>.</li>
<li>reward pool: Tracks rewards earned by actively staked funds. See <a href="struct.RewardPool.html" title="struct pallet_nomination_pools::RewardPool"><code>RewardPool</code></a> and
<a href="pallet/type.RewardPools.html" title="type pallet_nomination_pools::pallet::RewardPools"><code>RewardPools</code></a>.</li>
<li>unbonding sub pools: Collection of pools at different phases of the unbonding lifecycle. See
<a href="struct.SubPools.html" title="struct pallet_nomination_pools::SubPools"><code>SubPools</code></a> and <a href="pallet/type.SubPoolsStorage.html" title="type pallet_nomination_pools::pallet::SubPoolsStorage"><code>SubPoolsStorage</code></a>.</li>
<li>members: Accounts that are members of pools. See <a href="struct.PoolMember.html" title="struct pallet_nomination_pools::PoolMember"><code>PoolMember</code></a> and <a href="pallet/type.PoolMembers.html" title="type pallet_nomination_pools::pallet::PoolMembers"><code>PoolMembers</code></a>.</li>
<li>roles: Administrative roles of each pool, capable of controlling nomination, and the state of
the pool.</li>
<li>point: A unit of measure for a members portion of a pool’s funds. Points initially have a
ratio of 1 (as set by <code>POINTS_TO_BALANCE_INIT_RATIO</code>) to balance, but as slashing happens,
this can change.</li>
<li>kick: The act of a pool administrator forcibly ejecting a member.</li>
<li>bonded account: A key-less account id derived from the pool id that acts as the bonded
account. This account registers itself as a nominator in the staking system, and follows
exactly the same rules and conditions as a normal staker. Its bond increases or decreases as
members join, it can <code>nominate</code> or <code>chill</code>, and might not even earn staking rewards if it is
not nominating proper validators.</li>
<li>reward account: A similar key-less account, that is set as the <code>Payee</code> account for the bonded
account for all staking rewards.</li>
<li>change rate: The rate at which pool commission can be changed. A change rate consists of a
<code>max_increase</code> and <code>min_delay</code>, dictating the maximum percentage increase that can be applied
to the commission per number of blocks.</li>
<li>throttle: An attempted commission increase is throttled if the attempted change falls outside
the change rate bounds.</li>
</ul>
<h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3><h4 id="join"><a class="doc-anchor" href="#join">§</a>Join</h4>
<p>An account can stake funds with a nomination pool by calling <a href="pallet/enum.Call.html#variant.join" title="variant pallet_nomination_pools::pallet::Call::join"><code>Call::join</code></a>.</p>
<h4 id="claim-rewards"><a class="doc-anchor" href="#claim-rewards">§</a>Claim rewards</h4>
<p>After joining a pool, a member can claim rewards by calling <a href="pallet/enum.Call.html#variant.claim_payout" title="variant pallet_nomination_pools::pallet::Call::claim_payout"><code>Call::claim_payout</code></a>.</p>
<p>A pool member can also set a <code>ClaimPermission</code> with <a href="pallet/enum.Call.html#variant.set_claim_permission" title="variant pallet_nomination_pools::pallet::Call::set_claim_permission"><code>Call::set_claim_permission</code></a>, to allow
other members to permissionlessly bond or withdraw their rewards by calling
<a href="pallet/enum.Call.html#variant.bond_extra_other" title="variant pallet_nomination_pools::pallet::Call::bond_extra_other"><code>Call::bond_extra_other</code></a> or <a href="pallet/enum.Call.html#variant.claim_payout_other" title="variant pallet_nomination_pools::pallet::Call::claim_payout_other"><code>Call::claim_payout_other</code></a> respectively.</p>
<p>For design docs see the <a href="#reward-pool">reward pool</a> section.</p>
<h4 id="leave"><a class="doc-anchor" href="#leave">§</a>Leave</h4>
<p>In order to leave, a member must take two steps.</p>
<p>First, they must call <a href="pallet/enum.Call.html#variant.unbond" title="variant pallet_nomination_pools::pallet::Call::unbond"><code>Call::unbond</code></a>. The unbond extrinsic will start the unbonding process by
unbonding all or a portion of the members funds.</p>
<blockquote>
<p>A member can have up to <a href="pallet/trait.Config.html#associatedtype.MaxUnbonding" title="associated type pallet_nomination_pools::pallet::Config::MaxUnbonding"><code>Config::MaxUnbonding</code></a> distinct active unbonding requests.</p>
</blockquote>
<p>Second, once [<code>sp_staking::StakingInterface::bonding_duration</code>] eras have passed, the member can
call <a href="pallet/enum.Call.html#variant.withdraw_unbonded" title="variant pallet_nomination_pools::pallet::Call::withdraw_unbonded"><code>Call::withdraw_unbonded</code></a> to withdraw any funds that are free.</p>
<p>For design docs see the <a href="#bonded-pool">bonded pool</a> and <a href="#unbonding-sub-pools">unbonding sub
pools</a> sections.</p>
<h4 id="slashes"><a class="doc-anchor" href="#slashes">§</a>Slashes</h4>
<p>Slashes are distributed evenly across the bonded pool and the unbonding pools from slash era+1
through the slash apply era. Thus, any member who either</p>
<ol>
<li>unbonded, or</li>
<li>was actively bonded
in the aforementioned range of eras will be affected by the slash. A member is slashed pro-rata
based on its stake relative to the total slash amount.</li>
</ol>
<p>Slashing does not change any single member’s balance. Instead, the slash will only reduce the
balance associated with a particular pool. But, we never change the total <em>points</em> of a pool
because of slashing. Therefore, when a slash happens, the ratio of points to balance changes in
a pool. In other words, the value of one point, which is initially 1-to-1 against a unit of
balance, is now less than one balance because of the slash.</p>
<h4 id="administration"><a class="doc-anchor" href="#administration">§</a>Administration</h4>
<p>A pool can be created with the <a href="pallet/enum.Call.html#variant.create" title="variant pallet_nomination_pools::pallet::Call::create"><code>Call::create</code></a> call. Once created, the pools nominator or root
user must call <a href="pallet/enum.Call.html#variant.nominate" title="variant pallet_nomination_pools::pallet::Call::nominate"><code>Call::nominate</code></a> to start nominating. <a href="pallet/enum.Call.html#variant.nominate" title="variant pallet_nomination_pools::pallet::Call::nominate"><code>Call::nominate</code></a> can be called at
anytime to update validator selection.</p>
<p>Similar to <a href="pallet/enum.Call.html#variant.nominate" title="variant pallet_nomination_pools::pallet::Call::nominate"><code>Call::nominate</code></a>, <a href="pallet/enum.Call.html#variant.chill" title="variant pallet_nomination_pools::pallet::Call::chill"><code>Call::chill</code></a> will chill to pool in the staking system, and
<a href="pallet/enum.Call.html#variant.pool_withdraw_unbonded" title="variant pallet_nomination_pools::pallet::Call::pool_withdraw_unbonded"><code>Call::pool_withdraw_unbonded</code></a> will withdraw any unbonding chunks of the pool bonded account.
The latter call is permissionless and can be called by anyone at any time.</p>
<p>To help facilitate pool administration the pool has one of three states (see <a href="enum.PoolState.html" title="enum pallet_nomination_pools::PoolState"><code>PoolState</code></a>):</p>
<ul>
<li>Open: Anyone can join the pool and no members can be permissionlessly removed.</li>
<li>Blocked: No members can join and some admin roles can kick members. Kicking is not instant,
and follows the same process of <code>unbond</code> and then <code>withdraw_unbonded</code>. In other words,
administrators can permissionlessly unbond other members.</li>
<li>Destroying: No members can join and all members can be permissionlessly removed with
<a href="pallet/enum.Call.html#variant.unbond" title="variant pallet_nomination_pools::pallet::Call::unbond"><code>Call::unbond</code></a> and <a href="pallet/enum.Call.html#variant.withdraw_unbonded" title="variant pallet_nomination_pools::pallet::Call::withdraw_unbonded"><code>Call::withdraw_unbonded</code></a>. Once a pool is in destroying state, it
cannot be reverted to another state.</li>
</ul>
<p>A pool has 4 administrative roles (see <a href="struct.PoolRoles.html" title="struct pallet_nomination_pools::PoolRoles"><code>PoolRoles</code></a>):</p>
<ul>
<li>Depositor: creates the pool and is the initial member. They can only leave the pool once all
other members have left. Once they fully withdraw their funds, the pool is destroyed.</li>
<li>Nominator: can select which validators the pool nominates.</li>
<li>Bouncer: can change the pools state and kick members if the pool is blocked.</li>
<li>Root: can change the nominator, bouncer, or itself, manage and claim commission, and can
perform any of the actions the nominator or bouncer can.</li>
</ul>
<p>### Commission</p>
<p>A pool can optionally have a commission configuration, via the <code>root</code> role, set with
<a href="pallet/enum.Call.html#variant.set_commission" title="variant pallet_nomination_pools::pallet::Call::set_commission"><code>Call::set_commission</code></a> and claimed with <a href="pallet/enum.Call.html#variant.claim_commission" title="variant pallet_nomination_pools::pallet::Call::claim_commission"><code>Call::claim_commission</code></a>. A payee account must be
supplied with the desired commission percentage. Beyond the commission itself, a pool can have a
maximum commission and a change rate.</p>
<p>Importantly, both max commission  <a href="pallet/enum.Call.html#variant.set_commission_max" title="variant pallet_nomination_pools::pallet::Call::set_commission_max"><code>Call::set_commission_max</code></a> and change rate
<a href="pallet/enum.Call.html#variant.set_commission_change_rate" title="variant pallet_nomination_pools::pallet::Call::set_commission_change_rate"><code>Call::set_commission_change_rate</code></a> can not be removed once set, and can only be set to more
restrictive values (i.e. a lower max commission or a slower change rate) in subsequent updates.</p>
<p>If set, a pool’s commission is bound to <a href="pallet/type.GlobalMaxCommission.html" title="type pallet_nomination_pools::pallet::GlobalMaxCommission"><code>GlobalMaxCommission</code></a> at the time it is applied to
pending rewards. <a href="pallet/type.GlobalMaxCommission.html" title="type pallet_nomination_pools::pallet::GlobalMaxCommission"><code>GlobalMaxCommission</code></a> is intended to be updated only via governance.</p>
<p>When a pool is dissolved, any outstanding pending commission that has not been claimed will be
transferred to the depositor.</p>
<p>Implementation note: Commission is analogous to a separate member account of the pool, with its
own reward counter in the form of <code>current_pending_commission</code>.</p>
<p>Crucially, commission is applied to rewards based on the current commission in effect at the
time rewards are transferred into the reward pool. This is to prevent the malicious behaviour of
changing the commission rate to a very high value after rewards are accumulated, and thus claim
an unexpectedly high chunk of the reward.</p>
<h4 id="dismantling"><a class="doc-anchor" href="#dismantling">§</a>Dismantling</h4>
<p>As noted, a pool is destroyed once</p>
<ol>
<li>First, all members need to fully unbond and withdraw. If the pool state is set to
<code>Destroying</code>, this can happen permissionlessly.</li>
<li>The depositor itself fully unbonds and withdraws.</li>
</ol>
<blockquote>
<p>Note that at this point, based on the requirements of the staking system, the pool’s bonded
account’s stake might not be able to ge below a certain threshold as a nominator. At this
point, the pool should <code>chill</code> itself to allow the depositor to leave. See <a href="pallet/enum.Call.html#variant.chill" title="variant pallet_nomination_pools::pallet::Call::chill"><code>Call::chill</code></a>.</p>
</blockquote>
<h3 id="implementors-guide"><a class="doc-anchor" href="#implementors-guide">§</a>Implementor’s Guide</h3>
<p>Some notes and common mistakes that wallets/apps wishing to implement this pallet should be
aware of:</p>
<h4 id="pool-members"><a class="doc-anchor" href="#pool-members">§</a>Pool Members</h4>
<ul>
<li>In general, whenever a pool member changes their total points, the chain will automatically
claim all their pending rewards for them. This is not optional, and MUST happen for the reward
calculation to remain correct (see the documentation of <code>bond</code> as an example). So, make sure
you are warning your users about it. They might be surprised if they see that they bonded an
extra 100 DOTs, and now suddenly their 5.23 DOTs in pending reward is gone. It is not gone, it
has been paid out to you!</li>
<li>Joining a pool implies transferring funds to the pool account. So it might be (based on which
wallet that you are using) that you no longer see the funds that are moved to the pool in your
“free balance” section. Make sure the user is aware of this, and not surprised by seeing this.
Also, the transfer that happens here is configured to to never accidentally destroy the sender
account. So to join a Pool, your sender account must remain alive with 1 DOT left in it. This
means, with 1 DOT as existential deposit, and 1 DOT as minimum to join a pool, you need at
least 2 DOT to join a pool. Consequently, if you are suggesting members to join a pool with
“Maximum possible value”, you must subtract 1 DOT to remain in the sender account to not
accidentally kill it.</li>
<li>Points and balance are not the same! Any pool member, at any point in time, can have points in
either the bonded pool or any of the unbonding pools. The crucial fact is that in any of these
pools, the ratio of point to balance is different and might not be 1. Each pool starts with a
ratio of 1, but as time goes on, for reasons such as slashing, the ratio gets broken. Over
time, 100 points in a bonded pool can be worth 90 DOTs. Make sure you are either representing
points as points (not as DOTs), or even better, always display both: “You have x points in
pool y which is worth z DOTs”. See here and here for examples of how to calculate point to
balance ratio of each pool (it is almost trivial ;))</li>
</ul>
<h4 id="pool-management"><a class="doc-anchor" href="#pool-management">§</a>Pool Management</h4>
<ul>
<li>The pool will be seen from the perspective of the rest of the system as a single nominator.
Ergo, This nominator must always respect the <code>staking.minNominatorBond</code> limit. Similar to a
normal nominator, who has to first <code>chill</code> before fully unbonding, the pool must also do the
same. The pool’s bonded account will be fully unbonded only when the depositor wants to leave
and dismantle the pool. All that said, the message is: the depositor can only leave the chain
when they chill the pool first.</li>
</ul>
<h3 id="design"><a class="doc-anchor" href="#design">§</a>Design</h3>
<p><em>Notes</em>: this section uses pseudo code to explain general design and does not necessarily
reflect the exact implementation. Additionally, a working knowledge of <code>pallet-staking</code>’s api is
assumed.</p>
<h4 id="goals"><a class="doc-anchor" href="#goals">§</a>Goals</h4>
<ul>
<li>Maintain network security by upholding integrity of slashing events, sufficiently penalizing
members that where in the pool while it was backing a validator that got slashed.</li>
<li>Maximize scalability in terms of member count.</li>
</ul>
<p>In order to maintain scalability, all operations are independent of the number of members. To do
this, delegation specific information is stored local to the member while the pool data
structures have bounded datum.</p>
<h4 id="bonded-pool"><a class="doc-anchor" href="#bonded-pool">§</a>Bonded pool</h4>
<p>A bonded pool nominates with its total balance, excluding that which has been withdrawn for
unbonding. The total points of a bonded pool are always equal to the sum of points of the
delegation members. A bonded pool tracks its points and reads its bonded balance.</p>
<p>When a member joins a pool, <code>amount_transferred</code> is transferred from the members account to the
bonded pools account. Then the pool calls <code>staking::bond_extra(amount_transferred)</code> and issues
new points which are tracked by the member and added to the bonded pool’s points.</p>
<p>When the pool already has some balance, we want the value of a point before the transfer to
equal the value of a point after the transfer. So, when a member joins a bonded pool with a
given <code>amount_transferred</code>, we maintain the ratio of bonded balance to points such that:</p>
<div class="example-wrap"><pre class="language-text"><code>balance_after_transfer / points_after_transfer == balance_before_transfer / points_before_transfer;</code></pre></div>
<p>To achieve this, we issue points based on the following:</p>
<div class="example-wrap"><pre class="language-text"><code>points_issued = (points_before_transfer / balance_before_transfer) * amount_transferred;</code></pre></div>
<p>For new bonded pools we can set the points issued per balance arbitrarily. In this
implementation we use a 1 points to 1 balance ratio for pool creation (see
<a href="constant.POINTS_TO_BALANCE_INIT_RATIO.html" title="constant pallet_nomination_pools::POINTS_TO_BALANCE_INIT_RATIO"><code>POINTS_TO_BALANCE_INIT_RATIO</code></a>).</p>
<p><strong>Relevant extrinsics:</strong></p>
<ul>
<li><a href="pallet/enum.Call.html#variant.create" title="variant pallet_nomination_pools::pallet::Call::create"><code>Call::create</code></a></li>
<li><a href="pallet/enum.Call.html#variant.join" title="variant pallet_nomination_pools::pallet::Call::join"><code>Call::join</code></a></li>
</ul>
<h4 id="reward-pool"><a class="doc-anchor" href="#reward-pool">§</a>Reward pool</h4>
<p>When a pool is first bonded it sets up a deterministic, inaccessible account as its reward
destination. This reward account combined with <code>RewardPool</code> compose a reward pool.</p>
<p>Reward pools are completely separate entities to bonded pools. Along with its account, a reward
pool also tracks its outstanding and claimed rewards as counters, in addition to pending and
claimed commission. These counters are updated with <code>RewardPool::update_records</code>. The current
reward counter of the pool (the total outstanding rewards, in points) is also callable with the
<code>RewardPool::current_reward_counter</code> method.</p>
<p>See <a href="https://hackmd.io/PFGn6wI5TbCmBYoEA_f2Uw">this link</a> for an in-depth explanation of the
reward pool mechanism.</p>
<p><strong>Relevant extrinsics:</strong></p>
<ul>
<li><a href="pallet/enum.Call.html#variant.claim_payout" title="variant pallet_nomination_pools::pallet::Call::claim_payout"><code>Call::claim_payout</code></a></li>
</ul>
<h4 id="unbonding-sub-pools"><a class="doc-anchor" href="#unbonding-sub-pools">§</a>Unbonding sub pools</h4>
<p>When a member unbonds, it’s balance is unbonded in the bonded pool’s account and tracked in an
unbonding pool associated with the active era. If no such pool exists, one is created. To track
which unbonding sub pool a member belongs too, a member tracks it’s <code>unbonding_era</code>.</p>
<p>When a member initiates unbonding it’s claim on the bonded pool (<code>balance_to_unbond</code>) is
computed as:</p>
<div class="example-wrap"><pre class="language-text"><code>balance_to_unbond = (bonded_pool.balance / bonded_pool.points) * member.points;</code></pre></div>
<p>If this is the first transfer into an unbonding pool arbitrary amount of points can be issued
per balance. In this implementation unbonding pools are initialized with a 1 point to 1 balance
ratio (see <a href="constant.POINTS_TO_BALANCE_INIT_RATIO.html" title="constant pallet_nomination_pools::POINTS_TO_BALANCE_INIT_RATIO"><code>POINTS_TO_BALANCE_INIT_RATIO</code></a>). Otherwise, the unbonding pools hold the same
points to balance ratio properties as the bonded pool, so member points in the unbonding pool
are issued based on</p>
<div class="example-wrap"><pre class="language-text"><code>new_points_issued = (points_before_transfer / balance_before_transfer) * balance_to_unbond;</code></pre></div>
<p>For scalability, a bound is maintained on the number of unbonding sub pools (see
<a href="struct.TotalUnbondingPools.html" title="struct pallet_nomination_pools::TotalUnbondingPools"><code>TotalUnbondingPools</code></a>). An unbonding pool is removed once its older than <code>current_era - TotalUnbondingPools</code>. An unbonding pool is merged into the unbonded pool with</p>
<div class="example-wrap"><pre class="language-text"><code>unbounded_pool.balance = unbounded_pool.balance + unbonding_pool.balance;
unbounded_pool.points = unbounded_pool.points + unbonding_pool.points;</code></pre></div>
<p>This scheme “averages” out the points value in the unbonded pool.</p>
<p>Once a members <code>unbonding_era</code> is older than <code>current_era - [sp_staking::StakingInterface::bonding_duration]</code>, it can can cash it’s points out of the
corresponding unbonding pool. If it’s <code>unbonding_era</code> is older than <code>current_era - TotalUnbondingPools</code>, it can cash it’s points from the unbonded pool.</p>
<p><strong>Relevant extrinsics:</strong></p>
<ul>
<li><a href="pallet/enum.Call.html#variant.unbond" title="variant pallet_nomination_pools::pallet::Call::unbond"><code>Call::unbond</code></a></li>
<li><a href="pallet/enum.Call.html#variant.withdraw_unbonded" title="variant pallet_nomination_pools::pallet::Call::withdraw_unbonded"><code>Call::withdraw_unbonded</code></a></li>
</ul>
<h4 id="slashing"><a class="doc-anchor" href="#slashing">§</a>Slashing</h4>
<p>This section assumes that the slash computation is executed by
<code>pallet_staking::StakingLedger::slash</code>, which passes the information to this pallet via
[<code>sp_staking::OnStakingUpdate::on_slash</code>].</p>
<p>Unbonding pools need to be slashed to ensure all nominators whom where in the bonded pool while
it was backing a validator that equivocated are punished. Without these measures a member could
unbond right after a validator equivocated with no consequences.</p>
<p>This strategy is unfair to members who joined after the slash, because they get slashed as well,
but spares members who unbond. The latter is much more important for security: if a pool’s
validators are attacking the network, their members need to unbond fast! Avoiding slashes gives
them an incentive to do that if validators get repeatedly slashed.</p>
<p>To be fair to joiners, this implementation also need joining pools, which are actively staking,
in addition to the unbonding pools. For maintenance simplicity these are not implemented.
Related: <a href="https://github.com/paritytech/substrate/issues/10860">https://github.com/paritytech/substrate/issues/10860</a></p>
<h4 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h4>
<ul>
<li>PoolMembers cannot vote with their staked funds because they are transferred into the pools
account. In the future this can be overcome by allowing the members to vote with their bonded
funds via vote splitting.</li>
<li>PoolMembers cannot quickly transfer to another pool if they do no like nominations, instead
they must wait for the unbonding duration.</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.WeightInfo"><code>pub use weights::<a class="trait" href="weights/trait.WeightInfo.html" title="trait pallet_nomination_pools::weights::WeightInfo">WeightInfo</a>;</code></dt><dt><code>pub use <a class="mod" href="pallet/index.html" title="mod pallet_nomination_pools::pallet">pallet</a>::*;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="adapter/index.html" title="mod pallet_nomination_pools::adapter">adapter</a></dt><dt><a class="mod" href="migration/index.html" title="mod pallet_nomination_pools::migration">migration</a></dt><dt><a class="mod" href="mock/index.html" title="mod pallet_nomination_pools::mock">mock</a></dt><dt><a class="mod" href="pallet/index.html" title="mod pallet_nomination_pools::pallet">pallet</a></dt><dd>The <code>pallet</code> module in each FRAME pallet hosts the most important items needed
to construct this pallet.</dd><dt><a class="mod" href="weights/index.html" title="mod pallet_nomination_pools::weights">weights</a></dt><dd>Autogenerated weights for <code>pallet_nomination_pools</code></dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.log.html" title="macro pallet_nomination_pools::log">log</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AllPoolMembers.html" title="struct pallet_nomination_pools::AllPoolMembers">AllPool<wbr>Members</a></dt><dd>A utility struct that provides a way to check if a given account is a pool member.</dd><dt><a class="struct" href="struct.BondedPool.html" title="struct pallet_nomination_pools::BondedPool">Bonded<wbr>Pool</a></dt><dd>A wrapper for bonded pools, with utility functions.</dd><dt><a class="struct" href="struct.BondedPoolInner.html" title="struct pallet_nomination_pools::BondedPoolInner">Bonded<wbr>Pool<wbr>Inner</a></dt><dd>Pool permissions and state</dd><dt><a class="struct" href="struct.Commission.html" title="struct pallet_nomination_pools::Commission">Commission</a></dt><dd>Pool commission.</dd><dt><a class="struct" href="struct.CommissionChangeRate.html" title="struct pallet_nomination_pools::CommissionChangeRate">Commission<wbr>Change<wbr>Rate</a></dt><dd>Pool commission change rate preferences.</dd><dt><a class="struct" href="struct.PoolMember.html" title="struct pallet_nomination_pools::PoolMember">Pool<wbr>Member</a></dt><dd>A member in a pool.</dd><dt><a class="struct" href="struct.PoolRoles.html" title="struct pallet_nomination_pools::PoolRoles">Pool<wbr>Roles</a></dt><dd>Pool administration roles.</dd><dt><a class="struct" href="struct.RewardPool.html" title="struct pallet_nomination_pools::RewardPool">Reward<wbr>Pool</a></dt><dd>A reward pool.</dd><dt><a class="struct" href="struct.SubPools.html" title="struct pallet_nomination_pools::SubPools">SubPools</a></dt><dt><a class="struct" href="struct.TotalUnbondingPools.html" title="struct pallet_nomination_pools::TotalUnbondingPools">Total<wbr>Unbonding<wbr>Pools</a></dt><dd>The maximum amount of eras an unbonding pool can exist prior to being merged with the
<code>no_era</code> pool. This is guaranteed to at least be equal to the staking <code>UnbondingDuration</code>. For
improved UX <a href="pallet/trait.Config.html#associatedtype.PostUnbondingPoolsWindow" title="associated type pallet_nomination_pools::pallet::Config::PostUnbondingPoolsWindow"><code>Config::PostUnbondingPoolsWindow</code></a> should be configured to a non-zero value.</dd><dt><a class="struct" href="struct.UnbondPool.html" title="struct pallet_nomination_pools::UnbondPool">Unbond<wbr>Pool</a></dt><dd>An unbonding pool. This is always mapped with an era.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.BondExtra.html" title="enum pallet_nomination_pools::BondExtra">Bond<wbr>Extra</a></dt><dd>How to increase the bond of a member.</dd><dt><a class="enum" href="enum.BondType.html" title="enum pallet_nomination_pools::BondType">Bond<wbr>Type</a></dt><dd>The type of bonding that can happen to a pool.</dd><dt><a class="enum" href="enum.ClaimPermission.html" title="enum pallet_nomination_pools::ClaimPermission">Claim<wbr>Permission</a></dt><dd>The permission a pool member can set for other accounts to claim rewards on their behalf.</dd><dt><a class="enum" href="enum.CommissionClaimPermission.html" title="enum pallet_nomination_pools::CommissionClaimPermission">Commission<wbr>Claim<wbr>Permission</a></dt><dt><a class="enum" href="enum.ConfigOp.html" title="enum pallet_nomination_pools::ConfigOp">Config<wbr>Op</a></dt><dd>Possible operations on the configuration values of this pallet.</dd><dt><a class="enum" href="enum.PoolState.html" title="enum pallet_nomination_pools::PoolState">Pool<wbr>State</a></dt><dd>A pool’s possible states.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.LOG_TARGET.html" title="constant pallet_nomination_pools::LOG_TARGET">LOG_<wbr>TARGET</a></dt><dd>The log target of this pallet.</dd><dt><a class="constant" href="constant.POINTS_TO_BALANCE_INIT_RATIO.html" title="constant pallet_nomination_pools::POINTS_TO_BALANCE_INIT_RATIO">POINTS_<wbr>TO_<wbr>BALANCE_<wbr>INIT_<wbr>RATIO</a></dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.BalanceOf.html" title="type pallet_nomination_pools::BalanceOf">Balance<wbr>Of</a></dt><dd>The balance type used by the currency system.</dd><dt><a class="type" href="type.BlockNumberFor.html" title="type pallet_nomination_pools::BlockNumberFor">Block<wbr>Number<wbr>For</a></dt><dt><a class="type" href="type.PoolId.html" title="type pallet_nomination_pools::PoolId">PoolId</a></dt><dd>Type used for unique identifier of each pool.</dd></dl><script type="text/json" id="notable-traits-data">{"&'static [u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.u8.html\">u8</a>]</div>","Vec<u8>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.88.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.88.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.88.0/std/primitive.u8.html\">u8</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.88.0/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div>"}</script></section></div></main><script> mermaid.init({ startOnLoad: true, theme: "dark" }, "pre.language-mermaid > code");</script>


</body></html>