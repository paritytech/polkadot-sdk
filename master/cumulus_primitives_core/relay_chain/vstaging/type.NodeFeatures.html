<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Bit indices in the `HostConfiguration.node_features` that correspond to different node features."><title>NodeFeatures in cumulus_primitives_core::relay_chain::vstaging - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="cumulus_primitives_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0 (79e9716c9 2023-11-13)" data-channel="1.74.0" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"><script async defer src="https://apisa.parity.io/latest.js"></script><noscript><img src="https://apisa.parity.io/latest.js" alt="" referrerpolicy="no-referrer-when-downgrade" /></noscript></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../cumulus_primitives_core/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../../../cumulus_primitives_core/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">NodeFeatures</a></h2><div class="sidebar-elems"><section><h3><a href="#aliased-type">Aliased type</a></h3><h3><a href="#deref-methods-BitSlice%3CT,+O%3E">Methods from Deref&lt;Target=BitSlice&lt;T, O&gt;&gt;</a></h3><ul class="block"><li><a href="#method.align_to">align_to</a></li><li><a href="#method.all">all</a></li><li><a href="#method.any">any</a></li><li><a href="#method.as_bitptr">as_bitptr</a></li><li><a href="#method.as_bitptr_range">as_bitptr_range</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.as_ptr_range">as_ptr_range</a></li><li><a href="#method.bit_domain">bit_domain</a></li><li><a href="#method.chunks">chunks</a></li><li><a href="#method.chunks_exact">chunks_exact</a></li><li><a href="#method.contains">contains</a></li><li><a href="#method.count_ones">count_ones</a></li><li><a href="#method.count_zeros">count_zeros</a></li><li><a href="#method.domain">domain</a></li><li><a href="#method.ends_with">ends_with</a></li><li><a href="#method.first">first</a></li><li><a href="#method.first_one">first_one</a></li><li><a href="#method.first_zero">first_zero</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.iter_ones">iter_ones</a></li><li><a href="#method.iter_zeros">iter_zeros</a></li><li><a href="#method.last">last</a></li><li><a href="#method.last_one">last_one</a></li><li><a href="#method.last_zero">last_zero</a></li><li><a href="#method.leading_ones">leading_ones</a></li><li><a href="#method.leading_zeros">leading_zeros</a></li><li><a href="#method.len">len</a></li><li><a href="#method.not_all">not_all</a></li><li><a href="#method.not_any">not_any</a></li><li><a href="#method.rchunks">rchunks</a></li><li><a href="#method.rchunks_exact">rchunks_exact</a></li><li><a href="#method.repeat">repeat</a></li><li><a href="#method.rsplit">rsplit</a></li><li><a href="#method.rsplitn">rsplitn</a></li><li><a href="#method.set_aliased">set_aliased</a></li><li><a href="#method.set_aliased_unchecked">set_aliased_unchecked</a></li><li><a href="#method.some">some</a></li><li><a href="#method.split">split</a></li><li><a href="#method.split_at">split_at</a></li><li><a href="#method.split_at_unchecked">split_at_unchecked</a></li><li><a href="#method.split_first">split_first</a></li><li><a href="#method.split_inclusive">split_inclusive</a></li><li><a href="#method.split_last">split_last</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.starts_with">starts_with</a></li><li><a href="#method.strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix">strip_suffix</a></li><li><a href="#method.to_bitvec">to_bitvec</a></li><li><a href="#method.to_vec">to_vec</a></li><li><a href="#method.trailing_ones">trailing_ones</a></li><li><a href="#method.trailing_zeros">trailing_zeros</a></li><li><a href="#method.windows">windows</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Deref-for-BitVec%3CT,+O%3E">Deref</a></li></ul></section><h2><a href="index.html">In cumulus_primitives_core::relay_chain::vstaging</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Type Alias <a href="../../index.html">cumulus_primitives_core</a>::<wbr><a href="../index.html">relay_chain</a>::<wbr><a href="index.html">vstaging</a>::<wbr><a class="type" href="#">NodeFeatures</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub type NodeFeatures = BitVec&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.u8.html">u8</a>, Lsb0&gt;;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Bit indices in the <code>HostConfiguration.node_features</code> that correspond to different node features.</p>
</div></details><h2 id="aliased-type" class="small-section-header">Aliased Type<a href="#aliased-type" class="anchor">Â§</a></h2><pre class="rust item-decl"><code>struct NodeFeatures { /* private fields */ }</code></pre><h2 id="deref-methods-BitSlice%3CT,+O%3E" class="small-section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/1.74.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = BitSlice&lt;T, O&gt;&gt;</span><a href="#deref-methods-BitSlice%3CT,+O%3E" class="anchor">Â§</a></h2><div id="deref-methods-BitSlice%3CT,+O%3E-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the number of bits in the bit-slice.</p>
<h6 id="original"><a href="#original">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.len"><code>slice::len</code></a></p>
<h6 id="examples"><a href="#examples">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].len(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">10</span>].len(), <span class="number">10</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if the bit-slice is empty (length zero).</p>
<h6 id="original-1"><a href="#original-1">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.is_empty"><code>slice::is_empty</code></a></p>
<h6 id="examples-1"><a href="#examples-1">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].is_empty());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">10</span>].is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.first" class="method"><h4 class="code-header">pub fn <a href="#method.first" class="fn">first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;BitRef&lt;'_, Const, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a reference to the first bit of the bit-slice, or <code>None</code> if it is
empty.</p>
<h6 id="original-2"><a href="#original-2">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first"><code>slice::first</code></a></p>
<h6 id="api-differences"><a href="#api-differences">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-2"><a href="#examples-2">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.first().as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_first" class="method"><h4 class="code-header">pub fn <a href="#method.split_first" class="fn">split_first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(BitRef&lt;'_, Const, T, O&gt;, &amp;BitSlice&lt;T, O&gt;)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into a reference to its first bit, and the rest of
the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-3"><a href="#original-3">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_first"><code>slice::split_first</code></a></p>
<h6 id="api-differences-1"><a href="#api-differences-1">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-3"><a href="#examples-3">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span>(first, rest) = bits.split_first().unwrap();
<span class="macro">assert_eq!</span>(first, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_last" class="method"><h4 class="code-header">pub fn <a href="#method.split_last" class="fn">split_last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(BitRef&lt;'_, Const, T, O&gt;, &amp;BitSlice&lt;T, O&gt;)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into a reference to its last bit, and the rest of
the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-4"><a href="#original-4">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last"><code>slice::split_last</code></a></p>
<h6 id="api-differences-2"><a href="#api-differences-2">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-4"><a href="#examples-4">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>(last, rest) = bits.split_last().unwrap();
<span class="macro">assert_eq!</span>(last, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(rest, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last" class="method"><h4 class="code-header">pub fn <a href="#method.last" class="fn">last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;BitRef&lt;'_, Const, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a reference to the last bit of the bit-slice, or <code>None</code> if it is
empty.</p>
<h6 id="original-5"><a href="#original-5">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last"><code>slice::last</code></a></p>
<h6 id="api-differences-3"><a href="#api-differences-3">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-5"><a href="#examples-5">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(bits.last().as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;'a, I&gt;(
    &amp;'a self,
    index: I
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&lt;I as BitSliceIndex&lt;'a, T, O&gt;&gt;::Immut&gt;<span class="where fmt-newline">where
    I: BitSliceIndex&lt;'a, T, O&gt;,</span></h4></section></summary><div class="docblock"><p>Gets a reference to a single bit or a subsection of the bit-slice,
depending on the type of <code>index</code>.</p>
<ul>
<li>If given a <code>usize</code>, this produces a reference structure to the <code>bool</code>
at the position.</li>
<li>If given any form of range, this produces a smaller bit-slice.</li>
</ul>
<p>This returns <code>None</code> if the <code>index</code> departs the bounds of <code>self</code>.</p>
<h6 id="original-6"><a href="#original-6">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get"><code>slice::get</code></a></p>
<h6 id="api-differences-4"><a href="#api-differences-4">API Differences</a></h6>
<p><code>BitSliceIndex</code> uses discrete types for immutable and mutable
references, rather than a single referent type.</p>
<h6 id="examples-6"><a href="#examples-6">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.get(<span class="number">1</span>).as_deref(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(bits.get(<span class="number">0 </span>.. <span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(bits.get(<span class="number">3</span>).is_none());
<span class="macro">assert!</span>(bits.get(<span class="number">0 </span>.. <span class="number">4</span>).is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;'a, I&gt;(
    &amp;'a self,
    index: I
) -&gt; &lt;I as BitSliceIndex&lt;'a, T, O&gt;&gt;::Immut<span class="where fmt-newline">where
    I: BitSliceIndex&lt;'a, T, O&gt;,</span></h4></section></summary><div class="docblock"><p>Gets a reference to a single bit or to a subsection of the bit-slice,
without bounds checking.</p>
<p>This has the same arguments and behavior as <a href="Self::get"><code>.get()</code></a>, except that it
does not check that <code>index</code> is in bounds.</p>
<h6 id="original-7"><a href="#original-7">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a></p>
<h6 id="safety"><a href="#safety">Safety</a></h6>
<p>You must ensure that <code>index</code> is within bounds (within the range <code>0 .. self.len()</code>), or this method will introduce memory safety and/or
undefined behavior.</p>
<p>It is library-level undefined behavior to index beyond the length of any
bit-slice, even if you <strong>know</strong> that the offset remains within an
allocation as measured by Rust or LLVM.</p>
<h6 id="examples-7"><a href="#examples-7">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>data = <span class="number">0b0001_0010u8</span>;
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;Lsb0&gt;()[.. <span class="number">3</span>];

<span class="kw">unsafe </span>{
  <span class="macro">assert!</span>(bits.get_unchecked(<span class="number">1</span>));
  <span class="macro">assert!</span>(bits.get_unchecked(<span class="number">4</span>));
}</code></pre></div>
</div></details><section id="method.as_ptr" class="method"><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; BitPtr&lt;Const, T, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ðŸ‘Ž</span><span>Deprecated: use <code>.as_bitptr()</code> instead</span></div></span><details class="toggle method-toggle" open><summary><section id="method.as_ptr_range" class="method"><h4 class="code-header">pub fn <a href="#method.as_ptr_range" class="fn">as_ptr_range</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.0/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;BitPtr&lt;Const, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Produces a range of bit-pointers to each bit in the bit-slice.</p>
<p>This is a standard-library range, which has no real functionality for
pointer types. You should prefer <a href="Self::as_bitptr_range"><code>.as_bitptr_range()</code></a> instead, as it
produces a custom structure that provides expected ranging
functionality.</p>
<h6 id="original-8"><a href="#original-8">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr_range"><code>slice::as_ptr_range</code></a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><h4 class="code-header">pub fn <a href="#method.iter" class="fn">iter</a>(&amp;self) -&gt; Iter&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Produces an iterator over each bit in the bit-slice.</p>
<h6 id="original-9"><a href="#original-9">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter"><code>slice::iter</code></a></p>
<h6 id="api-differences-5"><a href="#api-differences-5">API Differences</a></h6>
<p>This iterator yields proxy-reference structures, not <code>&amp;bool</code>. It can be
adapted to yield <code>&amp;bool</code> with the <a href="crate::slice::Iter::by_refs"><code>.by_refs()</code></a> method, or <code>bool</code> with
<a href="crate::slice::Iter::by_vals"><code>.by_vals()</code></a>.</p>
<p>This iterator, and its adapters, are fast. Do not try to be more clever
than them by abusing <code>.as_bitptr_range()</code>.</p>
<h6 id="examples-8"><a href="#examples-8">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.iter();

<span class="macro">assert!</span>(!iter.next().unwrap());
<span class="macro">assert!</span>( iter.next().unwrap());
<span class="macro">assert!</span>( iter.next_back().unwrap());
<span class="macro">assert!</span>(!iter.next_back().unwrap());
<span class="macro">assert!</span>( iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.windows" class="method"><h4 class="code-header">pub fn <a href="#method.windows" class="fn">windows</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>) -&gt; Windows&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over consecutive windowing subslices in a bit-slice.</p>
<p>Windows are overlapping views of the bit-slice. Each window advances one
bit from the previous, so in a bit-slice <code>[A, B, C, D, E]</code>, calling
<code>.windows(3)</code> will yield <code>[A, B, C]</code>, <code>[B, C, D]</code>, and <code>[C, D, E]</code>.</p>
<h6 id="original-10"><a href="#original-10">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.windows"><code>slice::windows</code></a></p>
<h6 id="panics"><a href="#panics">Panics</a></h6>
<p>This panics if <code>size</code> is <code>0</code>.</p>
<h6 id="examples-9"><a href="#examples-9">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.windows(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chunks" class="method"><h4 class="code-header">pub fn <a href="#method.chunks" class="fn">chunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>) -&gt; Chunks&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice.</p>
<p>Unlike <code>.windows()</code>, the subslices this yields do not overlap with each
other. If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the
last chunk yielded will be shorter.</p>
<h6 id="original-11"><a href="#original-11">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks"><code>slice::chunks</code></a></p>
<h6 id="sibling-methods"><a href="#sibling-methods">Sibling Methods</a></h6>
<ul>
<li><a href="Self::chunks_mut"><code>.chunks_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="Self::chunks_exact"><code>.chunks_exact()</code></a> does not yield the final chunk if it is shorter
than <code>chunk_size</code>.</li>
<li><a href="Self::rchunks"><code>.rchunks()</code></a> iterates from the back of the bit-slice to the front,
with the final, possibly-shorter, segment at the front edge.</li>
</ul>
<h6 id="panics-1"><a href="#panics-1">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-10"><a href="#examples-10">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.chunks(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>]));
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chunks_exact" class="method"><h4 class="code-header">pub fn <a href="#method.chunks_exact" class="fn">chunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>) -&gt; ChunksExact&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the last
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="crate::slice::ChunksExact::remainder"><code>.remainder()</code></a> method if the iterator is bound to a name.</p>
<h6 id="original-12"><a href="#original-12">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact"><code>slice::chunks_exact</code></a></p>
<h6 id="sibling-methods-1"><a href="#sibling-methods-1">Sibling Methods</a></h6>
<ul>
<li><a href="Self::chunks"><code>.chunks()</code></a> yields any leftover bits at the end as a shorter chunk
during iteration.</li>
<li><a href="Self::chunks_exact_mut"><code>.chunks_exact_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="Self::rchunks_exact"><code>.rchunks_exact()</code></a> iterates from the back of the bit-slice to the
front, with the unyielded remainder segment at the front edge.</li>
</ul>
<h6 id="panics-2"><a href="#panics-2">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-11"><a href="#examples-11">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.chunks_exact(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(iter.next().is_none());
<span class="macro">assert_eq!</span>(iter.remainder(), <span class="macro">bits!</span>[<span class="number">1</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rchunks" class="method"><h4 class="code-header">pub fn <a href="#method.rchunks" class="fn">rchunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>) -&gt; RChunks&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice, from the back
edge.</p>
<p>Unlike <code>.chunks()</code>, this aligns its chunks to the back edge of <code>self</code>.
If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the
leftover partial chunk is <code>self[0 .. len % chunk_size]</code>.</p>
<h6 id="original-13"><a href="#original-13">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks"><code>slice::rchunks</code></a></p>
<h6 id="sibling-methods-2"><a href="#sibling-methods-2">Sibling Methods</a></h6>
<ul>
<li><a href="Self::rchunks_mut"><code>.rchunks_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="Self::rchunks_exact"><code>.rchunks_exact()</code></a> does not yield the final chunk if it is shorter
than <code>chunk_size</code>.</li>
<li><a href="Self::chunks"><code>.chunks()</code></a> iterates from the front of the bit-slice to the back,
with the final, possibly-shorter, segment at the back edge.</li>
</ul>
<h6 id="panics-3"><a href="#panics-3">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-12"><a href="#examples-12">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rchunks(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>]));
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rchunks_exact" class="method"><h4 class="code-header">pub fn <a href="#method.rchunks_exact" class="fn">rchunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>) -&gt; RChunksExact&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice, from the back
edge.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the first
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="crate::slice::RChunksExact::remainder"><code>.remainder()</code></a> method if the iterator is bound to a name.</p>
<h6 id="original-14"><a href="#original-14">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_exact"><code>slice::rchunks_exact</code></a></p>
<h6 id="sibling-methods-3"><a href="#sibling-methods-3">Sibling Methods</a></h6>
<ul>
<li><a href="Self::rchunks"><code>.rchunks()</code></a> yields any leftover bits at the front as a shorter
chunk during iteration.</li>
<li><a href="Self::rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="Self::chunks_exact"><code>.chunks_exact()</code></a> iterates from the front of the bit-slice to the
back, with the unyielded remainder segment at the back edge.</li>
</ul>
<h6 id="panics-4"><a href="#panics-4">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-13"><a href="#examples-13">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rchunks_exact(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(iter.next().is_none());
<span class="macro">assert_eq!</span>(iter.remainder(), <span class="macro">bits!</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at" class="method"><h4 class="code-header">pub fn <a href="#method.split_at" class="fn">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>) -&gt; (&amp;BitSlice&lt;T, O&gt;, &amp;BitSlice&lt;T, O&gt;)</h4></section></summary><div class="docblock"><p>Splits a bit-slice in two parts at an index.</p>
<p>The returned bit-slices are <code>self[.. mid]</code> and <code>self[mid ..]</code>. <code>mid</code> is
included in the right bit-slice, not the left.</p>
<p>If <code>mid</code> is <code>0</code> then the left bit-slice is empty; if it is <code>self.len()</code>
then the right bit-slice is empty.</p>
<p>This method guarantees that even when either partition is empty, the
encoded bit-pointer values of the bit-slice references is <code>&amp;self[0]</code> and
<code>&amp;self[mid]</code>.</p>
<h6 id="original-15"><a href="#original-15">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at"><code>slice::split_at</code></a></p>
<h6 id="panics-5"><a href="#panics-5">Panics</a></h6>
<p>This panics if <code>mid</code> is greater than <code>self.len()</code>. It is allowed to be
equal to the length, in which case the right bit-slice is simply empty.</p>
<h6 id="examples-14"><a href="#examples-14">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let </span>base = bits.as_bitptr();

<span class="kw">let </span>(a, b) = bits.split_at(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ a.as_bitptr().offset_from(base) }, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ b.as_bitptr().offset_from(base) }, <span class="number">0</span>);

<span class="kw">let </span>(a, b) = bits.split_at(<span class="number">6</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ b.as_bitptr().offset_from(base) }, <span class="number">6</span>);

<span class="kw">let </span>(a, b) = bits.split_at(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(a, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(b, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">3</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; Split&lt;'_, T, O, F&gt;<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.74.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate. The
matched bit is <em>not</em> contained in the yielded bit-slices.</p>
<h6 id="original-16"><a href="#original-16">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split"><code>slice::split</code></a></p>
<h6 id="api-differences-6"><a href="#api-differences-6">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-4"><a href="#sibling-methods-4">Sibling Methods</a></h6>
<ul>
<li><a href="Self::split_mut"><code>.split_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="Self::split_inclusive"><code>.split_inclusive()</code></a> includes the matched bit in the yielded
bit-slice.</li>
<li><a href="Self::rsplit"><code>.rsplit()</code></a> iterates from the back of the bit-slice instead of the
front.</li>
<li><a href="Self::splitn"><code>.splitn()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-15"><a href="#examples-15">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If the first bit is matched, then an empty bit-slice will be the first
item yielded by the iterator. Similarly, if the last bit in the
bit-slice matches, then an empty bit-slice will be the last item
yielded.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If two matched bits are directly adjacent, then an empty bit-slice will
be yielded between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                  ^  ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| !<span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_inclusive" class="method"><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fn">split_inclusive</a>&lt;F&gt;(&amp;self, pred: F) -&gt; SplitInclusive&lt;'_, T, O, F&gt;<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.74.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate. Unlike
<code>.split()</code>, this <em>does</em> include the matching bit as the last bit in the
yielded bit-slice.</p>
<h6 id="original-17"><a href="#original-17">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_inclusive"><code>slice::split_inclusive</code></a></p>
<h6 id="api-differences-7"><a href="#api-differences-7">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-5"><a href="#sibling-methods-5">Sibling Methods</a></h6>
<ul>
<li><a href="Self::split_inclusive_mut"><code>.split_inclusive_mut()</code></a> has the same splitting logic, but each
yielded bit-slice is mutable.</li>
<li><a href="Self::split"><code>.split()</code></a> does not include the matched bit in the yielded
bit-slice.</li>
</ul>
<h6 id="examples-16"><a href="#examples-16">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split_inclusive(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit" class="method"><h4 class="code-header">pub fn <a href="#method.rsplit" class="fn">rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; RSplit&lt;'_, T, O, F&gt;<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.74.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate, from
the back edge. The matched bit is <em>not</em> contained in the yielded
bit-slices.</p>
<h6 id="original-18"><a href="#original-18">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit"><code>slice::rsplit</code></a></p>
<h6 id="api-differences-8"><a href="#api-differences-8">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-6"><a href="#sibling-methods-6">Sibling Methods</a></h6>
<ul>
<li><a href="Self::rsplit_mut"><code>.rsplit_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="Self::split"><code>.split()</code></a> iterates from the front of the bit-slice instead of the
back.</li>
<li><a href="Self::rsplitn"><code>.rsplitn()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-17"><a href="#examples-17">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplit(|pos, _bit| pos % <span class="number">3 </span>== <span class="number">2</span>);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If the last bit is matched, then an empty bit-slice will be the first
item yielded by the iterator. Similarly, if the first bit in the
bit-slice matches, then an empty bit-slice will be the last item
yielded.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplit(|_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
<p>If two yielded bits are directly adjacent, then an empty bit-slice will
be yielded between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                  ^  ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.split(|_pos, bit| !<span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().unwrap().is_empty());
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn" class="method"><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; SplitN&lt;'_, T, O, F&gt;<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.74.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate, giving
up after yielding <code>n</code> times. The <code>n</code>th yield contains the rest of the
bit-slice. As with <code>.split()</code>, the yielded bit-slices do not contain the
matched bit.</p>
<h6 id="original-19"><a href="#original-19">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn"><code>slice::splitn</code></a></p>
<h6 id="api-differences-9"><a href="#api-differences-9">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-7"><a href="#sibling-methods-7">Sibling Methods</a></h6>
<ul>
<li><a href="Self::splitn_mut"><code>.splitn_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="Self::rsplitn"><code>.rsplitn()</code></a> iterates from the back of the bit-slice instead of the
front.</li>
<li><a href="Self::split"><code>.split()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-18"><a href="#examples-18">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>iter = bits.splitn(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn" class="method"><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fn">rsplitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; RSplitN&lt;'_, T, O, F&gt;<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.74.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate from the back edge, giving up after yielding <code>n</code> times. The
<code>n</code>th yield contains the rest of the bit-slice. As with <code>.split_mut()</code>,
the yielded bit-slices do not contain the matched bit.</p>
<h6 id="original-20"><a href="#original-20">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn"><code>slice::rsplitn</code></a></p>
<h6 id="api-differences-10"><a href="#api-differences-10">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-8"><a href="#sibling-methods-8">Sibling Methods</a></h6>
<ul>
<li><a href="Self::rsplitn_mut"><code>.rsplitn_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="Self::splitn"><code>.splitn()</code></a>: iterates from the front of the bit-slice instead of the
back.</li>
<li><a href="Self::rsplit"><code>.rsplit()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-19"><a href="#examples-19">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                        ^
</span><span class="kw">let </span><span class="kw-2">mut </span>iter = bits.rsplitn(<span class="number">2</span>, |_pos, bit| <span class="kw-2">*</span>bit);

<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(iter.next().unwrap(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains" class="method"><h4 class="code-header">pub fn <a href="#method.contains" class="fn">contains</a>&lt;T2, O2&gt;(&amp;self, other: &amp;BitSlice&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    T2: BitStore,
    O2: BitOrder,</span></h4></section></summary><div class="docblock"><p>Tests if the bit-slice contains the given sequence anywhere within it.</p>
<p>This scans over <code>self.windows(other.len())</code> until one of the windows
matches. The search key does not need to share type parameters with the
bit-slice being tested, as the comparison is bit-wise. However, sharing
type parameters will accelerate the comparison.</p>
<h6 id="original-21"><a href="#original-21">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.contains"><code>slice::contains</code></a></p>
<h6 id="examples-20"><a href="#examples-20">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( bits.contains(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(!bits.contains(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with" class="method"><h4 class="code-header">pub fn <a href="#method.starts_with" class="fn">starts_with</a>&lt;T2, O2&gt;(&amp;self, needle: &amp;BitSlice&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    T2: BitStore,
    O2: BitOrder,</span></h4></section></summary><div class="docblock"><p>Tests if the bit-slice begins with the given sequence.</p>
<p>The search key does not need to share type parameters with the bit-slice
being tested, as the comparison is bit-wise. However, sharing type
parameters will accelerate the comparison.</p>
<h6 id="original-22"><a href="#original-22">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.starts_with"><code>slice::starts_with</code></a></p>
<h6 id="examples-21"><a href="#examples-21">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( bits.starts_with(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(!bits.starts_with(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));</code></pre></div>
<p>This always returns <code>true</code> if the needle is empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>empty = <span class="macro">bits!</span>[];
<span class="macro">assert!</span>(bits.starts_with(empty));
<span class="macro">assert!</span>(empty.starts_with(empty));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with" class="method"><h4 class="code-header">pub fn <a href="#method.ends_with" class="fn">ends_with</a>&lt;T2, O2&gt;(&amp;self, needle: &amp;BitSlice&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    T2: BitStore,
    O2: BitOrder,</span></h4></section></summary><div class="docblock"><p>Tests if the bit-slice ends with the given sequence.</p>
<p>The search key does not need to share type parameters with the bit-slice
being tested, as the comparison is bit-wise. However, sharing type
parameters will accelerate the comparison.</p>
<h6 id="original-23"><a href="#original-23">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.ends_with"><code>slice::ends_with</code></a></p>
<h6 id="examples-22"><a href="#examples-22">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( bits.ends_with(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(!bits.ends_with(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));</code></pre></div>
<p>This always returns <code>true</code> if the needle is empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let </span>empty = <span class="macro">bits!</span>[];
<span class="macro">assert!</span>(bits.ends_with(empty));
<span class="macro">assert!</span>(empty.ends_with(empty));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix" class="method"><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fn">strip_prefix</a>&lt;T2, O2&gt;(
    &amp;self,
    prefix: &amp;BitSlice&lt;T2, O2&gt;
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;BitSlice&lt;T, O&gt;&gt;<span class="where fmt-newline">where
    T2: BitStore,
    O2: BitOrder,</span></h4></section></summary><div class="docblock"><p>Removes a prefix bit-slice, if present.</p>
<p>Like <a href="Self::starts_with"><code>.starts_with()</code></a>, the search key does not need to share type
parameters with the bit-slice being stripped. If
<code>self.starts_with(suffix)</code>, then this returns <code>Some(&amp;self[prefix.len() ..])</code>, otherwise it returns <code>None</code>.</p>
<h6 id="original-24"><a href="#original-24">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.strip_prefix"><code>slice::strip_prefix</code></a></p>
<h6 id="api-differences-11"><a href="#api-differences-11">API Differences</a></h6>
<p><code>BitSlice</code> does not support pattern searches; instead, it permits <code>self</code>
and <code>prefix</code> to differ in type parameters.</p>
<h6 id="examples-23"><a href="#examples-23">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.strip_prefix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]).unwrap(), bits[<span class="number">2 </span>..]);
<span class="macro">assert_eq!</span>(bits.strip_prefix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,]).unwrap(), bits[<span class="number">4 </span>..]);
<span class="macro">assert!</span>(bits.strip_prefix(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]).is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix" class="method"><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fn">strip_suffix</a>&lt;T2, O2&gt;(
    &amp;self,
    suffix: &amp;BitSlice&lt;T2, O2&gt;
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;BitSlice&lt;T, O&gt;&gt;<span class="where fmt-newline">where
    T2: BitStore,
    O2: BitOrder,</span></h4></section></summary><div class="docblock"><p>Removes a suffix bit-slice, if present.</p>
<p>Like <a href="Self::ends_with."><code>.ends_with()</code></a>, the search key does not need to share type
parameters with the bit-slice being stripped. If
<code>self.ends_with(suffix)</code>, then this returns <code>Some(&amp;self[.. self.len() - suffix.len()])</code>, otherwise it returns <code>None</code>.</p>
<h6 id="original-25"><a href="#original-25">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.strip_suffix"><code>slice::strip_suffix</code></a></p>
<h6 id="api-differences-12"><a href="#api-differences-12">API Differences</a></h6>
<p><code>BitSlice</code> does not support pattern searches; instead, it permits <code>self</code>
and <code>suffix</code> to differ in type parameters.</p>
<h6 id="examples-24"><a href="#examples-24">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits.strip_suffix(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]).unwrap(), bits[.. <span class="number">7</span>]);
<span class="macro">assert_eq!</span>(bits.strip_suffix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]).unwrap(), bits[.. <span class="number">5</span>]);
<span class="macro">assert!</span>(bits.strip_suffix(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]).is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.align_to" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.align_to" class="fn">align_to</a>&lt;U&gt;(
    &amp;self
) -&gt; (&amp;BitSlice&lt;T, O&gt;, &amp;BitSlice&lt;U, O&gt;, &amp;BitSlice&lt;T, O&gt;)<span class="where fmt-newline">where
    U: BitStore,</span></h4></section></summary><div class="docblock"><p>Produces bit-slice view(s) with different underlying storage types.</p>
<p>This may have unexpected effects, and you cannot assume that
<code>before[idx] == after[idx]</code>! Consult the <a href="https://bitvecto-rs.github.io/bitvec/memory-layout.html">tables in the manual</a>
for information about memory layouts.</p>
<h6 id="original-26"><a href="#original-26">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a></p>
<h6 id="notes"><a href="#notes">Notes</a></h6>
<p>Unlike the standard library documentation, this explicitly guarantees
that the middle bit-slice will have maximal size. You may rely on this
property.</p>
<h6 id="safety-1"><a href="#safety-1">Safety</a></h6>
<p>You may not use this to cast away alias protections. Rust does not have
support for higher-kinded types, so this cannot express the relation
<code>Outer&lt;T&gt; -&gt; Outer&lt;U&gt; where Outer: BitStoreContainer</code>, but memory safety
does require that you respect this rule. ReÃ¤lign integers to integers,
<code>Cell</code>s to <code>Cell</code>s, and atomics to atomics, but do not cross these
boundaries.</p>
<h6 id="examples-25"><a href="#examples-25">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bytes: [u8; <span class="number">7</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
<span class="kw">let </span>bits = bytes.view_bits::&lt;Lsb0&gt;();
<span class="kw">let </span>(pfx, mid, sfx) = <span class="kw">unsafe </span>{
  bits.align_to::&lt;u16&gt;()
};
<span class="macro">assert!</span>(pfx.len() &lt;= <span class="number">8</span>);
<span class="macro">assert_eq!</span>(mid.len(), <span class="number">48</span>);
<span class="macro">assert!</span>(sfx.len() &lt;= <span class="number">8</span>);</code></pre></div>
</div></details><section id="method.to_vec" class="method"><h4 class="code-header">pub fn <a href="#method.to_vec" class="fn">to_vec</a>(&amp;self) -&gt; BitVec&lt;&lt;T as BitStore&gt;::Unalias, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ðŸ‘Ž</span><span>Deprecated: use <code>.to_bitvec()</code> instead</span></div></span><details class="toggle method-toggle" open><summary><section id="method.repeat" class="method"><h4 class="code-header">pub fn <a href="#method.repeat" class="fn">repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>) -&gt; BitVec&lt;&lt;T as BitStore&gt;::Unalias, O&gt;</h4></section></summary><div class="docblock"><p>Creates a bit-vector by repeating a bit-slice <code>n</code> times.</p>
<h6 id="original-27"><a href="#original-27">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.repeat"><code>slice::repeat</code></a></p>
<h6 id="panics-6"><a href="#panics-6">Panics</a></h6>
<p>This method panics if <code>self.len() * n</code> exceeds the <code>BitVec</code> capacity.</p>
<h6 id="examples-26"><a href="#examples-26">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].repeat(<span class="number">3</span>), <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
<p>This panics by exceeding bit-vector maximum capacity:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">â“˜</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].repeat(BitSlice::&lt;usize, Lsb0&gt;::MAX_BITS);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bitptr" class="method"><h4 class="code-header">pub fn <a href="#method.as_bitptr" class="fn">as_bitptr</a>(&amp;self) -&gt; BitPtr&lt;Const, T, O&gt;</h4></section></summary><div class="docblock"><p>Gets a raw pointer to the zeroth bit of the bit-slice.</p>
<h6 id="original-28"><a href="#original-28">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr"><code>slice::as_ptr</code></a></p>
<h6 id="api-differences-13"><a href="#api-differences-13">API Differences</a></h6>
<p>This is renamed in order to indicate that it is returning a <code>bitvec</code>
structure, not a raw pointer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bitptr_range" class="method"><h4 class="code-header">pub fn <a href="#method.as_bitptr_range" class="fn">as_bitptr_range</a>(&amp;self) -&gt; BitPtrRange&lt;Const, T, O&gt;</h4></section></summary><div class="docblock"><p>Views the bit-slice as a half-open range of bit-pointers, to its first
bit <em>in</em> the bit-slice and first bit <em>beyond</em> it.</p>
<h6 id="original-29"><a href="#original-29">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr_range"><code>slice::as_ptr_range</code></a></p>
<h6 id="api-differences-14"><a href="#api-differences-14">API Differences</a></h6>
<p>This is renamed to indicate that it returns a <code>bitvec</code> structure, rather
than an ordinary <code>Range</code>.</p>
<h6 id="notes-1"><a href="#notes-1">Notes</a></h6>
<p><code>BitSlice</code> does define a <a href="Self::as_ptr_range"><code>.as_ptr_range()</code></a>, which returns a
<code>Range&lt;BitPtr&gt;</code>. <code>BitPtrRange</code> has additional capabilities that
<code>Range&lt;*const T&gt;</code> and <code>Range&lt;BitPtr&gt;</code> do not.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_unchecked" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked" class="fn">split_at_unchecked</a>(
    &amp;self,
    mid: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>
) -&gt; (&amp;BitSlice&lt;T, O&gt;, &amp;BitSlice&lt;T, O&gt;)</h4></section></summary><div class="docblock"><p>Splits a bit-slice at an index, without bounds checking.</p>
<p>See <a href="Self::split_at"><code>.split_at()</code></a> for documentation.</p>
<h6 id="safety-2"><a href="#safety-2">Safety</a></h6>
<p>You must ensure that <code>mid</code> is in the range <code>0 ..= self.len()</code>.</p>
<p>This method produces new bit-slice references. If <code>mid</code> is out of
bounds, its behavior is <strong>library-level</strong> undefined. You must
conservatively assume that an out-of-bounds split point produces
compiler-level UB.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bit_domain" class="method"><h4 class="code-header">pub fn <a href="#method.bit_domain" class="fn">bit_domain</a>(&amp;self) -&gt; BitDomain&lt;'_, Const, T, O&gt;</h4></section></summary><div class="docblock"><p>Partitions a bit-slice into maybe-contended and known-uncontended parts.</p>
<p>The documentation of <code>BitDomain</code> goes into this in more detail. In
short, this produces a <code>&amp;BitSlice</code> that is as large as possible without
requiring alias protection, as well as any bits that were not able to be
included in the unaliased bit-slice.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.domain" class="method"><h4 class="code-header">pub fn <a href="#method.domain" class="fn">domain</a>(&amp;self) -&gt; Domain&lt;'_, Const, T, O&gt;</h4></section></summary><div class="docblock"><p>Views the underlying memory of a bit-slice, removing alias protections
where possible.</p>
<p>The documentation of <code>Domain</code> goes into this in more detail. In short,
this produces a <code>&amp;[T]</code> slice with alias protections removed, covering
all elements that <code>self</code> completely fills. Partially-used elements on
either the front or back edge of the slice are returned separately.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.count_ones" class="method"><h4 class="code-header">pub fn <a href="#method.count_ones" class="fn">count_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits set to <code>1</code> in the bit-slice contents.</p>
<h6 id="examples-27"><a href="#examples-27">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits[.. <span class="number">2</span>].count_ones(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(bits[<span class="number">2 </span>..].count_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].count_ones(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.count_zeros" class="method"><h4 class="code-header">pub fn <a href="#method.count_zeros" class="fn">count_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits cleared to <code>0</code> in the bit-slice contents.</p>
<h6 id="examples-28"><a href="#examples-28">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(bits[.. <span class="number">2</span>].count_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(bits[<span class="number">2 </span>..].count_zeros(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].count_zeros(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter_ones" class="method"><h4 class="code-header">pub fn <a href="#method.iter_ones" class="fn">iter_ones</a>(&amp;self) -&gt; IterOnes&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Enumerates the index of each bit in a bit-slice set to <code>1</code>.</p>
<p>This is a shorthand for a <code>.enumerate().filter_map()</code> iterator that
selects the index of each <code>true</code> bit; however, its implementation is
eligible for optimizations that the individual-bit iterator is not.</p>
<p>Specializations for the <code>Lsb0</code> and <code>Msb0</code> orderings allow processors
with instructions that seek particular bits within an element to operate
on whole elements, rather than on each bit individually.</p>
<h6 id="examples-29"><a href="#examples-29">Examples</a></h6>
<p>This example uses <code>.iter_ones()</code>, a <code>.filter_map()</code> that finds the index
of each set bit, and the known indices, in order to show that they have
equivalent behavior.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">let </span>iter_ones = bits.iter_ones();
<span class="kw">let </span>known_indices = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].iter().copied();
<span class="kw">let </span>filter = bits.iter()
  .by_vals()
  .enumerate()
  .filter_map(|(idx, bit)| <span class="kw">if </span>bit { <span class="prelude-val">Some</span>(idx) } <span class="kw">else </span>{ <span class="prelude-val">None </span>});
<span class="kw">let </span>all = iter_ones.zip(known_indices).zip(filter);

<span class="kw">for </span>((iter_one, known), filtered) <span class="kw">in </span>all {
  <span class="macro">assert_eq!</span>(iter_one, known);
  <span class="macro">assert_eq!</span>(known, filtered);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter_zeros" class="method"><h4 class="code-header">pub fn <a href="#method.iter_zeros" class="fn">iter_zeros</a>(&amp;self) -&gt; IterZeros&lt;'_, T, O&gt;</h4></section></summary><div class="docblock"><p>Enumerates the index of each bit in a bit-slice cleared to <code>0</code>.</p>
<p>This is a shorthand for a <code>.enumerate().filter_map()</code> iterator that
selects the index of each <code>false</code> bit; however, its implementation is
eligible for optimizations that the individual-bit iterator is not.</p>
<p>Specializations for the <code>Lsb0</code> and <code>Msb0</code> orderings allow processors
with instructions that seek particular bits within an element to operate
on whole elements, rather than on each bit individually.</p>
<h6 id="examples-30"><a href="#examples-30">Examples</a></h6>
<p>This example uses <code>.iter_zeros()</code>, a <code>.filter_map()</code> that finds the
index of each cleared bit, and the known indices, in order to show that
they have equivalent behavior.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">let </span>iter_zeros = bits.iter_zeros();
<span class="kw">let </span>known_indices = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].iter().copied();
<span class="kw">let </span>filter = bits.iter()
  .by_vals()
  .enumerate()
  .filter_map(|(idx, bit)| <span class="kw">if </span>!bit { <span class="prelude-val">Some</span>(idx) } <span class="kw">else </span>{ <span class="prelude-val">None </span>});
<span class="kw">let </span>all = iter_zeros.zip(known_indices).zip(filter);

<span class="kw">for </span>((iter_zero, known), filtered) <span class="kw">in </span>all {
  <span class="macro">assert_eq!</span>(iter_zero, known);
  <span class="macro">assert_eq!</span>(known, filtered);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.first_one" class="method"><h4 class="code-header">pub fn <a href="#method.first_one" class="fn">first_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the first bit in the bit-slice set to <code>1</code>.</p>
<p>Returns <code>None</code> if there is no <code>true</code> bit in the bit-slice.</p>
<h6 id="examples-31"><a href="#examples-31">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first_one().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].first_one().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].first_one(), <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.first_zero" class="method"><h4 class="code-header">pub fn <a href="#method.first_zero" class="fn">first_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the first bit in the bit-slice cleared to <code>0</code>.</p>
<p>Returns <code>None</code> if there is no <code>false</code> bit in the bit-slice.</p>
<h6 id="examples-32"><a href="#examples-32">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].first_zero().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].first_zero().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].first_zero(), <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last_one" class="method"><h4 class="code-header">pub fn <a href="#method.last_one" class="fn">last_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the last bit in the bit-slice set to <code>1</code>.</p>
<p>Returns <code>None</code> if there is no <code>true</code> bit in the bit-slice.</p>
<h6 id="examples-33"><a href="#examples-33">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last_one().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].last_one().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].last_one(), <span class="prelude-val">Some</span>(<span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.last_zero" class="method"><h4 class="code-header">pub fn <a href="#method.last_zero" class="fn">last_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the last bit in the bit-slice cleared to <code>0</code>.</p>
<p>Returns <code>None</code> if there is no <code>false</code> bit in the bit-slice.</p>
<h6 id="examples-34"><a href="#examples-34">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].last_zero().is_none());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].last_zero().is_none());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].last_zero(), <span class="prelude-val">Some</span>(<span class="number">0</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.leading_ones" class="method"><h4 class="code-header">pub fn <a href="#method.leading_ones" class="fn">leading_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-35"><a href="#examples-35">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].leading_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].leading_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].leading_ones(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.leading_zeros" class="method"><h4 class="code-header">pub fn <a href="#method.leading_zeros" class="fn">leading_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-36"><a href="#examples-36">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].leading_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].leading_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].leading_zeros(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trailing_ones" class="method"><h4 class="code-header">pub fn <a href="#method.trailing_ones" class="fn">trailing_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-37"><a href="#examples-37">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].trailing_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].trailing_ones(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].trailing_ones(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trailing_zeros" class="method"><h4 class="code-header">pub fn <a href="#method.trailing_zeros" class="fn">trailing_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-38"><a href="#examples-38">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].trailing_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].trailing_zeros(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].trailing_zeros(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.any" class="method"><h4 class="code-header">pub fn <a href="#method.any" class="fn">any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if there is at least one bit set to <code>1</code> in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-39"><a href="#examples-39">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(!<span class="macro">bits!</span>[].any());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>].any());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].any());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.all" class="method"><h4 class="code-header">pub fn <a href="#method.all" class="fn">all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if every bit is set to <code>1</code> in the bit-slice.</p>
<p>Returns <code>true</code> when <code>self</code> is empty.</p>
<h6 id="examples-40"><a href="#examples-40">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>( <span class="macro">bits!</span>[].all());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>].all());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">1</span>].all());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.not_any" class="method"><h4 class="code-header">pub fn <a href="#method.not_any" class="fn">not_any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if every bit is cleared to <code>0</code> in the bit-slice.</p>
<p>Returns <code>true</code> when <code>self</code> is empty.</p>
<h6 id="examples-41"><a href="#examples-41">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>( <span class="macro">bits!</span>[].not_any());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">1</span>].not_any());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>].not_any());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.not_all" class="method"><h4 class="code-header">pub fn <a href="#method.not_all" class="fn">not_all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if at least one bit is cleared to <code>0</code> in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-42"><a href="#examples-42">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(!<span class="macro">bits!</span>[].not_all());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">1</span>].not_all());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>].not_all());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.some" class="method"><h4 class="code-header">pub fn <a href="#method.some" class="fn">some</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if at least one bit is set to <code>1</code>, and at least one bit is cleared
to <code>0</code>, in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-43"><a href="#examples-43">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(!<span class="macro">bits!</span>[].some());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">0</span>].some());
<span class="macro">assert!</span>(!<span class="macro">bits!</span>[<span class="number">1</span>].some());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].some());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_aliased" class="method"><h4 class="code-header">pub fn <a href="#method.set_aliased" class="fn">set_aliased</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, using alias-safe operations.</p>
<p>This is equivalent to <a href="Self::set"><code>.set()</code></a>, except that it does not require an
<code>&amp;mut</code> reference, and allows bit-slices with alias-safe storage to share
write permissions.</p>
<h6 id="parameters"><a href="#parameters">Parameters</a></h6>
<ul>
<li><code>&amp;self</code>: This method only exists on bit-slices with alias-safe
storage, and so does not require exclusive access.</li>
<li><code>index</code>: The bit index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="panics-7"><a href="#panics-7">Panics</a></h6>
<p>This panics if <code>index</code> is out of bounds.</p>
<h6 id="examples-44"><a href="#examples-44">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::cell::Cell;

<span class="kw">let </span>bits: <span class="kw-2">&amp;</span>BitSlice&lt;<span class="kw">_</span>, <span class="kw">_</span>&gt; = <span class="macro">bits!</span>[Cell&lt;usize&gt;, Lsb0; <span class="number">0</span>, <span class="number">1</span>];
bits.set_aliased(<span class="number">0</span>, <span class="bool-val">true</span>);
bits.set_aliased(<span class="number">1</span>, <span class="bool-val">false</span>);

<span class="macro">assert_eq!</span>(bits, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_aliased_unchecked" class="method"><h4 class="code-header">pub unsafe fn <a href="#method.set_aliased_unchecked" class="fn">set_aliased_unchecked</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, using alias-safe operations and
without bounds checking.</p>
<p>This is equivalent to <a href="Self::set_unchecked"><code>.set_unchecked()</code></a>, except that it does not
require an <code>&amp;mut</code> reference, and allows bit-slices with alias-safe
storage to share write permissions.</p>
<h6 id="parameters-1"><a href="#parameters-1">Parameters</a></h6>
<ul>
<li><code>&amp;self</code>: This method only exists on bit-slices with alias-safe
storage, and so does not require exclusive access.</li>
<li><code>index</code>: The bit index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="safety-3"><a href="#safety-3">Safety</a></h6>
<p>The caller must ensure that <code>index</code> is not out of bounds.</p>
<h6 id="examples-45"><a href="#examples-45">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>core::cell::Cell;

<span class="kw">let </span>data = Cell::new(<span class="number">0u8</span>);
<span class="kw">let </span>bits = <span class="kw-2">&amp;</span>data.view_bits::&lt;Lsb0&gt;()[.. <span class="number">2</span>];
<span class="kw">unsafe </span>{
  bits.set_aliased_unchecked(<span class="number">3</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(data.get(), <span class="number">8</span>);</code></pre></div>
</div></details><section id="associatedconstant.MAX_BITS" class="associatedconstant"><h4 class="code-header">pub const <a href="#associatedconstant.MAX_BITS" class="constant">MAX_BITS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a> = 2_305_843_009_213_693_951usize</h4></section><section id="associatedconstant.MAX_ELTS" class="associatedconstant"><h4 class="code-header">pub const <a href="#associatedconstant.MAX_ELTS" class="constant">MAX_ELTS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.74.0/std/primitive.usize.html">usize</a> = BitSpan&lt;Const, T, O&gt;::REGION_MAX_ELTS</h4></section><details class="toggle method-toggle" open><summary><section id="method.to_bitvec" class="method"><h4 class="code-header">pub fn <a href="#method.to_bitvec" class="fn">to_bitvec</a>(&amp;self) -&gt; BitVec&lt;&lt;T as BitStore&gt;::Unalias, O&gt;</h4></section></summary><div class="docblock"><p>Copies a bit-slice into an owned bit-vector.</p>
<p>Since the new vector is freshly owned, this gets marked as <code>::Unalias</code>
to remove any guards that may have been inserted by the bit-sliceâ€™s
history.</p>
<p>It does <em>not</em> use the underlying memory type, so that a <code>BitSlice&lt;_, Cell&lt;_&gt;&gt;</code> will produce a <code>BitVec&lt;_, Cell&lt;_&gt;&gt;</code>.</p>
<h6 id="original-30"><a href="#original-30">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></p>
<h6 id="examples-46"><a href="#examples-46">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bitvec::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span>bits = <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>bv = bits.to_bitvec();
<span class="macro">assert_eq!</span>(bits, bv);</code></pre></div>
</div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">Â§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Deref-for-BitVec%3CT,+O%3E" class="impl"><a href="#impl-Deref-for-BitVec%3CT,+O%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.74.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for BitVec&lt;T, O&gt;<span class="where fmt-newline">where
    T: BitStore,
    O: BitOrder,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a href="#associatedtype.Target" class="anchor">Â§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.74.0/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = BitSlice&lt;T, O&gt;</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a href="#method.deref" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.74.0/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;&lt;BitVec&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/1.74.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details></div></section></div></main></body></html>