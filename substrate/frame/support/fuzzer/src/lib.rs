// This file is part of Substrate.

// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Shared code of the fuzzers.
//!
//! This provides the arbitrary types that will be randomly generated by the fuzzing framework.

pub use frame_support::{
	pallet_prelude::NMapKey,
	parameter_types,
	storage::{types::ValueQuery, StorageList as _},
	Blake2_128Concat,
};
use frame_support::{
	pallet_prelude::{StorageList, StoragePagedNMap},
	storage::{types::StoragePagedList, StorageKeyedList},
	traits::StorageInstance,
};
pub use sp_io::{hashing::twox_128, TestExternalities};

/// What storage operation to do.
pub enum Op {
	/// Append some values.
	Append(Vec<u32>),
	/// Try to drain as many items as possible, limited by the inner value.
	Drain(u8),
}

impl arbitrary::Arbitrary<'_> for Op {
	fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
		if u.arbitrary::<bool>()? {
			Ok(Op::Append(Vec::<u32>::arbitrary(u)?))
		} else {
			Ok(Op::Drain(u.arbitrary::<u8>()?))
		}
	}
}

impl Op {
	/// Execute the operation on a List.
	pub fn exec_list<List: StorageList<u32>>(self) -> i64 {
		match self {
			Op::Append(v) => {
				let l = v.len();
				List::append_many(v);
				l as i64
			},
			Op::Drain(v) => -(List::drain().take(v as usize).count() as i64),
		}
	}

	/// Execute the operation on a Map. NOTE: The map is currently hard-coded.
	pub fn exec_map(self, key: u32) -> i64 {
		match self {
			Op::Append(v) => {
				let l = v.len();
				NMap::append_many((key,), v);
				l as i64
			},
			Op::Drain(v) => -(NMap::drain((key,)).take(v as usize).count() as i64),
		}
	}
}

/// An `Op` that also needs a key to function. For example when using it with a map.
pub struct KeyedOp {
	/// The operation to do.
	pub op: Op,
	/// On what key the operation should be done.
	pub key: u32,
}

impl arbitrary::Arbitrary<'_> for KeyedOp {
	fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
		Ok(KeyedOp { op: Op::arbitrary(u)?, key: u.arbitrary::<u32>()? })
	}
}

/// Aggregated version that can be used to fuzz a map and a list at the same time.
pub enum AllInOneOp {
	/// Do a list operation.
	List(Op),
	/// Do an operation on a key (map).
	NMap(KeyedOp),
}

impl arbitrary::Arbitrary<'_> for AllInOneOp {
	fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {
		if u.arbitrary::<bool>()? {
			Ok(AllInOneOp::List(Op::arbitrary(u)?))
		} else {
			Ok(AllInOneOp::NMap(KeyedOp::arbitrary(u)?))
		}
	}
}

parameter_types! {
	/// Changeable heap size that will be used for the list and map.
	pub storage HeapSize: u32 = 20;
}

pub struct Prefix;
impl StorageInstance for Prefix {
	fn pallet_prefix() -> &'static str {
		"test"
	}

	const STORAGE_PREFIX: &'static str = "foo";
}

// NOTE: We use the *same* prefix for the list and the map. This should **never** be done by a
// pallet. We just do it here to show that the storage key derivations of a List and an NMap do not
// collide.

pub type List = StoragePagedList<Prefix, u32, HeapSize>;
pub type NMap = StoragePagedNMap<Prefix, (NMapKey<Blake2_128Concat, u32>,), u32, HeapSize>;
