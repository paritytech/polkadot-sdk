// This file is part of Substrate.

// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::{Account, Asset, AssetDetails, AssetStatus, Config, DepositBalanceOf, Pallet, Vec};
use frame_support::{
	pallet_prelude::*,
	sp_runtime::traits::{Saturating, Zero},
	traits::OnRuntimeUpgrade,
	weights::Weight,
};

#[cfg(feature = "try-runtime")]
use sp_runtime::TryRuntimeError;

pub mod old {
	use super::*;

	#[frame_support::storage_alias]
	/// Details of an asset.
	pub(crate) type Asset<T: Config<I>, I: 'static> = StorageMap<
		Pallet<T, I>,
		Blake2_128Concat,
		<T as Config<I>>::AssetId,
		AssetDetails<
			<T as Config<I>>::Balance,
			<T as frame_system::Config>::AccountId,
			DepositBalanceOf<T, I>,
		>,
	>;

	#[derive(PartialEq, Eq, Clone, Encode, Decode, RuntimeDebug, TypeInfo)]
	pub(crate) struct AssetDetails<Balance, AccountId, DepositBalance> {
		pub owner: AccountId,
		pub issuer: AccountId,
		pub admin: AccountId,
		pub freezer: AccountId,
		pub supply: Balance,
		pub deposit: DepositBalance,
		pub min_balance: Balance,
		pub is_sufficient: bool,
		pub accounts: u32,
		pub sufficients: u32,
		pub approvals: u32,
		pub status: AssetStatus,
	}

	impl<Balance, AccountId, DepositBalance> AssetDetails<Balance, AccountId, DepositBalance>
	where
		Balance: Zero,
	{
		pub(super) fn migrate_to_v2(
			self,
		) -> super::AssetDetails<Balance, AccountId, DepositBalance> {
			super::AssetDetails {
				owner: self.owner,
				issuer: self.issuer,
				admin: self.admin,
				freezer: self.freezer,
				supply: self.supply,
				inactive: Zero::zero(),
				deposit: self.deposit,
				min_balance: self.min_balance,
				is_sufficient: self.is_sufficient,
				accounts: self.accounts,
				sufficients: self.sufficients,
				approvals: self.approvals,
				status: self.status,
			}
		}
	}
}

/// This migration moves all the state to v2 of Assets
pub struct VersionUncheckedMigrateToV2<
	T: Config<I>,
	I: 'static,
	A: Get<Vec<(T::AssetId, T::AccountId)>>,
>(core::marker::PhantomData<(T, I, A)>);

impl<T: Config<I>, I: 'static, A: Get<Vec<(T::AssetId, T::AccountId)>>> OnRuntimeUpgrade
	for VersionUncheckedMigrateToV2<T, I, A>
{
	fn on_runtime_upgrade() -> Weight {
		let mut translated = 0u64;

		Asset::<T, I>::translate::<
			old::AssetDetails<T::Balance, T::AccountId, DepositBalanceOf<T, I>>,
			_,
		>(|_asset_id, old_value| {
			translated.saturating_inc();
			Some(old_value.migrate_to_v2())
		});

		let mut reads = 0u64;
		for (asset_id, account) in A::get() {
			reads.saturating_inc();
			let Some(acc) = Account::<T, I>::get(&asset_id, &account) else {
				log::info!(
					"inactive migration: account {:?} not found for asset {:?}",
					account,
					asset_id
				);
				continue
			};
			Asset::<T, I>::mutate(&asset_id, |asset| match asset {
				Some(asset) => asset.inactive.saturating_accrue(acc.balance),
				None => log::info!("inactive migration: asset {:?} not found", asset_id),
			});
		}

		T::DbWeight::get().reads_writes(translated.saturating_add(reads), translated)
	}

	#[cfg(feature = "try-runtime")]
	fn pre_upgrade() -> Result<Vec<u8>, TryRuntimeError> {
		log::info!("pre-migration assets v2");
		Ok((old::Asset::<T, I>::iter().collect::<Vec<_>>()).encode())
	}

	#[cfg(feature = "try-runtime")]
	fn post_upgrade(old_status: Vec<u8>) -> Result<(), TryRuntimeError> {
		log::info!("post-migration assets v2");

		let mut old_assets: Vec<(
			T::AssetId,
			old::AssetDetails<T::Balance, T::AccountId, DepositBalanceOf<T, I>>,
		)> = Decode::decode(&mut old_status.as_slice()).map_err(|_| {
			"the state parameter should be something that was generated by pre_upgrade"
		})?;

		ensure!(
			old_assets.len() == Asset::<T, I>::iter().count(),
			"the number of assets should be the same"
		);

		let new_assets =
			old_assets.drain(..).map(|(k, v)| (k, v.migrate_to_v2())).collect::<Vec<_>>();

		let inactives = A::get().iter().fold(
			Vec::<(T::AssetId, T::Balance)>::new(),
			|mut acc, (asset_id, account)| {
				let Some(details) = Account::<T, I>::get(&asset_id, &account) else { return acc };
				match acc.iter().position(|(id, _)| id == asset_id) {
					Some(idx) => acc[idx].1.saturating_accrue(details.balance),
					None => acc.push((asset_id.clone(), details.balance)),
				}
				acc
			},
		);

		for (asset_id, mut asset) in new_assets {
			let inactive = inactives
				.iter()
				.find(|(id, _)| *id == asset_id)
				.map(|(_, b)| *b)
				.unwrap_or_else(|| Zero::zero());
			asset.inactive = inactive;
			ensure!(
				Asset::<T, I>::get(&asset_id) == Some(asset),
				"migrated asset does not match expected inactive value"
			);
		}

		Ok(())
	}
}

/// [`VersionUncheckedMigrateToV2`] wrapped in a [`frame_support::migrations::VersionedMigration`],
/// ensuring the migration is only performed when on-chain version is 1.
pub type MigrateToV2<T, I = (), A = ()> = frame_support::migrations::VersionedMigration<
	1,
	2,
	VersionUncheckedMigrateToV2<T, I, A>,
	crate::pallet::Pallet<T, I>,
	<T as frame_system::Config>::DbWeight,
>;
