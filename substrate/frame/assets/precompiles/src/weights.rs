// This file is part of Substrate.

// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Autogenerated weights for `pallet_assets_precompiles`
//!
//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 32.0.0
//! DO NOT EDIT! Use `frame-benchmarking-cli` to regenerate.

#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(missing_docs)]

use frame_support::{traits::Get, weights::{Weight, constants::RocksDbWeight}};
use core::marker::PhantomData;

/// Weight functions needed for `pallet_assets_precompiles` migration.
pub trait WeightInfo {
	/// Weight for migrating a single asset (when the asset needs to be migrated).
	fn migrate_asset_step_migrate() -> Weight;
	/// Weight for processing an asset that is already migrated (skip case).
	fn migrate_asset_step_skip() -> Weight;
	/// Weight for processing an asset when reaching the end of iteration.
	fn migrate_asset_step_finished() -> Weight;
}

/// Default weights for the migration based on RocksDB.
pub struct SubstrateWeight<T>(PhantomData<T>);
impl<T: frame_system::Config> WeightInfo for SubstrateWeight<T> {
	/// Weight for migrating a single asset.
	/// Storage operations:
	/// - 1 read: iter_keys_from or iter_keys (pallet_assets::Asset)
	/// - 1 read: ForeignAssetIdToAssetIndex (check if already mapped)
	/// - 1 read: NextAssetIndex
	/// - 1 write: NextAssetIndex
	/// - 1 write: AssetIndexToForeignAssetId
	/// - 1 write: ForeignAssetIdToAssetIndex
	fn migrate_asset_step_migrate() -> Weight {
		Weight::from_parts(15_000_000, 0)
			.saturating_add(T::DbWeight::get().reads(3))
			.saturating_add(T::DbWeight::get().writes(3))
	}

	/// Weight for processing an asset that is already migrated (skip case).
	/// Storage operations:
	/// - 1 read: iter_keys_from or iter_keys (pallet_assets::Asset)
	/// - 1 read: ForeignAssetIdToAssetIndex (check if already mapped)
	fn migrate_asset_step_skip() -> Weight {
		Weight::from_parts(8_000_000, 0)
			.saturating_add(T::DbWeight::get().reads(2))
	}

	/// Weight for processing when reaching the end of iteration (no more assets).
	/// Storage operations:
	/// - 1 read: iter_keys_from or iter_keys (pallet_assets::Asset) - returns None
	fn migrate_asset_step_finished() -> Weight {
		Weight::from_parts(5_000_000, 0)
			.saturating_add(T::DbWeight::get().reads(1))
	}
}

impl WeightInfo for () {
	fn migrate_asset_step_migrate() -> Weight {
		Weight::from_parts(15_000_000, 0)
			.saturating_add(RocksDbWeight::get().reads(3))
			.saturating_add(RocksDbWeight::get().writes(3))
	}

	fn migrate_asset_step_skip() -> Weight {
		Weight::from_parts(8_000_000, 0)
			.saturating_add(RocksDbWeight::get().reads(2))
	}

	fn migrate_asset_step_finished() -> Weight {
		Weight::from_parts(5_000_000, 0)
			.saturating_add(RocksDbWeight::get().reads(1))
	}
}
