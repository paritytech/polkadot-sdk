#![feature(prelude_import)]
// This file is part of Substrate.

// Copyright (C) Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! # Nomination Pools for Staking Delegation
//!
//! A pallet that allows members to delegate their stake to nominating pools. A nomination pool acts
//! as nominator and nominates validators on the members behalf.
//!
//! # Index
//!
//! * [Key terms](#key-terms)
//! * [Usage](#usage)
//! * [Implementor's Guide](#implementors-guide)
//! * [Design](#design)
//!
//! ## Key Terms
//!
//!  * pool id: A unique identifier of each pool. Set to u32.
//!  * bonded pool: Tracks the distribution of actively staked funds. See [`BondedPool`] and
//! [`BondedPoolInner`].
//! * reward pool: Tracks rewards earned by actively staked funds. See [`RewardPool`] and
//!   [`RewardPools`].
//! * unbonding sub pools: Collection of pools at different phases of the unbonding lifecycle. See
//!   [`SubPools`] and [`SubPoolsStorage`].
//! * members: Accounts that are members of pools. See [`PoolMember`] and [`PoolMembers`].
//! * roles: Administrative roles of each pool, capable of controlling nomination, and the state of
//!   the pool.
//! * point: A unit of measure for a members portion of a pool's funds. Points initially have a
//!   ratio of 1 (as set by `POINTS_TO_BALANCE_INIT_RATIO`) to balance, but as slashing happens,
//!   this can change.
//! * kick: The act of a pool administrator forcibly ejecting a member.
//! * bonded account: A key-less account id derived from the pool id that acts as the bonded
//!   account. This account registers itself as a nominator in the staking system, and follows
//!   exactly the same rules and conditions as a normal staker. Its bond increases or decreases as
//!   members join, it can `nominate` or `chill`, and might not even earn staking rewards if it is
//!   not nominating proper validators.
//! * reward account: A similar key-less account, that is set as the `Payee` account for the bonded
//!   account for all staking rewards.
//! * change rate: The rate at which pool commission can be changed. A change rate consists of a
//!   `max_increase` and `min_delay`, dictating the maximum percentage increase that can be applied
//!   to the commission per number of blocks.
//! * throttle: An attempted commission increase is throttled if the attempted change falls outside
//!   the change rate bounds.
//!
//! ## Usage
//!
//! ### Join
//!
//! An account can stake funds with a nomination pool by calling [`Call::join`].
//!
//! ### Claim rewards
//!
//! After joining a pool, a member can claim rewards by calling [`Call::claim_payout`].
//!
//! A pool member can also set a `ClaimPermission` with [`Call::set_claim_permission`], to allow
//! other members to permissionlessly bond or withdraw their rewards by calling
//! [`Call::bond_extra_other`] or [`Call::claim_payout_other`] respectively.
//!
//! For design docs see the [reward pool](#reward-pool) section.
//!
//! ### Leave
//!
//! In order to leave, a member must take two steps.
//!
//! First, they must call [`Call::unbond`]. The unbond extrinsic will start the unbonding process by
//! unbonding all or a portion of the members funds.
//!
//! > A member can have up to [`Config::MaxUnbonding`] distinct active unbonding requests.
//!
//! Second, once [`sp_staking::StakingInterface::bonding_duration`] eras have passed, the member can
//! call [`Call::withdraw_unbonded`] to withdraw any funds that are free.
//!
//! For design docs see the [bonded pool](#bonded-pool) and [unbonding sub
//! pools](#unbonding-sub-pools) sections.
//!
//! ### Slashes
//!
//! Slashes are distributed evenly across the bonded pool and the unbonding pools from slash era+1
//! through the slash apply era. Thus, any member who either
//!
//! 1. unbonded, or
//! 2. was actively bonded
//
//! in the aforementioned range of eras will be affected by the slash. A member is slashed pro-rata
//! based on its stake relative to the total slash amount.
//!
//! Slashing does not change any single member's balance. Instead, the slash will only reduce the
//! balance associated with a particular pool. But, we never change the total *points* of a pool
//! because of slashing. Therefore, when a slash happens, the ratio of points to balance changes in
//! a pool. In other words, the value of one point, which is initially 1-to-1 against a unit of
//! balance, is now less than one balance because of the slash.
//!
//! ### Administration
//!
//! A pool can be created with the [`Call::create`] call. Once created, the pools nominator or root
//! user must call [`Call::nominate`] to start nominating. [`Call::nominate`] can be called at
//! anytime to update validator selection.
//!
//! Similar to [`Call::nominate`], [`Call::chill`] will chill to pool in the staking system, and
//! [`Call::pool_withdraw_unbonded`] will withdraw any unbonding chunks of the pool bonded account.
//! The latter call is permissionless and can be called by anyone at any time.
//!
//! To help facilitate pool administration the pool has one of three states (see [`PoolState`]):
//!
//! * Open: Anyone can join the pool and no members can be permissionlessly removed.
//! * Blocked: No members can join and some admin roles can kick members. Kicking is not instant,
//!   and follows the same process of `unbond` and then `withdraw_unbonded`. In other words,
//!   administrators can permissionlessly unbond other members.
//! * Destroying: No members can join and all members can be permissionlessly removed with
//!   [`Call::unbond`] and [`Call::withdraw_unbonded`]. Once a pool is in destroying state, it
//!   cannot be reverted to another state.
//!
//! A pool has 4 administrative roles (see [`PoolRoles`]):
//!
//! * Depositor: creates the pool and is the initial member. They can only leave the pool once all
//!   other members have left. Once they fully withdraw their funds, the pool is destroyed.
//! * Nominator: can select which validators the pool nominates.
//! * Bouncer: can change the pools state and kick members if the pool is blocked.
//! * Root: can change the nominator, bouncer, or itself, manage and claim commission, and can
//!   perform any of the actions the nominator or bouncer can.
//!
//! ###¬†Commission
//!
//! A pool can optionally have a commission configuration, via the `root` role, set with
//! [`Call::set_commission`] and claimed with [`Call::claim_commission`]. A payee account must be
//! supplied with the desired commission percentage. Beyond the commission itself, a pool can have a
//! maximum commission and a change rate.
//!
//! Importantly, both max commission  [`Call::set_commission_max`] and change rate
//! [`Call::set_commission_change_rate`] can not be removed once set, and can only be set to more
//! restrictive values (i.e. a lower max commission or a slower change rate) in subsequent updates.
//!
//! If set, a pool's commission is bound to [`GlobalMaxCommission`] at the time it is applied to
//! pending rewards. [`GlobalMaxCommission`] is intended to be updated only via governance.
//!
//! When a pool is dissolved, any outstanding pending commission that has not been claimed will be
//! transferred to the depositor.
//!
//! Implementation note: Commission is analogous to a separate member account of the pool, with its
//! own reward counter in the form of `current_pending_commission`.
//!
//! Crucially, commission is applied to rewards based on the current commission in effect at the
//! time rewards are transferred into the reward pool. This is to prevent the malicious behaviour of
//! changing the commission rate to a very high value after rewards are accumulated, and thus claim
//! an unexpectedly high chunk of the reward.
//!
//! ### Dismantling
//!
//! As noted, a pool is destroyed once
//!
//! 1. First, all members need to fully unbond and withdraw. If the pool state is set to
//!    `Destroying`, this can happen permissionlessly.
//! 2. The depositor itself fully unbonds and withdraws.
//!
//! > Note that at this point, based on the requirements of the staking system, the pool's bonded
//! > account's stake might not be able to ge below a certain threshold as a nominator. At this
//! > point, the pool should `chill` itself to allow the depositor to leave. See [`Call::chill`].
//!
//! ## Implementor's Guide
//!
//! Some notes and common mistakes that wallets/apps wishing to implement this pallet should be
//! aware of:
//!
//!
//! ### Pool Members
//!
//! * In general, whenever a pool member changes their total point, the chain will automatically
//!   claim all their pending rewards for them. This is not optional, and MUST happen for the reward
//!   calculation to remain correct (see the documentation of `bond` as an example). So, make sure
//!   you are warning your users about it. They might be surprised if they see that they bonded an
//!   extra 100 DOTs, and now suddenly their 5.23 DOTs in pending reward is gone. It is not gone, it
//!   has been paid out to you!
//! * Joining a pool implies transferring funds to the pool account. So it might be (based on which
//!   wallet that you are using) that you no longer see the funds that are moved to the pool in your
//!   ‚Äúfree balance‚Äù section. Make sure the user is aware of this, and not surprised by seeing this.
//!   Also, the transfer that happens here is configured to to never accidentally destroy the sender
//!   account. So to join a Pool, your sender account must remain alive with 1 DOT left in it. This
//!   means, with 1 DOT as existential deposit, and 1 DOT as minimum to join a pool, you need at
//!   least 2 DOT to join a pool. Consequently, if you are suggesting members to join a pool with
//!   ‚ÄúMaximum possible value‚Äù, you must subtract 1 DOT to remain in the sender account to not
//!   accidentally kill it.
//! * Points and balance are not the same! Any pool member, at any point in time, can have points in
//!   either the bonded pool or any of the unbonding pools. The crucial fact is that in any of these
//!   pools, the ratio of point to balance is different and might not be 1. Each pool starts with a
//!   ratio of 1, but as time goes on, for reasons such as slashing, the ratio gets broken. Over
//!   time, 100 points in a bonded pool can be worth 90 DOTs. Make sure you are either representing
//!   points as points (not as DOTs), or even better, always display both: ‚ÄúYou have x points in
//!   pool y which is worth z DOTs‚Äù. See here and here for examples of how to calculate point to
//!   balance ratio of each pool (it is almost trivial ;))
//!
//! ### Pool Management
//!
//! * The pool will be seen from the perspective of the rest of the system as a single nominator.
//!   Ergo, This nominator must always respect the `staking.minNominatorBond` limit. Similar to a
//!   normal nominator, who has to first `chill` before fully unbonding, the pool must also do the
//!   same. The pool‚Äôs bonded account will be fully unbonded only when the depositor wants to leave
//!   and dismantle the pool. All that said, the message is: the depositor can only leave the chain
//!   when they chill the pool first.
//!
//! ## Design
//!
//! _Notes_: this section uses pseudo code to explain general design and does not necessarily
//! reflect the exact implementation. Additionally, a working knowledge of `pallet-staking`'s api is
//! assumed.
//!
//! ### Goals
//!
//! * Maintain network security by upholding integrity of slashing events, sufficiently penalizing
//!   members that where in the pool while it was backing a validator that got slashed.
//! * Maximize scalability in terms of member count.
//!
//! In order to maintain scalability, all operations are independent of the number of members. To do
//! this, delegation specific information is stored local to the member while the pool data
//! structures have bounded datum.
//!
//! ### Bonded pool
//!
//! A bonded pool nominates with its total balance, excluding that which has been withdrawn for
//! unbonding. The total points of a bonded pool are always equal to the sum of points of the
//! delegation members. A bonded pool tracks its points and reads its bonded balance.
//!
//! When a member joins a pool, `amount_transferred` is transferred from the members account to the
//! bonded pools account. Then the pool calls `staking::bond_extra(amount_transferred)` and issues
//! new points which are tracked by the member and added to the bonded pool's points.
//!
//! When the pool already has some balance, we want the value of a point before the transfer to
//! equal the value of a point after the transfer. So, when a member joins a bonded pool with a
//! given `amount_transferred`, we maintain the ratio of bonded balance to points such that:
//!
//! ```text
//! balance_after_transfer / points_after_transfer == balance_before_transfer / points_before_transfer;
//! ```
//!
//! To achieve this, we issue points based on the following:
//!
//! ```text
//! points_issued = (points_before_transfer / balance_before_transfer) * amount_transferred;
//! ```
//!
//! For new bonded pools we can set the points issued per balance arbitrarily. In this
//! implementation we use a 1 points to 1 balance ratio for pool creation (see
//! [`POINTS_TO_BALANCE_INIT_RATIO`]).
//!
//! **Relevant extrinsics:**
//!
//! * [`Call::create`]
//! * [`Call::join`]
//!
//! ### Reward pool
//!
//! When a pool is first bonded it sets up a deterministic, inaccessible account as its reward
//! destination. This reward account combined with `RewardPool` compose a reward pool.
//!
//! Reward pools are completely separate entities to bonded pools. Along with its account, a reward
//! pool also tracks its outstanding and claimed rewards as counters, in addition to pending and
//! claimed commission. These counters are updated with `RewardPool::update_records`. The current
//! reward counter of the pool (the total outstanding rewards, in points) is also callable with the
//! `RewardPool::current_reward_counter` method.
//!
//! See [this link](https://hackmd.io/PFGn6wI5TbCmBYoEA_f2Uw) for an in-depth explanation of the
//! reward pool mechanism.
//!
//! **Relevant extrinsics:**
//!
//! * [`Call::claim_payout`]
//!
//! ### Unbonding sub pools
//!
//! When a member unbonds, it's balance is unbonded in the bonded pool's account and tracked in an
//! unbonding pool associated with the active era. If no such pool exists, one is created. To track
//! which unbonding sub pool a member belongs too, a member tracks it's `unbonding_era`.
//!
//! When a member initiates unbonding it's claim on the bonded pool (`balance_to_unbond`) is
//! computed as:
//!
//! ```text
//! balance_to_unbond = (bonded_pool.balance / bonded_pool.points) * member.points;
//! ```
//!
//! If this is the first transfer into an unbonding pool arbitrary amount of points can be issued
//! per balance. In this implementation unbonding pools are initialized with a 1 point to 1 balance
//! ratio (see [`POINTS_TO_BALANCE_INIT_RATIO`]). Otherwise, the unbonding pools hold the same
//! points to balance ratio properties as the bonded pool, so member points in the unbonding pool
//! are issued based on
//!
//! ```text
//! new_points_issued = (points_before_transfer / balance_before_transfer) * balance_to_unbond;
//! ```
//!
//! For scalability, a bound is maintained on the number of unbonding sub pools (see
//! [`TotalUnbondingPools`]). An unbonding pool is removed once its older than `current_era -
//! TotalUnbondingPools`. An unbonding pool is merged into the unbonded pool with
//!
//! ```text
//! unbounded_pool.balance = unbounded_pool.balance + unbonding_pool.balance;
//! unbounded_pool.points = unbounded_pool.points + unbonding_pool.points;
//! ```
//!
//! This scheme "averages" out the points value in the unbonded pool.
//!
//! Once a members `unbonding_era` is older than `current_era -
//! [sp_staking::StakingInterface::bonding_duration]`, it can can cash it's points out of the
//! corresponding unbonding pool. If it's `unbonding_era` is older than `current_era -
//! TotalUnbondingPools`, it can cash it's points from the unbonded pool.
//!
//! **Relevant extrinsics:**
//!
//! * [`Call::unbond`]
//! * [`Call::withdraw_unbonded`]
//!
//! ### Slashing
//!
//! This section assumes that the slash computation is executed by
//! `pallet_staking::StakingLedger::slash`, which passes the information to this pallet via
//! [`sp_staking::OnStakingUpdate::on_slash`].
//!
//! Unbonding pools need to be slashed to ensure all nominators whom where in the bonded pool while
//! it was backing a validator that equivocated are punished. Without these measures a member could
//! unbond right after a validator equivocated with no consequences.
//!
//! This strategy is unfair to members who joined after the slash, because they get slashed as well,
//! but spares members who unbond. The latter is much more important for security: if a pool's
//! validators are attacking the network, their members need to unbond fast! Avoiding slashes gives
//! them an incentive to do that if validators get repeatedly slashed.
//!
//! To be fair to joiners, this implementation also need joining pools, which are actively staking,
//! in addition to the unbonding pools. For maintenance simplicity these are not implemented.
//! Related: <https://github.com/paritytech/substrate/issues/10860>
//!
//! ### Limitations
//!
//! * PoolMembers cannot vote with their staked funds because they are transferred into the pools
//!   account. In the future this can be overcome by allowing the members to vote with their bonded
//!   funds via vote splitting.
//! * PoolMembers cannot quickly transfer to another pool if they do no like nominations, instead
//!   they must wait for the unbonding duration.
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;


use codec::Codec;
use frame_support::{
    defensive, defensive_assert, ensure, pallet_prelude::{MaxEncodedLen, *},
    storage::bounded_btree_map::BoundedBTreeMap,
    traits::{
        fungible::{
            Inspect as FunInspect, InspectFreeze, Mutate as FunMutate,
            MutateFreeze as FunMutateFreeze,
        },
        tokens::{Fortitude, Preservation},
        Defensive, DefensiveOption, DefensiveResult, DefensiveSaturating, Get,
    },
    DefaultNoBound, PalletError,
};
use frame_system::pallet_prelude::BlockNumberFor;
use scale_info::TypeInfo;
use sp_core::U256;
use sp_runtime::{
    traits::{
        AccountIdConversion, Bounded, CheckedAdd, CheckedSub, Convert,
        Saturating, StaticLookup, Zero,
    },
    FixedPointNumber, Perbill,
};
use sp_staking::{EraIndex, StakingInterface};
use sp_std::{
    collections::btree_map::BTreeMap, fmt::Debug, ops::Div, vec::Vec,
};

#[cfg(any(feature = "try-runtime", feature = "fuzzing", test,
debug_assertions))]
use sp_runtime::TryRuntimeError;

/// The log target of this pallet.
pub const LOG_TARGET: &str = "runtime::nomination-pools";
// syntactic sugar for logging.
#[macro_export]
macro_rules! log {
    ($level : tt, $patter : expr $(, $values : expr) * $(,) ?) =>
    {
        log :: $level!
        (target : $crate :: LOG_TARGET, concat!
        ("[{:?}] üèä‚Äç‚ôÇÔ∏è ", $patter), < frame_system :: Pallet < T >> ::
        block_number() $(, $values) *)
    } ;
}


pub mod migration {














    // accuracy note: Reward counters are `FixedU128` with base of 10^18. This value is being
    // multiplied by a point. The worse case of a point is 10x the granularity of the balance
    // (10x is the common configuration of `MaxPointsToBalance`).
    //
    // Assuming roughly the current issuance of polkadot (12,047,781,394,999,601,455, which is
    // 1.2 * 10^9 * 10^10 = 1.2 * 10^19), the worse case point value is around 10^20.
    //
    // The final multiplication is:
    //
    // rc * 10^20 / 10^18 = rc * 100
    //
    // the implementation of `multiply_by_rational_with_rounding` shows that it will only fail
    // if the final division is not enough to fit in u128. In other words, if `rc * 100` is more
    // than u128::max. Given that RC is interpreted as reward per unit of point, and unit of
    // point is equal to balance (normally), and rewards are usually a proportion of the points
    // in the pool, the likelihood of rc reaching near u128::MAX is near impossible.





    // if the `SubPools::with_era` has already been merged into the
    // `SubPools::no_era` use this pool instead.






    // NOTE: if only drain-filter was stable..



    // A pool's possible commission claiming permissions.

    // Whether commission can be claimed permissionlessly, or whether an account can claim
    // commission. `Root` role can always claim.


    // do not throttle if `to` is the same or a decrease in commission.
    // Test for `max_increase` throttling.
    //
    // Throttled if the attempted increase in commission is greater than `max_increase`.

    // Test for `min_delay` throttling.
    //
    // Note: matching `None` is defensive only. `throttle_from` should always exist where
    // `change_rate` has already been set, so this scenario should never happen.
    // if `min_delay` is zero (no delay), not throttling.
    // throttling if blocks passed is less than `min_delay`.























    // NOTE: do not optimize by removing `balance`. it must be computed before mutating
    // `self.point`.



    // Note on why we can't use `Currency::reducible_balance`: Since pooled account has a
    // provider (staking pallet), the account can not be set expendable by
    // `pallet-nomination-pool`. This means reducible balance always returns balance preserving
    // ED in the account. What we want though is transferable balance given the account can be
    // dusted.











    // we need to ensure that `self.member_counter == 1` as well, because the depositor's
    // initial `MinCreateBond` (or more) is what guarantees that the ledger of the pool does not
    // get killed in the staking system, and that it does not fall below `MinimumNominatorBond`,
    // which could prevent other non-depositor members from fully leaving. Thus, all members
    // must withdraw, then depositor can unbond, and finally withdraw after waiting another
    // cycle.



    // We checked for zero above


    // Pool points can inflate relative to balance, but only if the pool is slashed.
    // If we cap the ratio of points:balance so one cannot join a pool that has been slashed
    // by `max_points_to_balance`%, if not zero.

    // then we can be decently confident the bonding pool points will not overflow
    // `BalanceOf<T>`. Note that these are just heuristics.





    // any partial unbonding is only ever allowed if this unbond is permissioned.

    // any unbond must comply with the balance condition:

    // additional checks:
    // permission depositor unbond: if destroying and pool is empty, always allowed,
    // with no additional limits.
    // everything good, let them unbond anything.
    // depositor cannot fully unbond yet.
    // If the pool is blocked, then an admin with kicking permissions can remove a
    // member. If the pool is being destroyed, anyone can remove a member
    // the depositor can simply not be unbonded permissionlessly, period.


    // This isn't a depositor

    // Cache the value
    // We must calculate the points issued *before* we bond who's funds, else points:balance
    // ratio will be wrong.

    // The pool should always be created in such a way its in a state to bond extra, but if
    // the active balance is slashed below the minimum bonded or the account cannot be
    // found, we exit early.


    // Set the state of `self`, and deposit an event if the state changed. State should never be set
    // directly in in order to ensure a state change event is always correctly deposited.








    // Store the reward counter at the time of this update. This is used in subsequent calls to
    // `current_reward_counter`, whereby newly pending rewards (in points) are added to this
    // value.

    // Add any new pending commission that has been calculated from `current_reward_counter` to
    // determine the total pending commission at the time of this update.

    // Total payouts are essentially the entire historical balance of the reward pool, equating
    // to the current balance + the total rewards that have left the pool + the total commission
    // that has left the pool.

    // Store the total payouts at the time of this update.
    //
    // An increase in ED could cause `last_recorded_total_payouts` to decrease but we should not
    // allow that to happen since an already paid out reward cannot decrease. The reward account
    // might go in deficit temporarily in this exceptional case but it will be corrected once
    // new rewards are added to the pool.



    // Calculate the current payout balance. The first 3 values of this calculation added
    // together represent what the balance would be if no payouts were made. The
    // `last_recorded_total_payouts` is then subtracted from this value to cancel out previously
    // recorded payouts, leaving only the remaining payouts that have not been claimed.

    // Split the `current_payout_balance` into claimable rewards and claimable commission
    // according to the current commission rate.

    // * accuracy notes regarding the multiplication in `checked_from_rational`:
    // `current_payout_balance` is a subset of the total_issuance at the very worse.
    // `bonded_points` are similarly, in a non-slashed pool, have the same granularity as
    // balance, and are thus below within the range of total_issuance. In the worse case
    // scenario, for `saturating_from_rational`, we have:
    //
    // dot_total_issuance * 10^18 / `minJoinBond`
    //
    // assuming `MinJoinBond == ED`
    //
    // dot_total_issuance * 10^18 / 10^10 = dot_total_issuance * 10^8
    //
    // which, with the current numbers, is a miniscule fraction of the u128 capacity.
    //
    // Thus, adding two values of type reward counter should be safe for ages in a chain like
    // Polkadot. The important note here is that `reward_pool.last_recorded_reward_counter` only
    // ever accumulates, but its semantics imply that it is less than total_issuance, when
    // represented as `FixedU128`, which means it is less than `total_issuance * 10^18`.
    //
    // * accuracy notes regarding `checked_from_rational` collapsing to zero, meaning that no
    //   reward can be claimed:
    //
    // largest `bonded_points`, such that the reward counter is non-zero, with `FixedU128` will
    // be when the payout is being computed. This essentially means `payout/bonded_points` needs
    // to be more than 1/1^18. Thus, assuming that `bonded_points` will always be less than `10
    // * dot_total_issuance`, if the reward_counter is the smallest possible value, the value of
    //   the
    // reward being calculated is:
    //
    // x / 10^20 = 1/ 10^18
    //
    // x = 100
    //
    // which is basically 10^-8 DOTs. See `smallest_claimable_reward` for an example of this.










    // Ex: if `TotalUnbondingPools` is 5 and current era is 10, we only want to retain pools
    // 6..=10. Note that in the first few eras where `checked_sub` is `None`, we don't remove
    // anything.
    // keep
    // merge into the no-era pool




    // NOTE: this may be dangerous in the scenario bonding_duration gets decreased because
    // we would no longer be able to decode `BoundedBTreeMap::<EraIndex, UnbondPool<T>,
    // TotalUnbondingPools<T>>`, which uses `TotalUnbondingPools` as the bound

























    // To get or insert a pool see [`BondedPool::get`] and [`BondedPool::put`]

















    // If a member already exists that means they already belong to a pool


    // IMPORTANT: reward pool records must be updated with the old points.


    // we just updated `last_known_reward_counter` to the current one in
    // `update_recorded`.




    // NOTE: this transaction is implemented with the sole purpose of readability and
    // correctness, not optimization. We read/write several storage items multiple times instead
    // of just once, in the spirit reusing code.




    // Claim the the payout prior to unbonding. Once the user is unbonding their points no
    // longer exist in the bonded pool and thus they can no longer claim their payouts. It
    // is not strictly necessary to claim the rewards, but we do it here for UX.


    // Unbond in the actual underlying nominator.

    // Note that we lazily create the unbonding pools here if they don't already exist

    // Update the unbond pool associated with the current era with the unbonded funds. Note
    // that we lazily create the unbond pool if it does not yet exist.
    // The above call to `maybe_merge_pools` should ensure there is
    // always enough space to insert.

    // The above check ensures the pool exists.

    // Try and unbond in the member map.


    // Now that we know everything has worked write the items to storage.


    // For now we only allow a pool to withdraw unbonded if its not destroying. If the pool
    // is destroying then `withdraw_unbonded` can be used.





    // NOTE: must do this after we have done the `ok_to_withdraw_unbonded_other_with` check.

    // Before calculating the `balance_to_unbond`, we call withdraw unbonded to ensure the
    // `transferrable_balance` is correct.

    // defensive-only: the depositor puts enough funds into the stash so that it will only
    // be destroyed when they are leaving.

    // A pool does not belong to this era, so it must have been merged to the
    // era-less pool.
    // A call to this transaction may cause the pool's stash to get dusted. If this
    // happens before the last member has withdrawn, then all subsequent withdraws will
    // be 0. However the unbond pools do no get updated to reflect this. In the
    // aforementioned scenario, this check ensures we don't try to withdraw funds that
    // don't exist. This check is also defensive in cases where the unbond pool does not
    // update its balance (e.g. a bug in the slashing hook.) We gracefully proceed in
    // order to ensure members can leave the pool and it can be destroyed.



    // remove any `ClaimPermission` associated with the member.

    // member being reaped.

    // we certainly don't need to delete any pools, because no one is being removed.










    // If the pool has bad properties, then anyone can set it as destroying


















    //

    // IMPORTANT: make sure that everything up to this point is using the current commission
    // before it updates. Note that `try_update_current` could still fail at this point.


















    // remove the ED restriction from the pool reward account.

    // Kill accounts from storage by making their balance go below ED. We assume that the
    // accounts have no references that would prevent destruction once we get to this point. We
    // don't work with the system pallet directly, but
    // 1. we drain the reward account and kill it. This account should never have any extra
    // consumers anyway.
    // 2. the bonded account should become a 'killed stash' in the staking system, and all of
    //    its consumers removed.

    // This shouldn't fail, but if it does we don't really care. Remaining balance can consist
    // of unclaimed pending commission, erroneous transfers to the reward account, etc.

    // NOTE: Defensively force set balance to zero.

    // Remove bonded pool metadata.



    // NOTE: in order to have a distinction in the test account id type (u128), we put
    // account_type first so it does not get truncated out.



    // The pool was totally slashed.
    // This is the equivalent of `(current_points / 1) * new_funds`.
    // Equivalent to (current_points / current_balance) * new_funds
    // We check for zero above

    // There is nothing to unbond

    // Equivalent of (current_balance / current_points) * points
    // We check for zero above

    // Emits events and potentially modifies pool state if any arithmetic saturates, but does
    // not persist any of the mutable inputs to storage.

    // a member who has no skin in the game anymore cannot claim any rewards.


    // Determine the pending rewards. In scenarios where commission is 100%, `pending_rewards`
    // will be zero.

    // IFF the reward is non-zero alter the member and reward pool info.

    // defensive: the depositor has put existential deposit into the pool and it stays
    // untouched, reward account shall not die.





    // Transfer the minimum balance for the reward account.

    // Restrict reward account balance from going below ED.







    // payout related stuff: we must claim the payouts, and updated recorded payout data
    // before updating the bonded pool points, similar to that of `join` transaction.







    // IMPORTANT: ensure newly pending commission not yet processed is added to
    // `total_commission_pending`.



    // Payout claimed commission.

    // Add pending commission to total claimed counter.
    // Reset total pending commission counter to zero.







    // Update frozen amount with current ED.

    // Transfer excess back to depositor.
    // Transfer ED deficit from depositor to the pool




    // note: while a bit wacky, since they have the same key, even collecting to vec should
    // result in the same set of keys, in the same order.





    // else this pool has been heavily slashed and cannot have any rewards anymore.


    // the sum of the pending rewards must be less than the leftover balance. Since the
    // reward math rounds down, we might accumulate some dust here.

    // If this happens, this is most likely due to an old bug and not a recent code change.
    // We warn about this in try-runtime checks but do not panic.












    // Warn if any pool has incorrect ED frozen. We don't want to fail hard as this could be a
    // result of an intentional ED change.









    // Bonded balance is always read directly from staking, therefore we don't need to update
    // anything here.
    // As the slashed account belongs to a `BondedPool` the `TotalValueLocked` decreases and
    // an event is emitted.

    // set the reduced balance for each of the `SubPools`
    use super::*;
    use crate::log;
    use frame_support::traits::OnRuntimeUpgrade;
    use sp_std::{collections::btree_map::BTreeMap, vec::Vec};
    /// Exports for versioned migration `type`s for this pallet.
    pub mod versioned {
        use super::*;
        /// v8: Adds commission claim permissions to `BondedPools`.
        pub type V7ToV8<T> =
            frame_support::migrations::VersionedMigration<7, 8,
            v8::VersionUncheckedMigrateV7ToV8<T>, crate::pallet::Pallet<T>,
            <T as frame_system::Config>::DbWeight>;
        /// Migration V6 to V7 wrapped in a [`frame_support::migrations::VersionedMigration`], ensuring
        /// the migration is only performed when on-chain version is 6.
        pub type V6ToV7<T> =
            frame_support::migrations::VersionedMigration<6, 7,
            v7::VersionUncheckedMigrateV6ToV7<T>, crate::pallet::Pallet<T>,
            <T as frame_system::Config>::DbWeight>;
        /// Wrapper over `MigrateToV6` with convenience version checks.
        pub type V5toV6<T> =
            frame_support::migrations::VersionedMigration<5, 6,
            v6::MigrateToV6<T>, crate::pallet::Pallet<T>,
            <T as frame_system::Config>::DbWeight>;
    }
    pub mod v8 {
        use super::{v7::V7BondedPoolInner, *};
        impl<T: Config> V7BondedPoolInner<T> {
            fn migrate_to_v8(self) -> BondedPoolInner<T> {
                BondedPoolInner {
                    commission: Commission {
                        current: self.commission.current,
                        max: self.commission.max,
                        change_rate: self.commission.change_rate,
                        throttle_from: self.commission.throttle_from,
                        claim_permission: None,
                    },
                    member_counter: self.member_counter,
                    points: self.points,
                    roles: self.roles,
                    state: self.state,
                }
            }
        }
        pub struct VersionUncheckedMigrateV7ToV8<T>(sp_std::marker::PhantomData<T>);
        impl<T: Config> OnRuntimeUpgrade for VersionUncheckedMigrateV7ToV8<T>
            {
            fn on_runtime_upgrade() -> Weight {
                let mut translated = 0u64;
                BondedPools::<T>::translate::<V7BondedPoolInner<T>,
                        _>(|_key, old_value|
                        {
                            translated.saturating_inc();
                            Some(old_value.migrate_to_v8())
                        });
                T::DbWeight::get().reads_writes(translated, translated + 1)
            }
        }
    }
    /// This migration accumulates and initializes the [`TotalValueLocked`] for all pools.
    ///
    /// WARNING: This migration works under the assumption that the [`BondedPools`] cannot be inflated
    /// arbitrarily. Otherwise this migration could fail due to too high weight.
    pub(crate) mod v7 {
        use super::*;
        #[codec(mel_bound(T : Config))]
        #[scale_info(skip_type_params(T))]
        pub struct V7Commission<T: Config> {
            pub current: Option<(Perbill, T::AccountId)>,
            pub max: Option<Perbill>,
            pub change_rate: Option<CommissionChangeRate<BlockNumberFor<T>>>,
            pub throttle_from: Option<BlockNumberFor<T>>,
        }
        #[allow(deprecated)]
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::codec::Encode for V7Commission<T> where
                    Option<(Perbill, T::AccountId)>: ::codec::Encode,
                    Option<(Perbill, T::AccountId)>: ::codec::Encode,
                    Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Encode,
                    Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Encode,
                    Option<BlockNumberFor<T>>: ::codec::Encode,
                    Option<BlockNumberFor<T>>: ::codec::Encode {
                    fn size_hint(&self) -> usize {
                        0_usize.saturating_add(::codec::Encode::size_hint(&self.current)).saturating_add(::codec::Encode::size_hint(&self.max)).saturating_add(::codec::Encode::size_hint(&self.change_rate)).saturating_add(::codec::Encode::size_hint(&self.throttle_from))
                    }
                    fn encode_to<__CodecOutputEdqy: ::codec::Output +
                        ?::core::marker::Sized>(&self,
                        __codec_dest_edqy: &mut __CodecOutputEdqy) {
                        ::codec::Encode::encode_to(&self.current,
                            __codec_dest_edqy);
                        ::codec::Encode::encode_to(&self.max, __codec_dest_edqy);
                        ::codec::Encode::encode_to(&self.change_rate,
                            __codec_dest_edqy);
                        ::codec::Encode::encode_to(&self.throttle_from,
                            __codec_dest_edqy);
                    }
                }
                #[automatically_derived]
                impl<T: Config> ::codec::EncodeLike for V7Commission<T> where
                    Option<(Perbill, T::AccountId)>: ::codec::Encode,
                    Option<(Perbill, T::AccountId)>: ::codec::Encode,
                    Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Encode,
                    Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Encode,
                    Option<BlockNumberFor<T>>: ::codec::Encode,
                    Option<BlockNumberFor<T>>: ::codec::Encode {
                }
            };
        #[allow(deprecated)]
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::codec::Decode for V7Commission<T> where
                    Option<(Perbill, T::AccountId)>: ::codec::Decode,
                    Option<(Perbill, T::AccountId)>: ::codec::Decode,
                    Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Decode,
                    Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Decode,
                    Option<BlockNumberFor<T>>: ::codec::Decode,
                    Option<BlockNumberFor<T>>: ::codec::Decode {
                    fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                            &mut __CodecInputEdqy)
                        -> ::core::result::Result<Self, ::codec::Error> {
                        ::core::result::Result::Ok(V7Commission::<T> {
                                current: {
                                    let __codec_res_edqy =
                                        <Option<(Perbill, T::AccountId)> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `V7Commission::current`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                max: {
                                    let __codec_res_edqy =
                                        <Option<Perbill> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `V7Commission::max`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                change_rate: {
                                    let __codec_res_edqy =
                                        <Option<CommissionChangeRate<BlockNumberFor<T>>> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `V7Commission::change_rate`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                throttle_from: {
                                    let __codec_res_edqy =
                                        <Option<BlockNumberFor<T>> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `V7Commission::throttle_from`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                            })
                    }
                }
            };
        const _: () =
            {
                impl<T: Config> ::codec::MaxEncodedLen for V7Commission<T>
                    where T: Config {
                    fn max_encoded_len() -> ::core::primitive::usize {
                        0_usize.saturating_add(<Option<(Perbill,
                                                T::AccountId)>>::max_encoded_len()).saturating_add(<Option<Perbill>>::max_encoded_len()).saturating_add(<Option<CommissionChangeRate<BlockNumberFor<T>>>>::max_encoded_len()).saturating_add(<Option<BlockNumberFor<T>>>::max_encoded_len())
                    }
                }
            };
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                impl<T: Config> ::scale_info::TypeInfo for V7Commission<T>
                    where
                    Option<(Perbill, T::AccountId)>: ::scale_info::TypeInfo +
                    'static,
                    Option<CommissionChangeRate<BlockNumberFor<T>>>: ::scale_info::TypeInfo +
                    'static, Option<BlockNumberFor<T>>: ::scale_info::TypeInfo +
                    'static, T: Config + 'static {
                    type Identity = Self;
                    fn type_info() -> ::scale_info::Type {
                        ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("V7Commission",
                                        "pallet_nomination_pools::migration::v7",
                                        &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                    ::core::option::Option::None)]))).composite(::scale_info::build::Fields::named().field(|f|
                                                f.ty::<Option<(Perbill,
                                                            T::AccountId)>>().name("current").type_name("Option<(Perbill, T::AccountId)>")).field(|f|
                                            f.ty::<Option<Perbill>>().name("max").type_name("Option<Perbill>")).field(|f|
                                        f.ty::<Option<CommissionChangeRate<BlockNumberFor<T>>>>().name("change_rate").type_name("Option<CommissionChangeRate<BlockNumberFor<T>>>")).field(|f|
                                    f.ty::<Option<BlockNumberFor<T>>>().name("throttle_from").type_name("Option<BlockNumberFor<T>>")))
                    }
                }
                ;
            };
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::core::fmt::Debug for V7Commission<T> {
                    fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        fmt.debug_struct("V7Commission").field("current",
                                            &self.current).field("max",
                                        &self.max).field("change_rate",
                                    &self.change_rate).field("throttle_from",
                                &self.throttle_from).finish()
                    }
                }
            };
        #[automatically_derived]
        impl<T: Config> ::core::marker::StructuralPartialEq for
            V7Commission<T> {
        }
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for
            V7Commission<T> where T::AccountId: ::core::cmp::PartialEq {
            #[inline]
            fn eq(&self, other: &V7Commission<T>) -> bool {
                self.current == other.current && self.max == other.max &&
                        self.change_rate == other.change_rate &&
                    self.throttle_from == other.throttle_from
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for
            V7Commission<T> where T::AccountId: ::core::clone::Clone {
            #[inline]
            fn clone(&self) -> V7Commission<T> {
                V7Commission {
                    current: ::core::clone::Clone::clone(&self.current),
                    max: ::core::clone::Clone::clone(&self.max),
                    change_rate: ::core::clone::Clone::clone(&self.change_rate),
                    throttle_from: ::core::clone::Clone::clone(&self.throttle_from),
                }
            }
        }
        #[codec(mel_bound(T : Config))]
        #[scale_info(skip_type_params(T))]
        pub struct V7BondedPoolInner<T: Config> {
            pub commission: V7Commission<T>,
            pub member_counter: u32,
            pub points: BalanceOf<T>,
            pub roles: PoolRoles<T::AccountId>,
            pub state: PoolState,
        }
        #[allow(deprecated)]
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::codec::Encode for V7BondedPoolInner<T> where
                    V7Commission<T>: ::codec::Encode,
                    V7Commission<T>: ::codec::Encode,
                    BalanceOf<T>: ::codec::Encode,
                    BalanceOf<T>: ::codec::Encode,
                    PoolRoles<T::AccountId>: ::codec::Encode,
                    PoolRoles<T::AccountId>: ::codec::Encode {
                    fn size_hint(&self) -> usize {
                        0_usize.saturating_add(::codec::Encode::size_hint(&self.commission)).saturating_add(::codec::Encode::size_hint(&self.member_counter)).saturating_add(::codec::Encode::size_hint(&self.points)).saturating_add(::codec::Encode::size_hint(&self.roles)).saturating_add(::codec::Encode::size_hint(&self.state))
                    }
                    fn encode_to<__CodecOutputEdqy: ::codec::Output +
                        ?::core::marker::Sized>(&self,
                        __codec_dest_edqy: &mut __CodecOutputEdqy) {
                        ::codec::Encode::encode_to(&self.commission,
                            __codec_dest_edqy);
                        ::codec::Encode::encode_to(&self.member_counter,
                            __codec_dest_edqy);
                        ::codec::Encode::encode_to(&self.points, __codec_dest_edqy);
                        ::codec::Encode::encode_to(&self.roles, __codec_dest_edqy);
                        ::codec::Encode::encode_to(&self.state, __codec_dest_edqy);
                    }
                }
                #[automatically_derived]
                impl<T: Config> ::codec::EncodeLike for V7BondedPoolInner<T>
                    where V7Commission<T>: ::codec::Encode,
                    V7Commission<T>: ::codec::Encode,
                    BalanceOf<T>: ::codec::Encode,
                    BalanceOf<T>: ::codec::Encode,
                    PoolRoles<T::AccountId>: ::codec::Encode,
                    PoolRoles<T::AccountId>: ::codec::Encode {
                }
            };
        #[allow(deprecated)]
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::codec::Decode for V7BondedPoolInner<T> where
                    V7Commission<T>: ::codec::Decode,
                    V7Commission<T>: ::codec::Decode,
                    BalanceOf<T>: ::codec::Decode,
                    BalanceOf<T>: ::codec::Decode,
                    PoolRoles<T::AccountId>: ::codec::Decode,
                    PoolRoles<T::AccountId>: ::codec::Decode {
                    fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                            &mut __CodecInputEdqy)
                        -> ::core::result::Result<Self, ::codec::Error> {
                        ::core::result::Result::Ok(V7BondedPoolInner::<T> {
                                commission: {
                                    let __codec_res_edqy =
                                        <V7Commission<T> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `V7BondedPoolInner::commission`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                member_counter: {
                                    let __codec_res_edqy =
                                        <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `V7BondedPoolInner::member_counter`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                points: {
                                    let __codec_res_edqy =
                                        <BalanceOf<T> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `V7BondedPoolInner::points`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                roles: {
                                    let __codec_res_edqy =
                                        <PoolRoles<T::AccountId> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `V7BondedPoolInner::roles`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                state: {
                                    let __codec_res_edqy =
                                        <PoolState as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `V7BondedPoolInner::state`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                            })
                    }
                }
            };
        const _: () =
            {
                impl<T: Config> ::codec::MaxEncodedLen for
                    V7BondedPoolInner<T> where T: Config {
                    fn max_encoded_len() -> ::core::primitive::usize {
                        0_usize.saturating_add(<V7Commission<T>>::max_encoded_len()).saturating_add(<u32>::max_encoded_len()).saturating_add(<BalanceOf<T>>::max_encoded_len()).saturating_add(<PoolRoles<T::AccountId>>::max_encoded_len()).saturating_add(<PoolState>::max_encoded_len())
                    }
                }
            };
        #[allow(non_upper_case_globals, unused_attributes,
        unused_qualifications)]
        const _: () =
            {
                impl<T: Config> ::scale_info::TypeInfo for
                    V7BondedPoolInner<T> where
                    V7Commission<T>: ::scale_info::TypeInfo + 'static,
                    BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                    PoolRoles<T::AccountId>: ::scale_info::TypeInfo + 'static,
                    T: Config + 'static {
                    type Identity = Self;
                    fn type_info() -> ::scale_info::Type {
                        ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("V7BondedPoolInner",
                                        "pallet_nomination_pools::migration::v7",
                                        &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                    ::core::option::Option::None)]))).composite(::scale_info::build::Fields::named().field(|f|
                                                    f.ty::<V7Commission<T>>().name("commission").type_name("V7Commission<T>")).field(|f|
                                                f.ty::<u32>().name("member_counter").type_name("u32")).field(|f|
                                            f.ty::<BalanceOf<T>>().name("points").type_name("BalanceOf<T>")).field(|f|
                                        f.ty::<PoolRoles<T::AccountId>>().name("roles").type_name("PoolRoles<T::AccountId>")).field(|f|
                                    f.ty::<PoolState>().name("state").type_name("PoolState")))
                    }
                }
                ;
            };
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::core::fmt::Debug for V7BondedPoolInner<T> {
                    fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        fmt.debug_struct("V7BondedPoolInner").field("commission",
                                                &self.commission).field("member_counter",
                                            &self.member_counter).field("points",
                                        &self.points).field("roles",
                                    &self.roles).field("state", &self.state).finish()
                    }
                }
            };
        #[automatically_derived]
        impl<T: Config> ::core::marker::StructuralPartialEq for
            V7BondedPoolInner<T> {
        }
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for
            V7BondedPoolInner<T> where T::AccountId: ::core::cmp::PartialEq {
            #[inline]
            fn eq(&self, other: &V7BondedPoolInner<T>) -> bool {
                self.commission == other.commission &&
                                self.member_counter == other.member_counter &&
                            self.points == other.points && self.roles == other.roles &&
                    self.state == other.state
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for
            V7BondedPoolInner<T> where T::AccountId: ::core::clone::Clone {
            #[inline]
            fn clone(&self) -> V7BondedPoolInner<T> {
                V7BondedPoolInner {
                    commission: ::core::clone::Clone::clone(&self.commission),
                    member_counter: ::core::clone::Clone::clone(&self.member_counter),
                    points: ::core::clone::Clone::clone(&self.points),
                    roles: ::core::clone::Clone::clone(&self.roles),
                    state: ::core::clone::Clone::clone(&self.state),
                }
            }
        }
        #[allow(dead_code)]
        pub struct V7BondedPool<T: Config> {
            /// The identifier of the pool.
            id: PoolId,
            /// The inner fields.
            inner: V7BondedPoolInner<T>,
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for
            V7BondedPool<T> {
            #[inline]
            fn clone(&self) -> V7BondedPool<T> {
                V7BondedPool {
                    id: ::core::clone::Clone::clone(&self.id),
                    inner: ::core::clone::Clone::clone(&self.inner),
                }
            }
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl<T: Config> ::core::marker::StructuralPartialEq for
            V7BondedPool<T> {
        }
        #[automatically_derived]
        #[allow(dead_code)]
        impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for
            V7BondedPool<T> {
            #[inline]
            fn eq(&self, other: &V7BondedPool<T>) -> bool {
                self.id == other.id && self.inner == other.inner
            }
        }
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::core::fmt::Debug for V7BondedPool<T> {
                    fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        fmt.debug_struct("V7BondedPool").field("id",
                                    &self.id).field("inner", &self.inner).finish()
                    }
                }
            };
        impl<T: Config> V7BondedPool<T> {
            fn bonded_account(&self) -> T::AccountId {
                Pallet::<T>::create_bonded_account(self.id)
            }
        }
        #[allow(non_camel_case_types)]
        pub struct BondedPools_Storage_Instance<T: Config>(frame_support::__private::sp_std::marker::PhantomData<(T)>);
        impl<T: Config> frame_support::traits::StorageInstance for
            BondedPools_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "BondedPools";
            fn storage_prefix_hash() -> [u8; 16] {
                [31u8, 124u8, 78u8, 87u8, 220u8, 73u8, 228u8, 214u8, 208u8,
                        3u8, 183u8, 48u8, 167u8, 137u8, 79u8, 50u8]
            }
        }
        pub struct CounterForBondedPools_Storage_Instance<T: Config>(frame_support::__private::sp_std::marker::PhantomData<(T)>);
        impl<T: Config> frame_support::traits::StorageInstance for
            CounterForBondedPools_Storage_Instance<T> {
            fn pallet_prefix() -> &'static str {
                <Pallet<T> as frame_support::traits::PalletInfoAccess>::name()
            }
            const STORAGE_PREFIX: &'static str = "CounterForBondedPools";
            fn storage_prefix_hash() -> [u8; 16] {
                [96u8, 155u8, 96u8, 70u8, 200u8, 200u8, 13u8, 17u8, 196u8,
                        115u8, 43u8, 187u8, 232u8, 110u8, 242u8, 224u8]
            }
        }
        impl<T: Config>
            frame_support::storage::types::CountedStorageMapInstance for
            BondedPools_Storage_Instance<T> {
            type CounterPrefix = CounterForBondedPools_Storage_Instance<T>;
        }
        pub type BondedPools<T> =
            frame_support::storage::types::CountedStorageMap<BondedPools_Storage_Instance<T>,
            Twox64Concat, PoolId, V7BondedPoolInner<T>>;
        pub struct VersionUncheckedMigrateV6ToV7<T>(sp_std::marker::PhantomData<T>);
        impl<T: Config> VersionUncheckedMigrateV6ToV7<T> {
            fn calculate_tvl_by_total_stake() -> BalanceOf<T> {
                BondedPools::<T>::iter().map(|(id, inner)|
                                {
                                    T::Staking::total_stake(&V7BondedPool {
                                                        id,
                                                        inner: inner.clone(),
                                                    }.bonded_account()).unwrap_or_default()
                                }).reduce(|acc, total_balance|
                            acc + total_balance).unwrap_or_default()
            }
        }
        impl<T: Config> OnRuntimeUpgrade for VersionUncheckedMigrateV6ToV7<T>
            {
            fn on_runtime_upgrade() -> Weight {
                let migrated = BondedPools::<T>::count();
                let tvl: BalanceOf<T> = Self::calculate_tvl_by_total_stake();
                TotalValueLocked::<T>::set(tvl);
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Upgraded {1} pools with a TVL of {2:?}",
                                    <frame_system::Pallet<T>>::block_number(), migrated, tvl),
                                lvl,
                                &(crate::LOG_TARGET,
                                        "pallet_nomination_pools::migration::v7",
                                        "substrate/frame/nomination-pools/src/migration.rs"),
                                183u32, ::log::__private_api::Option::None);
                        }
                };
                T::DbWeight::get().reads_writes(migrated.saturating_mul(2).saturating_add(2).into(),
                    2)
            }
        }
    }
    mod v6 {
        use super::*;
        /// This migration would restrict reward account of pools to go below ED by doing a named
        /// freeze on all the existing pools.
        pub struct MigrateToV6<T>(sp_std::marker::PhantomData<T>);
        impl<T: Config> MigrateToV6<T> {
            fn freeze_ed(pool_id: PoolId) -> Result<(), ()> {
                let reward_acc = Pallet::<T>::create_reward_account(pool_id);
                Pallet::<T>::freeze_pool_deposit(&reward_acc).map_err(|e|
                        {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL &&
                                            lvl <= ::log::max_level() {
                                        ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Failed to freeze ED for pool {1} with error: {2:?}",
                                                <frame_system::Pallet<T>>::block_number(), pool_id, e), lvl,
                                            &(crate::LOG_TARGET,
                                                    "pallet_nomination_pools::migration::v6",
                                                    "substrate/frame/nomination-pools/src/migration.rs"),
                                            240u32, ::log::__private_api::Option::None);
                                    }
                            };
                            ()
                        })
            }
        }
        impl<T: Config> OnRuntimeUpgrade for MigrateToV6<T> {
            fn on_runtime_upgrade() -> Weight {
                let mut success = 0u64;
                let mut fail = 0u64;
                BondedPools::<T>::iter_keys().for_each(|p|
                        {
                            if Self::freeze_ed(p).is_ok() {
                                    success.saturating_inc();
                                } else { fail.saturating_inc(); }
                        });
                if fail > 0 {
                        {
                            let lvl = ::log::Level::Error;
                            if lvl <= ::log::STATIC_MAX_LEVEL &&
                                        lvl <= ::log::max_level() {
                                    ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Failed to freeze ED for {1} pools",
                                            <frame_system::Pallet<T>>::block_number(), fail), lvl,
                                        &(crate::LOG_TARGET,
                                                "pallet_nomination_pools::migration::v6",
                                                "substrate/frame/nomination-pools/src/migration.rs"),
                                        259u32, ::log::__private_api::Option::None);
                                }
                        };
                    } else {
                       {
                           let lvl = ::log::Level::Info;
                           if lvl <= ::log::STATIC_MAX_LEVEL &&
                                       lvl <= ::log::max_level() {
                                   ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Freezing ED succeeded for {1} pools",
                                           <frame_system::Pallet<T>>::block_number(), success), lvl,
                                       &(crate::LOG_TARGET,
                                               "pallet_nomination_pools::migration::v6",
                                               "substrate/frame/nomination-pools/src/migration.rs"),
                                       261u32, ::log::__private_api::Option::None);
                               }
                       };
                   }
                let total = success.saturating_add(fail);
                T::DbWeight::get().reads_writes(3u64.saturating_mul(total),
                    2u64.saturating_mul(total))
            }
        }
    }
    pub mod v5 {
        use super::*;
        pub struct OldRewardPool<T: Config> {
            last_recorded_reward_counter: T::RewardCounter,
            last_recorded_total_payouts: BalanceOf<T>,
            total_rewards_claimed: BalanceOf<T>,
        }
        #[allow(deprecated)]
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::codec::Decode for OldRewardPool<T> where
                    T::RewardCounter: ::codec::Decode,
                    T::RewardCounter: ::codec::Decode,
                    BalanceOf<T>: ::codec::Decode,
                    BalanceOf<T>: ::codec::Decode,
                    BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode
                    {
                    fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                            &mut __CodecInputEdqy)
                        -> ::core::result::Result<Self, ::codec::Error> {
                        ::core::result::Result::Ok(OldRewardPool::<T> {
                                last_recorded_reward_counter: {
                                    let __codec_res_edqy =
                                        <T::RewardCounter as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldRewardPool::last_recorded_reward_counter`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                last_recorded_total_payouts: {
                                    let __codec_res_edqy =
                                        <BalanceOf<T> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldRewardPool::last_recorded_total_payouts`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                total_rewards_claimed: {
                                    let __codec_res_edqy =
                                        <BalanceOf<T> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldRewardPool::total_rewards_claimed`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                            })
                    }
                }
            };
        impl<T: Config> OldRewardPool<T> {
            fn migrate_to_v5(self) -> RewardPool<T> {
                RewardPool {
                    last_recorded_reward_counter: self.last_recorded_reward_counter,
                    last_recorded_total_payouts: self.last_recorded_total_payouts,
                    total_rewards_claimed: self.total_rewards_claimed,
                    total_commission_pending: Zero::zero(),
                    total_commission_claimed: Zero::zero(),
                }
            }
        }
        /// This migration adds `total_commission_pending` and `total_commission_claimed` field to every
        /// `RewardPool`, if any.
        pub struct MigrateToV5<T>(sp_std::marker::PhantomData<T>);
        impl<T: Config> OnRuntimeUpgrade for MigrateToV5<T> {
            fn on_runtime_upgrade() -> Weight {
                let current = Pallet::<T>::current_storage_version();
                let onchain = Pallet::<T>::on_chain_storage_version();
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Running migration with current storage version {1:?} / onchain {2:?}",
                                    <frame_system::Pallet<T>>::block_number(), current,
                                    onchain), lvl,
                                &(crate::LOG_TARGET,
                                        "pallet_nomination_pools::migration::v5",
                                        "substrate/frame/nomination-pools/src/migration.rs"),
                                308u32, ::log::__private_api::Option::None);
                        }
                };
                if current == 5 && onchain == 4 {
                        let mut translated = 0u64;
                        RewardPools::<T>::translate::<OldRewardPool<T>,
                                _>(|_id, old_value|
                                {
                                    translated.saturating_inc();
                                    Some(old_value.migrate_to_v5())
                                });
                        current.put::<Pallet<T>>();
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL &&
                                        lvl <= ::log::max_level() {
                                    ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Upgraded {1} pools, storage to version {2:?}",
                                            <frame_system::Pallet<T>>::block_number(), translated,
                                            current), lvl,
                                        &(crate::LOG_TARGET,
                                                "pallet_nomination_pools::migration::v5",
                                                "substrate/frame/nomination-pools/src/migration.rs"),
                                        323u32, ::log::__private_api::Option::None);
                                }
                        };
                        T::DbWeight::get().reads_writes(translated + 1,
                            translated + 1)
                    } else {
                       {
                           let lvl = ::log::Level::Info;
                           if lvl <= ::log::STATIC_MAX_LEVEL &&
                                       lvl <= ::log::max_level() {
                                   ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Migration did not execute. This probably should be removed",
                                           <frame_system::Pallet<T>>::block_number()), lvl,
                                       &(crate::LOG_TARGET,
                                               "pallet_nomination_pools::migration::v5",
                                               "substrate/frame/nomination-pools/src/migration.rs"),
                                       329u32, ::log::__private_api::Option::None);
                               }
                       };
                       T::DbWeight::get().reads(1)
                   }
            }
        }
    }
    pub mod v4 {
        use super::*;
        pub struct OldBondedPoolInner<T: Config> {
            pub points: BalanceOf<T>,
            pub state: PoolState,
            pub member_counter: u32,
            pub roles: PoolRoles<T::AccountId>,
        }
        #[allow(deprecated)]
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::codec::Decode for OldBondedPoolInner<T>
                    where BalanceOf<T>: ::codec::Decode,
                    BalanceOf<T>: ::codec::Decode,
                    PoolRoles<T::AccountId>: ::codec::Decode,
                    PoolRoles<T::AccountId>: ::codec::Decode {
                    fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                            &mut __CodecInputEdqy)
                        -> ::core::result::Result<Self, ::codec::Error> {
                        ::core::result::Result::Ok(OldBondedPoolInner::<T> {
                                points: {
                                    let __codec_res_edqy =
                                        <BalanceOf<T> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldBondedPoolInner::points`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                state: {
                                    let __codec_res_edqy =
                                        <PoolState as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldBondedPoolInner::state`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                member_counter: {
                                    let __codec_res_edqy =
                                        <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldBondedPoolInner::member_counter`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                roles: {
                                    let __codec_res_edqy =
                                        <PoolRoles<T::AccountId> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldBondedPoolInner::roles`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                            })
                    }
                }
            };
        impl<T: Config> OldBondedPoolInner<T> {
            fn migrate_to_v4(self) -> BondedPoolInner<T> {
                BondedPoolInner {
                    commission: Commission::default(),
                    member_counter: self.member_counter,
                    points: self.points,
                    state: self.state,
                    roles: self.roles,
                }
            }
        }
        /// Migrates from `v3` directly to `v5` to avoid the broken `v4` migration.
        #[allow(deprecated)]
        pub type MigrateV3ToV5<T, U> =
            (v4::MigrateToV4<T, U>, v5::MigrateToV5<T>);
        /// # Warning
        ///
        /// To avoid mangled storage please use `MigrateV3ToV5` instead.
        /// See: github.com/paritytech/substrate/pull/13715
        ///
        /// This migration adds a `commission` field to every `BondedPoolInner`, if
        /// any.
        #[deprecated(note =
        "To avoid mangled storage please use `MigrateV3ToV5` instead. See: github.com/paritytech/substrate/pull/13715")]
        pub struct MigrateToV4<T, U>(sp_std::marker::PhantomData<(T, U)>);
        #[allow(deprecated)]
        impl<T: Config, U: Get<Perbill>> OnRuntimeUpgrade for
            MigrateToV4<T, U> {
            fn on_runtime_upgrade() -> Weight {
                let current = Pallet::<T>::current_storage_version();
                let onchain = Pallet::<T>::on_chain_storage_version();
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Running migration with current storage version {1:?} / onchain {2:?}",
                                    <frame_system::Pallet<T>>::block_number(), current,
                                    onchain), lvl,
                                &(crate::LOG_TARGET,
                                        "pallet_nomination_pools::migration::v4",
                                        "substrate/frame/nomination-pools/src/migration.rs"),
                                464u32, ::log::__private_api::Option::None);
                        }
                };
                if onchain == 3 {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL &&
                                        lvl <= ::log::max_level() {
                                    ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Please run MigrateToV5 immediately after this migration. See github.com/paritytech/substrate/pull/13715",
                                            <frame_system::Pallet<T>>::block_number()), lvl,
                                        &(crate::LOG_TARGET,
                                                "pallet_nomination_pools::migration::v4",
                                                "substrate/frame/nomination-pools/src/migration.rs"),
                                        472u32, ::log::__private_api::Option::None);
                                }
                        };
                        let initial_global_max_commission = U::get();
                        GlobalMaxCommission::<T>::set(Some(initial_global_max_commission));
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL &&
                                        lvl <= ::log::max_level() {
                                    ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Set initial global max commission to {1:?}.",
                                            <frame_system::Pallet<T>>::block_number(),
                                            initial_global_max_commission), lvl,
                                        &(crate::LOG_TARGET,
                                                "pallet_nomination_pools::migration::v4",
                                                "substrate/frame/nomination-pools/src/migration.rs"),
                                        475u32, ::log::__private_api::Option::None);
                                }
                        };
                        let mut translated = 0u64;
                        BondedPools::<T>::translate::<OldBondedPoolInner<T>,
                                _>(|_key, old_value|
                                {
                                    translated.saturating_inc();
                                    Some(old_value.migrate_to_v4())
                                });
                        StorageVersion::new(4).put::<Pallet<T>>();
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL &&
                                        lvl <= ::log::max_level() {
                                    ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Upgraded {1} pools, storage to version {2:?}",
                                            <frame_system::Pallet<T>>::block_number(), translated,
                                            current), lvl,
                                        &(crate::LOG_TARGET,
                                                "pallet_nomination_pools::migration::v4",
                                                "substrate/frame/nomination-pools/src/migration.rs"),
                                        488u32, ::log::__private_api::Option::None);
                                }
                        };
                        T::DbWeight::get().reads_writes(translated + 1,
                            translated + 2)
                    } else {
                       {
                           let lvl = ::log::Level::Info;
                           if lvl <= ::log::STATIC_MAX_LEVEL &&
                                       lvl <= ::log::max_level() {
                                   ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Migration did not execute. This probably should be removed",
                                           <frame_system::Pallet<T>>::block_number()), lvl,
                                       &(crate::LOG_TARGET,
                                               "pallet_nomination_pools::migration::v4",
                                               "substrate/frame/nomination-pools/src/migration.rs"),
                                       494u32, ::log::__private_api::Option::None);
                               }
                       };
                       T::DbWeight::get().reads(1)
                   }
            }
        }
    }
    pub mod v3 {
        use super::*;
        /// This migration removes stale bonded-pool metadata, if any.
        pub struct MigrateToV3<T>(sp_std::marker::PhantomData<T>);
        impl<T: Config> OnRuntimeUpgrade for MigrateToV3<T> {
            fn on_runtime_upgrade() -> Weight {
                let current = Pallet::<T>::current_storage_version();
                let onchain = Pallet::<T>::on_chain_storage_version();
                if onchain == 2 {
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL &&
                                        lvl <= ::log::max_level() {
                                    ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Running migration with current storage version {1:?} / onchain {2:?}",
                                            <frame_system::Pallet<T>>::block_number(), current,
                                            onchain), lvl,
                                        &(crate::LOG_TARGET,
                                                "pallet_nomination_pools::migration::v3",
                                                "substrate/frame/nomination-pools/src/migration.rs"),
                                        546u32, ::log::__private_api::Option::None);
                                }
                        };
                        let mut metadata_iterated = 0u64;
                        let mut metadata_removed = 0u64;
                        Metadata::<T>::iter_keys().filter(|id|
                                            {
                                                metadata_iterated += 1;
                                                !BondedPools::<T>::contains_key(&id)
                                            }).collect::<Vec<_>>().into_iter().for_each(|id|
                                { metadata_removed += 1; Metadata::<T>::remove(&id); });
                        StorageVersion::new(3).put::<Pallet<T>>();
                        let total_reads = metadata_iterated * 2 + 1;
                        let total_writes = metadata_removed + 1;
                        T::DbWeight::get().reads_writes(total_reads, total_writes)
                    } else {
                       {
                           let lvl = ::log::Level::Info;
                           if lvl <= ::log::STATIC_MAX_LEVEL &&
                                       lvl <= ::log::max_level() {
                                   ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è MigrateToV3 should be removed",
                                           <frame_system::Pallet<T>>::block_number()), lvl,
                                       &(crate::LOG_TARGET,
                                               "pallet_nomination_pools::migration::v3",
                                               "substrate/frame/nomination-pools/src/migration.rs"),
                                       573u32, ::log::__private_api::Option::None);
                               }
                       };
                       T::DbWeight::get().reads(1)
                   }
            }
        }
    }
    pub mod v2 {
        use super::*;
        use sp_runtime::Perbill;
        pub struct OldRewardPool<B> {
            pub balance: B,
            pub total_earnings: B,
            pub points: U256,
        }
        #[allow(deprecated)]
        const _: () =
            {
                #[automatically_derived]
                impl<B> ::codec::Decode for OldRewardPool<B> where
                    B: ::codec::Decode, B: ::codec::Decode, B: ::codec::Decode,
                    B: ::codec::Decode {
                    fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                            &mut __CodecInputEdqy)
                        -> ::core::result::Result<Self, ::codec::Error> {
                        ::core::result::Result::Ok(OldRewardPool::<B> {
                                balance: {
                                    let __codec_res_edqy =
                                        <B as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldRewardPool::balance`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                total_earnings: {
                                    let __codec_res_edqy =
                                        <B as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldRewardPool::total_earnings`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                points: {
                                    let __codec_res_edqy =
                                        <U256 as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldRewardPool::points`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                            })
                    }
                }
            };
        pub struct OldPoolMember<T: Config> {
            pub pool_id: PoolId,
            pub points: BalanceOf<T>,
            pub reward_pool_total_earnings: BalanceOf<T>,
            pub unbonding_eras: BoundedBTreeMap<EraIndex, BalanceOf<T>,
            T::MaxUnbonding>,
        }
        #[allow(deprecated)]
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::codec::Decode for OldPoolMember<T> where
                    BalanceOf<T>: ::codec::Decode,
                    BalanceOf<T>: ::codec::Decode,
                    BalanceOf<T>: ::codec::Decode,
                    BalanceOf<T>: ::codec::Decode,
                    BoundedBTreeMap<EraIndex, BalanceOf<T>,
                    T::MaxUnbonding>: ::codec::Decode,
                    BoundedBTreeMap<EraIndex, BalanceOf<T>,
                    T::MaxUnbonding>: ::codec::Decode {
                    fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                            &mut __CodecInputEdqy)
                        -> ::core::result::Result<Self, ::codec::Error> {
                        ::core::result::Result::Ok(OldPoolMember::<T> {
                                pool_id: {
                                    let __codec_res_edqy =
                                        <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldPoolMember::pool_id`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                points: {
                                    let __codec_res_edqy =
                                        <BalanceOf<T> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldPoolMember::points`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                reward_pool_total_earnings: {
                                    let __codec_res_edqy =
                                        <BalanceOf<T> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldPoolMember::reward_pool_total_earnings`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                unbonding_eras: {
                                    let __codec_res_edqy =
                                        <BoundedBTreeMap<EraIndex, BalanceOf<T>, T::MaxUnbonding> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldPoolMember::unbonding_eras`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                            })
                    }
                }
            };
        /// Migrate the pool reward scheme to the new version, as per
        /// <https://github.com/paritytech/substrate/pull/11669.>.
        pub struct MigrateToV2<T>(sp_std::marker::PhantomData<T>);
        impl<T: Config> MigrateToV2<T> {
            fn run(current: StorageVersion) -> Weight {
                let mut reward_pools_translated = 0u64;
                let mut members_translated = 0u64;
                let mut total_value_locked = BalanceOf::<T>::zero();
                let mut total_points_locked = BalanceOf::<T>::zero();
                let mut temp_members =
                    BTreeMap::<PoolId,
                            Vec<(T::AccountId, BalanceOf<T>)>>::new();
                PoolMembers::<T>::translate::<OldPoolMember<T>,
                        _>(|key, old_member|
                        {
                            let id = old_member.pool_id;
                            temp_members.entry(id).or_default().push((key,
                                    old_member.points));
                            total_points_locked += old_member.points;
                            members_translated += 1;
                            Some(PoolMember::<T> {
                                    last_recorded_reward_counter: Zero::zero(),
                                    pool_id: old_member.pool_id,
                                    points: old_member.points,
                                    unbonding_eras: old_member.unbonding_eras,
                                })
                        });
                RewardPools::<T>::translate::<OldRewardPool<BalanceOf<T>>,
                        _>(|id, _old_reward_pool|
                        {
                            let members =
                                match temp_members.get(&id) {
                                    Some(x) => x,
                                    None => {
                                        {
                                            let lvl = ::log::Level::Error;
                                            if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                        lvl <= ::log::max_level() {
                                                    ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è pool {1} has no member! deleting it..",
                                                            <frame_system::Pallet<T>>::block_number(), id), lvl,
                                                        &(crate::LOG_TARGET,
                                                                "pallet_nomination_pools::migration::v2",
                                                                "substrate/frame/nomination-pools/src/migration.rs"),
                                                        710u32, ::log::__private_api::Option::None);
                                                }
                                        };
                                        return None
                                    }
                                };
                            let bonded_pool =
                                match BondedPools::<T>::get(id) {
                                    Some(x) => x,
                                    None => {
                                        {
                                            let lvl = ::log::Level::Error;
                                            if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                        lvl <= ::log::max_level() {
                                                    ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è pool {1} has no bonded pool! deleting it..",
                                                            <frame_system::Pallet<T>>::block_number(), id), lvl,
                                                        &(crate::LOG_TARGET,
                                                                "pallet_nomination_pools::migration::v2",
                                                                "substrate/frame/nomination-pools/src/migration.rs"),
                                                        717u32, ::log::__private_api::Option::None);
                                                }
                                        };
                                        return None
                                    }
                                };
                            let accumulated_reward =
                                RewardPool::<T>::current_balance(id);
                            let reward_account = Pallet::<T>::create_reward_account(id);
                            let mut sum_paid_out = BalanceOf::<T>::zero();
                            members.into_iter().filter_map(|(who, points)|
                                        {
                                            let bonded_pool =
                                                match BondedPool::<T>::get(id) {
                                                    Some(x) => x,
                                                    None => {
                                                        {
                                                            let lvl = ::log::Level::Error;
                                                            if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                                        lvl <= ::log::max_level() {
                                                                    ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è pool {1} for member {2:?} does not exist!",
                                                                            <frame_system::Pallet<T>>::block_number(), id, who), lvl,
                                                                        &(crate::LOG_TARGET,
                                                                                "pallet_nomination_pools::migration::v2",
                                                                                "substrate/frame/nomination-pools/src/migration.rs"),
                                                                        732u32, ::log::__private_api::Option::None);
                                                                }
                                                        };
                                                        return None
                                                    }
                                                };
                                            total_value_locked +=
                                                bonded_pool.points_to_balance(*points);
                                            let portion =
                                                Perbill::from_rational(*points, bonded_pool.points);
                                            let last_claim = portion * accumulated_reward;
                                            {
                                                let lvl = ::log::Level::Debug;
                                                if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                            lvl <= ::log::max_level() {
                                                        ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è {1:?} has {2:?} ({3:?}) of pool {4} with total reward of {5:?}",
                                                                <frame_system::Pallet<T>>::block_number(), who, portion,
                                                                last_claim, id, accumulated_reward), lvl,
                                                            &(crate::LOG_TARGET,
                                                                    "pallet_nomination_pools::migration::v2",
                                                                    "substrate/frame/nomination-pools/src/migration.rs"),
                                                            741u32, ::log::__private_api::Option::None);
                                                    }
                                            };
                                            if last_claim.is_zero() {
                                                    None
                                                } else { Some((who, last_claim)) }
                                        }).for_each(|(who, last_claim)|
                                    {
                                        let outcome =
                                            T::Currency::transfer(&reward_account, &who, last_claim,
                                                Preservation::Preserve);
                                        if let Err(reason) = outcome {
                                                {
                                                    let lvl = ::log::Level::Warn;
                                                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                                lvl <= ::log::max_level() {
                                                            ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è last reward claim failed due to {1:?}",
                                                                    <frame_system::Pallet<T>>::block_number(), reason), lvl,
                                                                &(crate::LOG_TARGET,
                                                                        "pallet_nomination_pools::migration::v2",
                                                                        "substrate/frame/nomination-pools/src/migration.rs"),
                                                                766u32, ::log::__private_api::Option::None);
                                                        }
                                                };
                                            } else {
                                               sum_paid_out = sum_paid_out.saturating_add(last_claim);
                                           }
                                        Pallet::<T>::deposit_event(Event::<T>::PaidOut {
                                                member: who.clone(),
                                                pool_id: id,
                                                payout: last_claim,
                                            });
                                    });
                            let leftover =
                                accumulated_reward.saturating_sub(sum_paid_out);
                            if !leftover.is_zero() {
                                    let o =
                                        T::Currency::transfer(&reward_account,
                                            &bonded_pool.roles.depositor, leftover,
                                            Preservation::Preserve);
                                    {
                                        let lvl = ::log::Level::Warn;
                                        if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                    lvl <= ::log::max_level() {
                                                ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è paying {1:?} leftover to the depositor: {2:?}",
                                                        <frame_system::Pallet<T>>::block_number(), leftover, o),
                                                    lvl,
                                                    &(crate::LOG_TARGET,
                                                            "pallet_nomination_pools::migration::v2",
                                                            "substrate/frame/nomination-pools/src/migration.rs"),
                                                    789u32, ::log::__private_api::Option::None);
                                            }
                                    };
                                }
                            reward_pools_translated += 1;
                            Some(RewardPool {
                                    last_recorded_reward_counter: Zero::zero(),
                                    last_recorded_total_payouts: Zero::zero(),
                                    total_rewards_claimed: Zero::zero(),
                                    total_commission_claimed: Zero::zero(),
                                    total_commission_pending: Zero::zero(),
                                })
                        });
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Upgraded {1} members, {2} reward pools, TVL {3:?} TPL {4:?}, storage to version {5:?}",
                                    <frame_system::Pallet<T>>::block_number(),
                                    members_translated, reward_pools_translated,
                                    total_value_locked, total_points_locked, current), lvl,
                                &(crate::LOG_TARGET,
                                        "pallet_nomination_pools::migration::v2",
                                        "substrate/frame/nomination-pools/src/migration.rs"),
                                805u32, ::log::__private_api::Option::None);
                        }
                };
                current.put::<Pallet<T>>();
                T::DbWeight::get().reads_writes(members_translated + 1,
                    reward_pools_translated + 1)
            }
        }
        impl<T: Config> OnRuntimeUpgrade for MigrateToV2<T> {
            fn on_runtime_upgrade() -> Weight {
                let current = Pallet::<T>::current_storage_version();
                let onchain = Pallet::<T>::on_chain_storage_version();
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Running migration with current storage version {1:?} / onchain {2:?}",
                                    <frame_system::Pallet<T>>::block_number(), current,
                                    onchain), lvl,
                                &(crate::LOG_TARGET,
                                        "pallet_nomination_pools::migration::v2",
                                        "substrate/frame/nomination-pools/src/migration.rs"),
                                825u32, ::log::__private_api::Option::None);
                        }
                };
                if current == 2 && onchain == 1 {
                        Self::run(current)
                    } else {
                       {
                           let lvl = ::log::Level::Info;
                           if lvl <= ::log::STATIC_MAX_LEVEL &&
                                       lvl <= ::log::max_level() {
                                   ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è MigrateToV2 did not executed. This probably should be removed",
                                           <frame_system::Pallet<T>>::block_number()), lvl,
                                       &(crate::LOG_TARGET,
                                               "pallet_nomination_pools::migration::v2",
                                               "substrate/frame/nomination-pools/src/migration.rs"),
                                       835u32, ::log::__private_api::Option::None);
                               }
                       };
                       T::DbWeight::get().reads(1)
                   }
            }
        }
    }
    pub mod v1 {
        use super::*;
        pub struct OldPoolRoles<AccountId> {
            pub depositor: AccountId,
            pub root: AccountId,
            pub nominator: AccountId,
            pub bouncer: AccountId,
        }
        #[allow(deprecated)]
        const _: () =
            {
                #[automatically_derived]
                impl<AccountId> ::codec::Decode for OldPoolRoles<AccountId>
                    where AccountId: ::codec::Decode,
                    AccountId: ::codec::Decode, AccountId: ::codec::Decode,
                    AccountId: ::codec::Decode, AccountId: ::codec::Decode,
                    AccountId: ::codec::Decode, AccountId: ::codec::Decode,
                    AccountId: ::codec::Decode {
                    fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                            &mut __CodecInputEdqy)
                        -> ::core::result::Result<Self, ::codec::Error> {
                        ::core::result::Result::Ok(OldPoolRoles::<AccountId> {
                                depositor: {
                                    let __codec_res_edqy =
                                        <AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldPoolRoles::depositor`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                root: {
                                    let __codec_res_edqy =
                                        <AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldPoolRoles::root`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                nominator: {
                                    let __codec_res_edqy =
                                        <AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldPoolRoles::nominator`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                bouncer: {
                                    let __codec_res_edqy =
                                        <AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldPoolRoles::bouncer`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                            })
                    }
                }
            };
        impl<AccountId> OldPoolRoles<AccountId> {
            fn migrate_to_v1(self) -> PoolRoles<AccountId> {
                PoolRoles {
                    depositor: self.depositor,
                    root: Some(self.root),
                    nominator: Some(self.nominator),
                    bouncer: Some(self.bouncer),
                }
            }
        }
        pub struct OldBondedPoolInner<T: Config> {
            pub points: BalanceOf<T>,
            pub state: PoolState,
            pub member_counter: u32,
            pub roles: OldPoolRoles<T::AccountId>,
        }
        #[allow(deprecated)]
        const _: () =
            {
                #[automatically_derived]
                impl<T: Config> ::codec::Decode for OldBondedPoolInner<T>
                    where BalanceOf<T>: ::codec::Decode,
                    BalanceOf<T>: ::codec::Decode,
                    OldPoolRoles<T::AccountId>: ::codec::Decode,
                    OldPoolRoles<T::AccountId>: ::codec::Decode {
                    fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                            &mut __CodecInputEdqy)
                        -> ::core::result::Result<Self, ::codec::Error> {
                        ::core::result::Result::Ok(OldBondedPoolInner::<T> {
                                points: {
                                    let __codec_res_edqy =
                                        <BalanceOf<T> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldBondedPoolInner::points`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                state: {
                                    let __codec_res_edqy =
                                        <PoolState as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldBondedPoolInner::state`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                member_counter: {
                                    let __codec_res_edqy =
                                        <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldBondedPoolInner::member_counter`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                                roles: {
                                    let __codec_res_edqy =
                                        <OldPoolRoles<T::AccountId> as
                                                ::codec::Decode>::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) =>
                                            return ::core::result::Result::Err(e.chain("Could not decode `OldBondedPoolInner::roles`")),
                                        ::core::result::Result::Ok(__codec_res_edqy) =>
                                            __codec_res_edqy,
                                    }
                                },
                            })
                    }
                }
            };
        impl<T: Config> OldBondedPoolInner<T> {
            fn migrate_to_v1(self) -> BondedPoolInner<T> {
                BondedPoolInner {
                    points: self.points,
                    commission: Commission::default(),
                    member_counter: self.member_counter,
                    state: self.state,
                    roles: self.roles.migrate_to_v1(),
                }
            }
        }
        /// Trivial migration which makes the roles of each pool optional.
        ///
        /// Note: The depositor is not optional since they can never change.
        pub struct MigrateToV1<T>(sp_std::marker::PhantomData<T>);
        impl<T: Config> OnRuntimeUpgrade for MigrateToV1<T> {
            fn on_runtime_upgrade() -> Weight {
                let current = Pallet::<T>::current_storage_version();
                let onchain = Pallet::<T>::on_chain_storage_version();
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Running migration with current storage version {1:?} / onchain {2:?}",
                                    <frame_system::Pallet<T>>::block_number(), current,
                                    onchain), lvl,
                                &(crate::LOG_TARGET,
                                        "pallet_nomination_pools::migration::v1",
                                        "substrate/frame/nomination-pools/src/migration.rs"),
                                942u32, ::log::__private_api::Option::None);
                        }
                };
                if current == 1 && onchain == 0 {
                        let mut translated = 0u64;
                        BondedPools::<T>::translate::<OldBondedPoolInner<T>,
                                _>(|_key, old_value|
                                {
                                    translated.saturating_inc();
                                    Some(old_value.migrate_to_v1())
                                });
                        current.put::<Pallet<T>>();
                        {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL &&
                                        lvl <= ::log::max_level() {
                                    ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Upgraded {1} pools, storage to version {2:?}",
                                            <frame_system::Pallet<T>>::block_number(), translated,
                                            current), lvl,
                                        &(crate::LOG_TARGET,
                                                "pallet_nomination_pools::migration::v1",
                                                "substrate/frame/nomination-pools/src/migration.rs"),
                                        959u32, ::log::__private_api::Option::None);
                                }
                        };
                        T::DbWeight::get().reads_writes(translated + 1,
                            translated + 1)
                    } else {
                       {
                           let lvl = ::log::Level::Info;
                           if lvl <= ::log::STATIC_MAX_LEVEL &&
                                       lvl <= ::log::max_level() {
                                   ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è Migration did not executed. This probably should be removed",
                                           <frame_system::Pallet<T>>::block_number()), lvl,
                                       &(crate::LOG_TARGET,
                                               "pallet_nomination_pools::migration::v1",
                                               "substrate/frame/nomination-pools/src/migration.rs"),
                                       963u32, ::log::__private_api::Option::None);
                               }
                       };
                       T::DbWeight::get().reads(1)
                   }
            }
        }
    }
}
pub mod weights {
    //! Autogenerated weights for `pallet_nomination_pools`
    //!
    //! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev
    //! DATE: 2023-11-23, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`
    //! WORST CASE MAP SIZE: `1000000`
    //! HOSTNAME: `runner-yprdrvc7-project-674-concurrent-0`, CPU: `Intel(R) Xeon(R) CPU @ 2.60GHz`
    //! WASM-EXECUTION: `Compiled`, CHAIN: `Some("dev")`, DB CACHE: `1024`
    #![allow(unused_parens)]
    #![allow(unused_imports)]
    #![allow(missing_docs)]
    use frame_support::{
        traits::Get, weights::{Weight, constants::RocksDbWeight},
    };
    use core::marker::PhantomData;
    /// Weight functions needed for `pallet_nomination_pools`.
    pub trait WeightInfo {
        fn join()
        -> Weight;
        fn bond_extra_transfer()
        -> Weight;
        fn bond_extra_other()
        -> Weight;
        fn claim_payout()
        -> Weight;
        fn unbond()
        -> Weight;
        fn pool_withdraw_unbonded(s: u32)
        -> Weight;
        fn withdraw_unbonded_update(s: u32)
        -> Weight;
        fn withdraw_unbonded_kill(s: u32)
        -> Weight;
        fn create()
        -> Weight;
        fn nominate(n: u32)
        -> Weight;
        fn set_state()
        -> Weight;
        fn set_metadata(n: u32)
        -> Weight;
        fn set_configs()
        -> Weight;
        fn update_roles()
        -> Weight;
        fn chill()
        -> Weight;
        fn set_commission()
        -> Weight;
        fn set_commission_max()
        -> Weight;
        fn set_commission_change_rate()
        -> Weight;
        fn set_commission_claim_permission()
        -> Weight;
        fn set_claim_permission()
        -> Weight;
        fn claim_commission()
        -> Weight;
        fn adjust_pool_deposit()
        -> Weight;
    }
    /// Weights for `pallet_nomination_pools` using the Substrate node and recommended hardware.
    pub struct SubstrateWeight<T>(PhantomData<T>);
    impl<T: frame_system::Config> WeightInfo for SubstrateWeight<T> {
        /// Storage: `NominationPools::MinJoinBond` (r:1 w:0)
        /// Proof: `NominationPools::MinJoinBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:2 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembersPerPool` (r:1 w:0)
        /// Proof: `NominationPools::MaxPoolMembersPerPool` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembers` (r:1 w:0)
        /// Proof: `NominationPools::MaxPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForPoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::CounterForPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        fn join() -> Weight {
            Weight::from_parts(188_860_000,
                        8877).saturating_add(T::DbWeight::get().reads(20_u64)).saturating_add(T::DbWeight::get().writes(13_u64))
        }
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:3 w:2)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        fn bond_extra_transfer() -> Weight {
            Weight::from_parts(192_646_000,
                        8877).saturating_add(T::DbWeight::get().reads(17_u64)).saturating_add(T::DbWeight::get().writes(13_u64))
        }
        /// Storage: `NominationPools::ClaimPermissions` (r:1 w:0)
        /// Proof: `NominationPools::ClaimPermissions` (`max_values`: None, `max_size`: Some(41), added: 2516, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:3 w:3)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        fn bond_extra_other() -> Weight {
            Weight::from_parts(227_569_000,
                        8877).saturating_add(T::DbWeight::get().reads(18_u64)).saturating_add(T::DbWeight::get().writes(14_u64))
        }
        /// Storage: `NominationPools::ClaimPermissions` (r:1 w:0)
        /// Proof: `NominationPools::ClaimPermissions` (`max_values`: None, `max_size`: Some(41), added: 2516, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        fn claim_payout() -> Weight {
            Weight::from_parts(77_709_000,
                        3719).saturating_add(T::DbWeight::get().reads(6_u64)).saturating_add(T::DbWeight::get().writes(4_u64))
        }
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:2 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::SubPoolsStorage` (r:1 w:1)
        /// Proof: `NominationPools::SubPoolsStorage` (`max_values`: None, `max_size`: Some(24382), added: 26857, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForSubPoolsStorage` (r:1 w:1)
        /// Proof: `NominationPools::CounterForSubPoolsStorage` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn unbond() -> Weight {
            Weight::from_parts(174_950_000,
                        27847).saturating_add(T::DbWeight::get().reads(20_u64)).saturating_add(T::DbWeight::get().writes(13_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn pool_withdraw_unbonded(s: u32) -> Weight {
            Weight::from_parts(72_312_887,
                            4764).saturating_add(Weight::from_parts(41_679,
                                0).saturating_mul(s.into())).saturating_add(T::DbWeight::get().reads(7_u64)).saturating_add(T::DbWeight::get().writes(3_u64))
        }
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::SubPoolsStorage` (r:1 w:1)
        /// Proof: `NominationPools::SubPoolsStorage` (`max_values`: None, `max_size`: Some(24382), added: 26857, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForPoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::CounterForPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ClaimPermissions` (r:0 w:1)
        /// Proof: `NominationPools::ClaimPermissions` (`max_values`: None, `max_size`: Some(41), added: 2516, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn withdraw_unbonded_update(s: u32) -> Weight {
            Weight::from_parts(136_595_971,
                            27847).saturating_add(Weight::from_parts(52_351,
                                0).saturating_mul(s.into())).saturating_add(T::DbWeight::get().reads(11_u64)).saturating_add(T::DbWeight::get().writes(9_u64))
        }
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::SubPoolsStorage` (r:1 w:1)
        /// Proof: `NominationPools::SubPoolsStorage` (`max_values`: None, `max_size`: Some(24382), added: 26857, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SlashingSpans` (r:1 w:0)
        /// Proof: `Staking::SlashingSpans` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Balances::Locks` (r:2 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:2 w:1)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:2 w:2)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForPoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::CounterForPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ReversePoolIdLookup` (r:1 w:1)
        /// Proof: `NominationPools::ReversePoolIdLookup` (`max_values`: None, `max_size`: Some(44), added: 2519, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForReversePoolIdLookup` (r:1 w:1)
        /// Proof: `NominationPools::CounterForReversePoolIdLookup` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForRewardPools` (r:1 w:1)
        /// Proof: `NominationPools::CounterForRewardPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForSubPoolsStorage` (r:1 w:1)
        /// Proof: `NominationPools::CounterForSubPoolsStorage` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::Metadata` (r:1 w:1)
        /// Proof: `NominationPools::Metadata` (`max_values`: None, `max_size`: Some(270), added: 2745, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForBondedPools` (r:1 w:1)
        /// Proof: `NominationPools::CounterForBondedPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ClaimPermissions` (r:0 w:1)
        /// Proof: `NominationPools::ClaimPermissions` (`max_values`: None, `max_size`: Some(41), added: 2516, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn withdraw_unbonded_kill(_s: u32) -> Weight {
            Weight::from_parts(241_694_316,
                        27847).saturating_add(T::DbWeight::get().reads(24_u64)).saturating_add(T::DbWeight::get().writes(20_u64))
        }
        /// Storage: `NominationPools::LastPoolId` (r:1 w:1)
        /// Proof: `NominationPools::LastPoolId` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MinCreateBond` (r:1 w:0)
        /// Proof: `NominationPools::MinCreateBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MinJoinBond` (r:1 w:0)
        /// Proof: `NominationPools::MinJoinBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPools` (r:1 w:0)
        /// Proof: `NominationPools::MaxPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForBondedPools` (r:1 w:1)
        /// Proof: `NominationPools::CounterForBondedPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembersPerPool` (r:1 w:0)
        /// Proof: `NominationPools::MaxPoolMembersPerPool` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembers` (r:1 w:0)
        /// Proof: `NominationPools::MaxPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForPoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::CounterForPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:2 w:2)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:2 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:2 w:1)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForRewardPools` (r:1 w:1)
        /// Proof: `NominationPools::CounterForRewardPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ReversePoolIdLookup` (r:1 w:1)
        /// Proof: `NominationPools::ReversePoolIdLookup` (`max_values`: None, `max_size`: Some(44), added: 2519, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForReversePoolIdLookup` (r:1 w:1)
        /// Proof: `NominationPools::CounterForReversePoolIdLookup` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:0 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        fn create() -> Weight {
            Weight::from_parts(176_478_000,
                        8538).saturating_add(T::DbWeight::get().reads(23_u64)).saturating_add(T::DbWeight::get().writes(17_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxNominatorsCount` (r:1 w:0)
        /// Proof: `Staking::MaxNominatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:17 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:1 w:1)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// The range of component `n` is `[1, 16]`.
        fn nominate(n: u32) -> Weight {
            Weight::from_parts(64_930_584,
                                    4556).saturating_add(Weight::from_parts(1_595_779,
                                        0).saturating_mul(n.into())).saturating_add(T::DbWeight::get().reads(12_u64)).saturating_add(T::DbWeight::get().reads((1_u64).saturating_mul(n.into()))).saturating_add(T::DbWeight::get().writes(5_u64)).saturating_add(Weight::from_parts(0,
                        2520).saturating_mul(n.into()))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        fn set_state() -> Weight {
            Weight::from_parts(33_955_000,
                        4556).saturating_add(T::DbWeight::get().reads(3_u64)).saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::Metadata` (r:1 w:1)
        /// Proof: `NominationPools::Metadata` (`max_values`: None, `max_size`: Some(270), added: 2745, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForMetadata` (r:1 w:1)
        /// Proof: `NominationPools::CounterForMetadata` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// The range of component `n` is `[1, 256]`.
        fn set_metadata(n: u32) -> Weight {
            Weight::from_parts(14_770_006,
                            3735).saturating_add(Weight::from_parts(1_900,
                                0).saturating_mul(n.into())).saturating_add(T::DbWeight::get().reads(3_u64)).saturating_add(T::DbWeight::get().writes(2_u64))
        }
        /// Storage: `NominationPools::MinJoinBond` (r:0 w:1)
        /// Proof: `NominationPools::MinJoinBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembers` (r:0 w:1)
        /// Proof: `NominationPools::MaxPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembersPerPool` (r:0 w:1)
        /// Proof: `NominationPools::MaxPoolMembersPerPool` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MinCreateBond` (r:0 w:1)
        /// Proof: `NominationPools::MinCreateBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:0 w:1)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPools` (r:0 w:1)
        /// Proof: `NominationPools::MaxPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn set_configs() -> Weight {
            Weight::from_parts(4_935_000,
                    0).saturating_add(T::DbWeight::get().writes(6_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        fn update_roles() -> Weight {
            Weight::from_parts(17_346_000,
                        3719).saturating_add(T::DbWeight::get().reads(1_u64)).saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:1 w:1)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn chill() -> Weight {
            Weight::from_parts(63_738_000,
                        4556).saturating_add(T::DbWeight::get().reads(9_u64)).saturating_add(T::DbWeight::get().writes(5_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:0)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        fn set_commission() -> Weight {
            Weight::from_parts(33_190_000,
                        3719).saturating_add(T::DbWeight::get().reads(4_u64)).saturating_add(T::DbWeight::get().writes(2_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn set_commission_max() -> Weight {
            Weight::from_parts(17_733_000,
                        3719).saturating_add(T::DbWeight::get().reads(2_u64)).saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        fn set_commission_change_rate() -> Weight {
            Weight::from_parts(17_563_000,
                        3719).saturating_add(T::DbWeight::get().reads(1_u64)).saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        fn set_commission_claim_permission() -> Weight {
            Weight::from_parts(17_022_000,
                        3719).saturating_add(T::DbWeight::get().reads(1_u64)).saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::PoolMembers` (r:1 w:0)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ClaimPermissions` (r:1 w:1)
        /// Proof: `NominationPools::ClaimPermissions` (`max_values`: None, `max_size`: Some(41), added: 2516, mode: `MaxEncodedLen`)
        fn set_claim_permission() -> Weight {
            Weight::from_parts(15_095_000,
                        3702).saturating_add(T::DbWeight::get().reads(2_u64)).saturating_add(T::DbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        fn claim_commission() -> Weight {
            Weight::from_parts(63_965_000,
                        3719).saturating_add(T::DbWeight::get().reads(4_u64)).saturating_add(T::DbWeight::get().writes(2_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:1)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:0)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        fn adjust_pool_deposit() -> Weight {
            Weight::from_parts(67_250_000,
                        4764).saturating_add(T::DbWeight::get().reads(4_u64)).saturating_add(T::DbWeight::get().writes(2_u64))
        }
    }
    impl WeightInfo for () {
        /// Storage: `NominationPools::MinJoinBond` (r:1 w:0)
        /// Proof: `NominationPools::MinJoinBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:2 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembersPerPool` (r:1 w:0)
        /// Proof: `NominationPools::MaxPoolMembersPerPool` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembers` (r:1 w:0)
        /// Proof: `NominationPools::MaxPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForPoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::CounterForPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        fn join() -> Weight {
            Weight::from_parts(188_860_000,
                        8877).saturating_add(RocksDbWeight::get().reads(20_u64)).saturating_add(RocksDbWeight::get().writes(13_u64))
        }
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:3 w:2)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        fn bond_extra_transfer() -> Weight {
            Weight::from_parts(192_646_000,
                        8877).saturating_add(RocksDbWeight::get().reads(17_u64)).saturating_add(RocksDbWeight::get().writes(13_u64))
        }
        /// Storage: `NominationPools::ClaimPermissions` (r:1 w:0)
        /// Proof: `NominationPools::ClaimPermissions` (`max_values`: None, `max_size`: Some(41), added: 2516, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:3 w:3)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        fn bond_extra_other() -> Weight {
            Weight::from_parts(227_569_000,
                        8877).saturating_add(RocksDbWeight::get().reads(18_u64)).saturating_add(RocksDbWeight::get().writes(14_u64))
        }
        /// Storage: `NominationPools::ClaimPermissions` (r:1 w:0)
        /// Proof: `NominationPools::ClaimPermissions` (`max_values`: None, `max_size`: Some(41), added: 2516, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        fn claim_payout() -> Weight {
            Weight::from_parts(77_709_000,
                        3719).saturating_add(RocksDbWeight::get().reads(6_u64)).saturating_add(RocksDbWeight::get().writes(4_u64))
        }
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:2 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:3 w:3)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:2 w:2)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::SubPoolsStorage` (r:1 w:1)
        /// Proof: `NominationPools::SubPoolsStorage` (`max_values`: None, `max_size`: Some(24382), added: 26857, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForSubPoolsStorage` (r:1 w:1)
        /// Proof: `NominationPools::CounterForSubPoolsStorage` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn unbond() -> Weight {
            Weight::from_parts(174_950_000,
                        27847).saturating_add(RocksDbWeight::get().reads(20_u64)).saturating_add(RocksDbWeight::get().writes(13_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn pool_withdraw_unbonded(s: u32) -> Weight {
            Weight::from_parts(72_312_887,
                            4764).saturating_add(Weight::from_parts(41_679,
                                0).saturating_mul(s.into())).saturating_add(RocksDbWeight::get().reads(7_u64)).saturating_add(RocksDbWeight::get().writes(3_u64))
        }
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::SubPoolsStorage` (r:1 w:1)
        /// Proof: `NominationPools::SubPoolsStorage` (`max_values`: None, `max_size`: Some(24382), added: 26857, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:0)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForPoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::CounterForPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ClaimPermissions` (r:0 w:1)
        /// Proof: `NominationPools::ClaimPermissions` (`max_values`: None, `max_size`: Some(41), added: 2516, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn withdraw_unbonded_update(s: u32) -> Weight {
            Weight::from_parts(136_595_971,
                            27847).saturating_add(Weight::from_parts(52_351,
                                0).saturating_mul(s.into())).saturating_add(RocksDbWeight::get().reads(11_u64)).saturating_add(RocksDbWeight::get().writes(9_u64))
        }
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::SubPoolsStorage` (r:1 w:1)
        /// Proof: `NominationPools::SubPoolsStorage` (`max_values`: None, `max_size`: Some(24382), added: 26857, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::SlashingSpans` (r:1 w:0)
        /// Proof: `Staking::SlashingSpans` (`max_values`: None, `max_size`: None, mode: `Measured`)
        /// Storage: `Balances::Locks` (r:2 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:2 w:1)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:2 w:2)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:0)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForPoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::CounterForPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ReversePoolIdLookup` (r:1 w:1)
        /// Proof: `NominationPools::ReversePoolIdLookup` (`max_values`: None, `max_size`: Some(44), added: 2519, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForReversePoolIdLookup` (r:1 w:1)
        /// Proof: `NominationPools::CounterForReversePoolIdLookup` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForRewardPools` (r:1 w:1)
        /// Proof: `NominationPools::CounterForRewardPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForSubPoolsStorage` (r:1 w:1)
        /// Proof: `NominationPools::CounterForSubPoolsStorage` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::Metadata` (r:1 w:1)
        /// Proof: `NominationPools::Metadata` (`max_values`: None, `max_size`: Some(270), added: 2745, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForBondedPools` (r:1 w:1)
        /// Proof: `NominationPools::CounterForBondedPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ClaimPermissions` (r:0 w:1)
        /// Proof: `NominationPools::ClaimPermissions` (`max_values`: None, `max_size`: Some(41), added: 2516, mode: `MaxEncodedLen`)
        /// The range of component `s` is `[0, 100]`.
        fn withdraw_unbonded_kill(_s: u32) -> Weight {
            Weight::from_parts(241_694_316,
                        27847).saturating_add(RocksDbWeight::get().reads(24_u64)).saturating_add(RocksDbWeight::get().writes(20_u64))
        }
        /// Storage: `NominationPools::LastPoolId` (r:1 w:1)
        /// Proof: `NominationPools::LastPoolId` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MinCreateBond` (r:1 w:0)
        /// Proof: `NominationPools::MinCreateBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MinJoinBond` (r:1 w:0)
        /// Proof: `NominationPools::MinJoinBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPools` (r:1 w:0)
        /// Proof: `NominationPools::MaxPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForBondedPools` (r:1 w:1)
        /// Proof: `NominationPools::CounterForBondedPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::PoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembersPerPool` (r:1 w:0)
        /// Proof: `NominationPools::MaxPoolMembersPerPool` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembers` (r:1 w:0)
        /// Proof: `NominationPools::MaxPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForPoolMembers` (r:1 w:1)
        /// Proof: `NominationPools::CounterForPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:2 w:2)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:1)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:2 w:1)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:2 w:1)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::TotalValueLocked` (r:1 w:1)
        /// Proof: `NominationPools::TotalValueLocked` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForRewardPools` (r:1 w:1)
        /// Proof: `NominationPools::CounterForRewardPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ReversePoolIdLookup` (r:1 w:1)
        /// Proof: `NominationPools::ReversePoolIdLookup` (`max_values`: None, `max_size`: Some(44), added: 2519, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForReversePoolIdLookup` (r:1 w:1)
        /// Proof: `NominationPools::CounterForReversePoolIdLookup` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:0 w:1)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Payee` (r:0 w:1)
        /// Proof: `Staking::Payee` (`max_values`: None, `max_size`: Some(73), added: 2548, mode: `MaxEncodedLen`)
        fn create() -> Weight {
            Weight::from_parts(176_478_000,
                        8538).saturating_add(RocksDbWeight::get().reads(23_u64)).saturating_add(RocksDbWeight::get().writes(17_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MinNominatorBond` (r:1 w:0)
        /// Proof: `Staking::MinNominatorBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::MaxNominatorsCount` (r:1 w:0)
        /// Proof: `Staking::MaxNominatorsCount` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:17 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CurrentEra` (r:1 w:0)
        /// Proof: `Staking::CurrentEra` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:1 w:1)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// The range of component `n` is `[1, 16]`.
        fn nominate(n: u32) -> Weight {
            Weight::from_parts(64_930_584,
                                    4556).saturating_add(Weight::from_parts(1_595_779,
                                        0).saturating_mul(n.into())).saturating_add(RocksDbWeight::get().reads(12_u64)).saturating_add(RocksDbWeight::get().reads((1_u64).saturating_mul(n.into()))).saturating_add(RocksDbWeight::get().writes(5_u64)).saturating_add(Weight::from_parts(0,
                        2520).saturating_mul(n.into()))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        fn set_state() -> Weight {
            Weight::from_parts(33_955_000,
                        4556).saturating_add(RocksDbWeight::get().reads(3_u64)).saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::Metadata` (r:1 w:1)
        /// Proof: `NominationPools::Metadata` (`max_values`: None, `max_size`: Some(270), added: 2745, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::CounterForMetadata` (r:1 w:1)
        /// Proof: `NominationPools::CounterForMetadata` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// The range of component `n` is `[1, 256]`.
        fn set_metadata(n: u32) -> Weight {
            Weight::from_parts(14_770_006,
                            3735).saturating_add(Weight::from_parts(1_900,
                                0).saturating_mul(n.into())).saturating_add(RocksDbWeight::get().reads(3_u64)).saturating_add(RocksDbWeight::get().writes(2_u64))
        }
        /// Storage: `NominationPools::MinJoinBond` (r:0 w:1)
        /// Proof: `NominationPools::MinJoinBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembers` (r:0 w:1)
        /// Proof: `NominationPools::MaxPoolMembers` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPoolMembersPerPool` (r:0 w:1)
        /// Proof: `NominationPools::MaxPoolMembersPerPool` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MinCreateBond` (r:0 w:1)
        /// Proof: `NominationPools::MinCreateBond` (`max_values`: Some(1), `max_size`: Some(16), added: 511, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:0 w:1)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::MaxPools` (r:0 w:1)
        /// Proof: `NominationPools::MaxPools` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn set_configs() -> Weight {
            Weight::from_parts(4_935_000,
                    0).saturating_add(RocksDbWeight::get().writes(6_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        fn update_roles() -> Weight {
            Weight::from_parts(17_346_000,
                        3719).saturating_add(RocksDbWeight::get().reads(1_u64)).saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Bonded` (r:1 w:0)
        /// Proof: `Staking::Bonded` (`max_values`: None, `max_size`: Some(72), added: 2547, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Ledger` (r:1 w:0)
        /// Proof: `Staking::Ledger` (`max_values`: None, `max_size`: Some(1091), added: 3566, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Validators` (r:1 w:0)
        /// Proof: `Staking::Validators` (`max_values`: None, `max_size`: Some(45), added: 2520, mode: `MaxEncodedLen`)
        /// Storage: `Staking::Nominators` (r:1 w:1)
        /// Proof: `Staking::Nominators` (`max_values`: None, `max_size`: Some(558), added: 3033, mode: `MaxEncodedLen`)
        /// Storage: `Staking::CounterForNominators` (r:1 w:1)
        /// Proof: `Staking::CounterForNominators` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListNodes` (r:1 w:1)
        /// Proof: `VoterList::ListNodes` (`max_values`: None, `max_size`: Some(154), added: 2629, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::ListBags` (r:1 w:1)
        /// Proof: `VoterList::ListBags` (`max_values`: None, `max_size`: Some(82), added: 2557, mode: `MaxEncodedLen`)
        /// Storage: `VoterList::CounterForListNodes` (r:1 w:1)
        /// Proof: `VoterList::CounterForListNodes` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn chill() -> Weight {
            Weight::from_parts(63_738_000,
                        4556).saturating_add(RocksDbWeight::get().reads(9_u64)).saturating_add(RocksDbWeight::get().writes(5_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:0)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        fn set_commission() -> Weight {
            Weight::from_parts(33_190_000,
                        3719).saturating_add(RocksDbWeight::get().reads(4_u64)).saturating_add(RocksDbWeight::get().writes(2_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        fn set_commission_max() -> Weight {
            Weight::from_parts(17_733_000,
                        3719).saturating_add(RocksDbWeight::get().reads(2_u64)).saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        fn set_commission_change_rate() -> Weight {
            Weight::from_parts(17_563_000,
                        3719).saturating_add(RocksDbWeight::get().reads(1_u64)).saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:1)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        fn set_commission_claim_permission() -> Weight {
            Weight::from_parts(17_022_000,
                        3719).saturating_add(RocksDbWeight::get().reads(1_u64)).saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::PoolMembers` (r:1 w:0)
        /// Proof: `NominationPools::PoolMembers` (`max_values`: None, `max_size`: Some(237), added: 2712, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::ClaimPermissions` (r:1 w:1)
        /// Proof: `NominationPools::ClaimPermissions` (`max_values`: None, `max_size`: Some(41), added: 2516, mode: `MaxEncodedLen`)
        fn set_claim_permission() -> Weight {
            Weight::from_parts(15_095_000,
                        3702).saturating_add(RocksDbWeight::get().reads(2_u64)).saturating_add(RocksDbWeight::get().writes(1_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::RewardPools` (r:1 w:1)
        /// Proof: `NominationPools::RewardPools` (`max_values`: None, `max_size`: Some(92), added: 2567, mode: `MaxEncodedLen`)
        /// Storage: `NominationPools::GlobalMaxCommission` (r:1 w:0)
        /// Proof: `NominationPools::GlobalMaxCommission` (`max_values`: Some(1), `max_size`: Some(4), added: 499, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        fn claim_commission() -> Weight {
            Weight::from_parts(63_965_000,
                        3719).saturating_add(RocksDbWeight::get().reads(4_u64)).saturating_add(RocksDbWeight::get().writes(2_u64))
        }
        /// Storage: `NominationPools::BondedPools` (r:1 w:0)
        /// Proof: `NominationPools::BondedPools` (`max_values`: None, `max_size`: Some(254), added: 2729, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Freezes` (r:1 w:1)
        /// Proof: `Balances::Freezes` (`max_values`: None, `max_size`: Some(67), added: 2542, mode: `MaxEncodedLen`)
        /// Storage: `System::Account` (r:1 w:1)
        /// Proof: `System::Account` (`max_values`: None, `max_size`: Some(128), added: 2603, mode: `MaxEncodedLen`)
        /// Storage: `Balances::Locks` (r:1 w:0)
        /// Proof: `Balances::Locks` (`max_values`: None, `max_size`: Some(1299), added: 3774, mode: `MaxEncodedLen`)
        fn adjust_pool_deposit() -> Weight {
            Weight::from_parts(67_250_000,
                        4764).saturating_add(RocksDbWeight::get().reads(4_u64)).saturating_add(RocksDbWeight::get().writes(2_u64))
        }
    }
}
pub use pallet::*;
pub use weights::WeightInfo;
/// The balance type used by the currency system.
pub type BalanceOf<T> =
    <<T as Config>::Currency as
    FunInspect<<T as frame_system::Config>::AccountId>>::Balance;
/// Type used for unique identifier of each pool.
pub type PoolId = u32;
type AccountIdLookupOf<T> =
    <<T as frame_system::Config>::Lookup as StaticLookup>::Source;
pub const POINTS_TO_BALANCE_INIT_RATIO: u32 = 1;
/// Possible operations on the configuration values of this pallet.
pub enum ConfigOp<T: Codec + Debug> {

    /// Don't change.
    Noop,

    /// Set the given value.
    Set(T),

    /// Remove from storage.
    Remove,
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Codec + Debug> ::codec::Encode for ConfigOp<T> where
            T: ::codec::Encode, T: ::codec::Encode {
            fn size_hint(&self) -> usize {
                1_usize +
                    match *self {
                        ConfigOp::Noop => { 0_usize }
                        ConfigOp::Set(ref aa) => {
                            0_usize.saturating_add(::codec::Encode::size_hint(aa))
                        }
                        ConfigOp::Remove => { 0_usize }
                        _ => 0_usize,
                    }
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                match *self {
                    ConfigOp::Noop => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(0usize as
                                ::core::primitive::u8);
                    }
                    ConfigOp::Set(ref aa) => {
                        __codec_dest_edqy.push_byte(1usize as
                                ::core::primitive::u8);
                        ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                    }
                    ConfigOp::Remove => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(2usize as
                                ::core::primitive::u8);
                    }
                    _ => (),
                }
            }
        }
        #[automatically_derived]
        impl<T: Codec + Debug> ::codec::EncodeLike for ConfigOp<T> where
            T: ::codec::Encode, T: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Codec + Debug> ::codec::Decode for ConfigOp<T> where
            T: ::codec::Decode, T: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy.read_byte().map_err(|e|
                                e.chain("Could not decode `ConfigOp`, failed to read variant byte"))?
                    {
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 0usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        { ::core::result::Result::Ok(ConfigOp::<T>::Noop) })();
                    }
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 1usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Ok(ConfigOp::<T>::Set({
                                                        let __codec_res_edqy =
                                                            <T as ::codec::Decode>::decode(__codec_input_edqy);
                                                        match __codec_res_edqy {
                                                            ::core::result::Result::Err(e) =>
                                                                return ::core::result::Result::Err(e.chain("Could not decode `ConfigOp::Set.0`")),
                                                            ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                __codec_res_edqy,
                                                        }
                                                    }))
                                        })();
                    }
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 2usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        { ::core::result::Result::Ok(ConfigOp::<T>::Remove) })();
                    }
                    _ => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Err(<_ as
                                                        ::core::convert::Into<_>>::into("Could not decode `ConfigOp`, variant doesn't exist"))
                                        })();
                    }
                }
            }
        }
    };
const _: () =
    {
        impl<T: Codec + Debug> ::codec::MaxEncodedLen for ConfigOp<T> where
            T: ::codec::MaxEncodedLen, T: ::codec::MaxEncodedLen {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.max(0_usize).max(0_usize.saturating_add(<T>::max_encoded_len())).max(0_usize).saturating_add(1)
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<T: Codec + Debug> ::scale_info::TypeInfo for ConfigOp<T> where
            T: ::scale_info::TypeInfo + 'static, T: Codec + Debug +
            ::scale_info::TypeInfo + 'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("ConfigOp",
                                    "pallet_nomination_pools",
                                    &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                ::core::option::Option::Some(::scale_info::meta_type::<T>()))]))).docs(&["Possible operations on the configuration values of this pallet."]).variant(::scale_info::build::Variants::new().variant("Noop",
                                |v|
                                    v.index(0usize as
                                                ::core::primitive::u8).docs(&["Don't change."])).variant("Set",
                            |v|
                                v.index(1usize as
                                                ::core::primitive::u8).fields(::scale_info::build::Fields::unnamed().field(|f|
                                                f.ty::<T>().type_name("T"))).docs(&["Set the given value."])).variant("Remove",
                        |v|
                            v.index(2usize as
                                        ::core::primitive::u8).docs(&["Remove from storage."])))
            }
        }
        ;
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Codec + Debug> ::core::fmt::Debug for ConfigOp<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                match *self {
                    Self::Noop => fmt.write_str("ConfigOp::Noop"),
                    Self::Set(ref _0) => {
                        fmt.debug_tuple("ConfigOp::Set").field(&_0).finish()
                    }
                    Self::Remove => fmt.write_str("ConfigOp::Remove"),
                }
            }
        }
    };
#[automatically_derived]
impl<T: Codec + Debug> ::core::marker::StructuralPartialEq for ConfigOp<T> { }
#[automatically_derived]
impl<T: ::core::cmp::PartialEq + Codec + Debug> ::core::cmp::PartialEq for
    ConfigOp<T> {
    #[inline]
    fn eq(&self, other: &ConfigOp<T>) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag &&
            match (self, other) {
                (ConfigOp::Set(__self_0), ConfigOp::Set(__arg1_0)) =>
                    *__self_0 == *__arg1_0,
                _ => true,
            }
    }
}
#[automatically_derived]
impl<T: ::core::clone::Clone + Codec + Debug> ::core::clone::Clone for
    ConfigOp<T> {
    #[inline]
    fn clone(&self) -> ConfigOp<T> {
        match self {
            ConfigOp::Noop => ConfigOp::Noop,
            ConfigOp::Set(__self_0) =>
                ConfigOp::Set(::core::clone::Clone::clone(__self_0)),
            ConfigOp::Remove => ConfigOp::Remove,
        }
    }
}
/// The type of bonding that can happen to a pool.
enum BondType {

    /// Someone is bonding into the pool upon creation.
    Create,

    /// Someone is adding more funds later to this pool.
    Later,
}
/// How to increase the bond of a member.
pub enum BondExtra<Balance> {

    /// Take from the free balance.
    FreeBalance(Balance),

    /// Take the entire amount from the accumulated rewards.
    Rewards,
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<Balance> ::codec::Encode for BondExtra<Balance> where
            Balance: ::codec::Encode, Balance: ::codec::Encode {
            fn size_hint(&self) -> usize {
                1_usize +
                    match *self {
                        BondExtra::FreeBalance(ref aa) => {
                            0_usize.saturating_add(::codec::Encode::size_hint(aa))
                        }
                        BondExtra::Rewards => { 0_usize }
                        _ => 0_usize,
                    }
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                match *self {
                    BondExtra::FreeBalance(ref aa) => {
                        __codec_dest_edqy.push_byte(0usize as
                                ::core::primitive::u8);
                        ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                    }
                    BondExtra::Rewards => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(1usize as
                                ::core::primitive::u8);
                    }
                    _ => (),
                }
            }
        }
        #[automatically_derived]
        impl<Balance> ::codec::EncodeLike for BondExtra<Balance> where
            Balance: ::codec::Encode, Balance: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<Balance> ::codec::Decode for BondExtra<Balance> where
            Balance: ::codec::Decode, Balance: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy.read_byte().map_err(|e|
                                e.chain("Could not decode `BondExtra`, failed to read variant byte"))?
                    {
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 0usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Ok(BondExtra::<Balance>::FreeBalance({
                                                        let __codec_res_edqy =
                                                            <Balance as ::codec::Decode>::decode(__codec_input_edqy);
                                                        match __codec_res_edqy {
                                                            ::core::result::Result::Err(e) =>
                                                                return ::core::result::Result::Err(e.chain("Could not decode `BondExtra::FreeBalance.0`")),
                                                            ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                __codec_res_edqy,
                                                        }
                                                    }))
                                        })();
                    }
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 1usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Ok(BondExtra::<Balance>::Rewards)
                                        })();
                    }
                    _ => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Err(<_ as
                                                        ::core::convert::Into<_>>::into("Could not decode `BondExtra`, variant doesn't exist"))
                                        })();
                    }
                }
            }
        }
    };
#[automatically_derived]
impl<Balance: ::core::clone::Clone> ::core::clone::Clone for
    BondExtra<Balance> {
    #[inline]
    fn clone(&self) -> BondExtra<Balance> {
        match self {
            BondExtra::FreeBalance(__self_0) =>
                BondExtra::FreeBalance(::core::clone::Clone::clone(__self_0)),
            BondExtra::Rewards => BondExtra::Rewards,
        }
    }
}
#[automatically_derived]
impl<Balance: ::core::marker::Copy> ::core::marker::Copy for
    BondExtra<Balance> {
}
#[automatically_derived]
impl<Balance: ::core::fmt::Debug> ::core::fmt::Debug for BondExtra<Balance> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BondExtra::FreeBalance(__self_0) =>
                ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                    "FreeBalance", &__self_0),
            BondExtra::Rewards =>
                ::core::fmt::Formatter::write_str(f, "Rewards"),
        }
    }
}
#[automatically_derived]
impl<Balance> ::core::marker::StructuralPartialEq for BondExtra<Balance> { }
#[automatically_derived]
impl<Balance: ::core::cmp::PartialEq> ::core::cmp::PartialEq for
    BondExtra<Balance> {
    #[inline]
    fn eq(&self, other: &BondExtra<Balance>) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag &&
            match (self, other) {
                (BondExtra::FreeBalance(__self_0),
                    BondExtra::FreeBalance(__arg1_0)) => *__self_0 == *__arg1_0,
                _ => true,
            }
    }
}
#[automatically_derived]
impl<Balance> ::core::marker::StructuralEq for BondExtra<Balance> { }
#[automatically_derived]
impl<Balance: ::core::cmp::Eq> ::core::cmp::Eq for BondExtra<Balance> {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Balance>;
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<Balance> ::scale_info::TypeInfo for BondExtra<Balance> where
            Balance: ::scale_info::TypeInfo + 'static,
            Balance: ::scale_info::TypeInfo + 'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("BondExtra",
                                    "pallet_nomination_pools",
                                    &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("Balance",
                                                ::core::option::Option::Some(::scale_info::meta_type::<Balance>()))]))).docs(&["How to increase the bond of a member."]).variant(::scale_info::build::Variants::new().variant("FreeBalance",
                            |v|
                                v.index(0usize as
                                                ::core::primitive::u8).fields(::scale_info::build::Fields::unnamed().field(|f|
                                                f.ty::<Balance>().type_name("Balance"))).docs(&["Take from the free balance."])).variant("Rewards",
                        |v|
                            v.index(1usize as
                                        ::core::primitive::u8).docs(&["Take the entire amount from the accumulated rewards."])))
            }
        }
        ;
    };
/// The type of account being created.
enum AccountType { Bonded, Reward, }
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl ::codec::Encode for AccountType {
            fn size_hint(&self) -> usize {
                1_usize +
                    match *self {
                        AccountType::Bonded => { 0_usize }
                        AccountType::Reward => { 0_usize }
                        _ => 0_usize,
                    }
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                match *self {
                    AccountType::Bonded => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(0usize as
                                ::core::primitive::u8);
                    }
                    AccountType::Reward => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(1usize as
                                ::core::primitive::u8);
                    }
                    _ => (),
                }
            }
        }
        #[automatically_derived]
        impl ::codec::EncodeLike for AccountType { }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl ::codec::Decode for AccountType {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy.read_byte().map_err(|e|
                                e.chain("Could not decode `AccountType`, failed to read variant byte"))?
                    {
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 0usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        { ::core::result::Result::Ok(AccountType::Bonded) })();
                    }
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 1usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        { ::core::result::Result::Ok(AccountType::Reward) })();
                    }
                    _ => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Err(<_ as
                                                        ::core::convert::Into<_>>::into("Could not decode `AccountType`, variant doesn't exist"))
                                        })();
                    }
                }
            }
        }
    };
/// The permission a pool member can set for other accounts to claim rewards on their behalf.
pub enum ClaimPermission {

    /// Only the pool member themself can claim their rewards.
    Permissioned,

    /// Anyone can compound rewards on a pool member's behalf.
    PermissionlessCompound,

    /// Anyone can withdraw rewards on a pool member's behalf.
    PermissionlessWithdraw,

    /// Anyone can withdraw and compound rewards on a pool member's behalf.
    PermissionlessAll,
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl ::codec::Encode for ClaimPermission {
            fn size_hint(&self) -> usize {
                1_usize +
                    match *self {
                        ClaimPermission::Permissioned => { 0_usize }
                        ClaimPermission::PermissionlessCompound => { 0_usize }
                        ClaimPermission::PermissionlessWithdraw => { 0_usize }
                        ClaimPermission::PermissionlessAll => { 0_usize }
                        _ => 0_usize,
                    }
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                match *self {
                    ClaimPermission::Permissioned => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(0usize as
                                ::core::primitive::u8);
                    }
                    ClaimPermission::PermissionlessCompound => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(1usize as
                                ::core::primitive::u8);
                    }
                    ClaimPermission::PermissionlessWithdraw => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(2usize as
                                ::core::primitive::u8);
                    }
                    ClaimPermission::PermissionlessAll => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(3usize as
                                ::core::primitive::u8);
                    }
                    _ => (),
                }
            }
        }
        #[automatically_derived]
        impl ::codec::EncodeLike for ClaimPermission { }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl ::codec::Decode for ClaimPermission {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy.read_byte().map_err(|e|
                                e.chain("Could not decode `ClaimPermission`, failed to read variant byte"))?
                    {
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 0usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Ok(ClaimPermission::Permissioned)
                                        })();
                    }
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 1usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Ok(ClaimPermission::PermissionlessCompound)
                                        })();
                    }
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 2usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Ok(ClaimPermission::PermissionlessWithdraw)
                                        })();
                    }
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 3usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Ok(ClaimPermission::PermissionlessAll)
                                        })();
                    }
                    _ => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Err(<_ as
                                                        ::core::convert::Into<_>>::into("Could not decode `ClaimPermission`, variant doesn't exist"))
                                        })();
                    }
                }
            }
        }
    };
const _: () =
    {
        impl ::codec::MaxEncodedLen for ClaimPermission {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.max(0_usize).max(0_usize).max(0_usize).max(0_usize).saturating_add(1)
            }
        }
    };
#[automatically_derived]
impl ::core::clone::Clone for ClaimPermission {
    #[inline]
    fn clone(&self) -> ClaimPermission { *self }
}
#[automatically_derived]
impl ::core::marker::Copy for ClaimPermission { }
#[automatically_derived]
impl ::core::fmt::Debug for ClaimPermission {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(f,
            match self {
                ClaimPermission::Permissioned => "Permissioned",
                ClaimPermission::PermissionlessCompound =>
                    "PermissionlessCompound",
                ClaimPermission::PermissionlessWithdraw =>
                    "PermissionlessWithdraw",
                ClaimPermission::PermissionlessAll => "PermissionlessAll",
            })
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ClaimPermission { }
#[automatically_derived]
impl ::core::cmp::PartialEq for ClaimPermission {
    #[inline]
    fn eq(&self, other: &ClaimPermission) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for ClaimPermission { }
#[automatically_derived]
impl ::core::cmp::Eq for ClaimPermission {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl ::scale_info::TypeInfo for ClaimPermission {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("ClaimPermission",
                                    "pallet_nomination_pools",
                                    &[])).type_params(::alloc::vec::Vec::new()).docs(&["The permission a pool member can set for other accounts to claim rewards on their behalf."]).variant(::scale_info::build::Variants::new().variant("Permissioned",
                                    |v|
                                        v.index(0usize as
                                                    ::core::primitive::u8).docs(&["Only the pool member themself can claim their rewards."])).variant("PermissionlessCompound",
                                |v|
                                    v.index(1usize as
                                                ::core::primitive::u8).docs(&["Anyone can compound rewards on a pool member's behalf."])).variant("PermissionlessWithdraw",
                            |v|
                                v.index(2usize as
                                            ::core::primitive::u8).docs(&["Anyone can withdraw rewards on a pool member's behalf."])).variant("PermissionlessAll",
                        |v|
                            v.index(3usize as
                                        ::core::primitive::u8).docs(&["Anyone can withdraw and compound rewards on a pool member's behalf."])))
            }
        }
        ;
    };
impl ClaimPermission {
    fn can_bond_extra(&self) -> bool {
        match self {
            ClaimPermission::PermissionlessAll |
                ClaimPermission::PermissionlessCompound => true,
            _ => false,
        }
    }
    fn can_claim_payout(&self) -> bool {
        match self {
            ClaimPermission::PermissionlessAll |
                ClaimPermission::PermissionlessWithdraw => true,
            _ => false,
        }
    }
}
impl Default for ClaimPermission {
    fn default() -> Self { Self::Permissioned }
}
/// A member in a pool.
#[codec(mel_bound(T : Config))]
#[scale_info(skip_type_params(T))]
pub struct PoolMember<T: Config> {
    /// The identifier of the pool to which `who` belongs.
    pub pool_id: PoolId,
    /// The quantity of points this member has in the bonded pool or in a sub pool if
    /// `Self::unbonding_era` is some.
    pub points: BalanceOf<T>,
    /// The reward counter at the time of this member's last payout claim.
    pub last_recorded_reward_counter: T::RewardCounter,
    /// The eras in which this member is unbonding, mapped from era index to the number of
    /// points scheduled to unbond in the given era.
    pub unbonding_eras: BoundedBTreeMap<EraIndex, BalanceOf<T>,
    T::MaxUnbonding>,
}
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::cmp::PartialEq for PoolMember<T> {
            fn eq(&self, other: &Self) -> bool {
                true && self.pool_id == other.pool_id &&
                            self.points == other.points &&
                        self.last_recorded_reward_counter ==
                            other.last_recorded_reward_counter &&
                    self.unbonding_eras == other.unbonding_eras
            }
        }
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::default::Default for PoolMember<T> {
            fn default() -> Self {
                Self {
                    pool_id: ::core::default::Default::default(),
                    points: ::core::default::Default::default(),
                    last_recorded_reward_counter: ::core::default::Default::default(),
                    unbonding_eras: ::core::default::Default::default(),
                }
            }
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for PoolMember<T> where
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            T::RewardCounter: ::codec::Encode,
            T::RewardCounter: ::codec::Encode,
            BoundedBTreeMap<EraIndex, BalanceOf<T>,
            T::MaxUnbonding>: ::codec::Encode,
            BoundedBTreeMap<EraIndex, BalanceOf<T>,
            T::MaxUnbonding>: ::codec::Encode {
            fn size_hint(&self) -> usize {
                0_usize.saturating_add(::codec::Encode::size_hint(&self.pool_id)).saturating_add(::codec::Encode::size_hint(&self.points)).saturating_add(::codec::Encode::size_hint(&self.last_recorded_reward_counter)).saturating_add(::codec::Encode::size_hint(&self.unbonding_eras))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                ::codec::Encode::encode_to(&self.pool_id, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.points, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.last_recorded_reward_counter,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.unbonding_eras,
                    __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for PoolMember<T> where
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            T::RewardCounter: ::codec::Encode,
            T::RewardCounter: ::codec::Encode,
            BoundedBTreeMap<EraIndex, BalanceOf<T>,
            T::MaxUnbonding>: ::codec::Encode,
            BoundedBTreeMap<EraIndex, BalanceOf<T>,
            T::MaxUnbonding>: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for PoolMember<T> where
            BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
            T::RewardCounter: ::codec::Decode,
            T::RewardCounter: ::codec::Decode,
            BoundedBTreeMap<EraIndex, BalanceOf<T>,
            T::MaxUnbonding>: ::codec::Decode,
            BoundedBTreeMap<EraIndex, BalanceOf<T>,
            T::MaxUnbonding>: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(PoolMember::<T> {
                        pool_id: {
                            let __codec_res_edqy =
                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `PoolMember::pool_id`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        points: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `PoolMember::points`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        last_recorded_reward_counter: {
                            let __codec_res_edqy =
                                <T::RewardCounter as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `PoolMember::last_recorded_reward_counter`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        unbonding_eras: {
                            let __codec_res_edqy =
                                <BoundedBTreeMap<EraIndex, BalanceOf<T>, T::MaxUnbonding> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `PoolMember::unbonding_eras`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                    })
            }
        }
    };
const _: () =
    {
        impl<T: Config> ::codec::MaxEncodedLen for PoolMember<T> where
            T: Config {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.saturating_add(<PoolId>::max_encoded_len()).saturating_add(<BalanceOf<T>>::max_encoded_len()).saturating_add(<T::RewardCounter>::max_encoded_len()).saturating_add(<BoundedBTreeMap<EraIndex,
                            BalanceOf<T>, T::MaxUnbonding>>::max_encoded_len())
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<T: Config> ::scale_info::TypeInfo for PoolMember<T> where
            BalanceOf<T>: ::scale_info::TypeInfo + 'static,
            T::RewardCounter: ::scale_info::TypeInfo + 'static,
            BoundedBTreeMap<EraIndex, BalanceOf<T>,
            T::MaxUnbonding>: ::scale_info::TypeInfo + 'static, T: Config +
            'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("PoolMember",
                                    "pallet_nomination_pools",
                                    &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                ::core::option::Option::None)]))).docs(&["A member in a pool."]).composite(::scale_info::build::Fields::named().field(|f|
                                        f.ty::<PoolId>().name("pool_id").type_name("PoolId").docs(&["The identifier of the pool to which `who` belongs."])).field(|f|
                                    f.ty::<BalanceOf<T>>().name("points").type_name("BalanceOf<T>").docs(&["The quantity of points this member has in the bonded pool or in a sub pool if",
                                                    "`Self::unbonding_era` is some."])).field(|f|
                                f.ty::<T::RewardCounter>().name("last_recorded_reward_counter").type_name("T::RewardCounter").docs(&["The reward counter at the time of this member's last payout claim."])).field(|f|
                            f.ty::<BoundedBTreeMap<EraIndex, BalanceOf<T>,
                                            T::MaxUnbonding>>().name("unbonding_eras").type_name("BoundedBTreeMap<EraIndex, BalanceOf<T>, T::MaxUnbonding>").docs(&["The eras in which this member is unbonding, mapped from era index to the number of",
                                            "points scheduled to unbond in the given era."])))
            }
        }
        ;
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::fmt::Debug for PoolMember<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                fmt.debug_struct("PoolMember").field("pool_id",
                                    &self.pool_id).field("points",
                                &self.points).field("last_recorded_reward_counter",
                            &self.last_recorded_reward_counter).field("unbonding_eras",
                        &self.unbonding_eras).finish()
            }
        }
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::clone::Clone for PoolMember<T> {
            fn clone(&self) -> Self {
                Self {
                    pool_id: ::core::clone::Clone::clone(&self.pool_id),
                    points: ::core::clone::Clone::clone(&self.points),
                    last_recorded_reward_counter: ::core::clone::Clone::clone(&self.last_recorded_reward_counter),
                    unbonding_eras: ::core::clone::Clone::clone(&self.unbonding_eras),
                }
            }
        }
    };
impl<T: Config> PoolMember<T> {
    /// The pending rewards of this member.
    fn pending_rewards(&self, current_reward_counter: T::RewardCounter)
        -> Result<BalanceOf<T>, Error<T>> {
        (current_reward_counter.defensive_saturating_sub(self.last_recorded_reward_counter)).checked_mul_int(self.active_points()).ok_or(Error::<T>::OverflowRisk)
    }
    /// Active balance of the member.
    ///
    /// This is derived from the ratio of points in the pool to which the member belongs to.
    /// Might return different values based on the pool state for the same member and points.
    fn active_balance(&self) -> BalanceOf<T> {
        if let Some(pool) = BondedPool::<T>::get(self.pool_id).defensive() {
                pool.points_to_balance(self.points)
            } else { Zero::zero() }
    }
    /// Total balance of the member, both active and unbonding.
    /// Doesn't mutate state.
    #[cfg(any(feature = "try-runtime", feature = "fuzzing", test,
    debug_assertions))]
    fn total_balance(&self) -> BalanceOf<T> {
        let pool = BondedPool::<T>::get(self.pool_id).unwrap();
        let active_balance = pool.points_to_balance(self.active_points());
        let sub_pools =
            match SubPoolsStorage::<T>::get(self.pool_id) {
                Some(sub_pools) => sub_pools,
                None => return active_balance,
            };
        let unbonding_balance =
            self.unbonding_eras.iter().fold(BalanceOf::<T>::zero(),
                |accumulator, (era, unlocked_points)|
                    {
                        let era_pool =
                            sub_pools.with_era.get(era).unwrap_or(&sub_pools.no_era);
                        accumulator + (era_pool.point_to_balance(*unlocked_points))
                    });
        active_balance + unbonding_balance
    }
    /// Total points of this member, both active and unbonding.
    fn total_points(&self) -> BalanceOf<T> {
        self.active_points().saturating_add(self.unbonding_points())
    }
    /// Active points of the member.
    fn active_points(&self) -> BalanceOf<T> { self.points }
    /// Inactive points of the member, waiting to be withdrawn.
    fn unbonding_points(&self) -> BalanceOf<T> {
        self.unbonding_eras.as_ref().iter().fold(BalanceOf::<T>::zero(),
            |acc, (_, v)| acc.saturating_add(*v))
    }
    /// Try and unbond `points_dissolved` from self, and in return mint `points_issued` into the
    /// corresponding `era`'s unlock schedule.
    ///
    /// In the absence of slashing, these two points are always the same. In the presence of
    /// slashing, the value of points in different pools varies.
    ///
    /// Returns `Ok(())` and updates `unbonding_eras` and `points` if success, `Err(_)` otherwise.
    fn try_unbond(&mut self, points_dissolved: BalanceOf<T>,
        points_issued: BalanceOf<T>, unbonding_era: EraIndex)
        -> Result<(), Error<T>> {
        if let Some(new_points) = self.points.checked_sub(&points_dissolved) {
                match self.unbonding_eras.get_mut(&unbonding_era) {
                    Some(already_unbonding_points) =>
                        *already_unbonding_points =
                            already_unbonding_points.saturating_add(points_issued),
                    None =>
                        self.unbonding_eras.try_insert(unbonding_era,
                                        points_issued).map(|old|
                                        {
                                            if old.is_some() {
                                                    {
                                                        let lvl = ::log::Level::Error;
                                                        if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                                    lvl <= ::log::max_level() {
                                                                ::log::__private_api::log(format_args!("{0}: {1:?}",
                                                                        ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                                                        "value checked to not exist in the map; qed"), lvl,
                                                                    &("runtime::defensive", "pallet_nomination_pools",
                                                                            "substrate/frame/nomination-pools/src/lib.rs"), 607u32,
                                                                    ::log::__private_api::Option::None);
                                                            }
                                                    };
                                                    if true {
                                                            if !false {
                                                                    {
                                                                        ::core::panicking::panic_fmt(format_args!("{0}: {1:?}",
                                                                                ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                                                                "value checked to not exist in the map; qed"));
                                                                    }
                                                                };
                                                        };
                                                    ;
                                                }
                                        }).map_err(|_| Error::<T>::MaxUnbondingLimit)?,
                }
                self.points = new_points;
                Ok(())
            } else { Err(Error::<T>::MinimumBondNotMet) }
    }
    /// Withdraw any funds in [`Self::unbonding_eras`] who's deadline in reached and is fully
    /// unlocked.
    ///
    /// Returns a a subset of [`Self::unbonding_eras`] that got withdrawn.
    ///
    /// Infallible, noop if no unbonding eras exist.
    fn withdraw_unlocked(&mut self, current_era: EraIndex)
        -> BoundedBTreeMap<EraIndex, BalanceOf<T>, T::MaxUnbonding> {
        let mut removed_points =
            BoundedBTreeMap::<EraIndex, BalanceOf<T>,
                    T::MaxUnbonding>::default();
        self.unbonding_eras.retain(|e, p|
                {
                    if *e > current_era {
                            true
                        } else {
                           removed_points.try_insert(*e,
                                   *p).expect("source map is bounded, this is a subset, will be bounded; qed");
                           false
                       }
                });
        removed_points
    }
}
/// A pool's possible states.
pub enum PoolState {

    /// The pool is open to be joined, and is working normally.
    Open,

    /// The pool is blocked. No one else can join.
    Blocked,

    /// The pool is in the process of being destroyed.
    ///
    /// All members can now be permissionlessly unbonded, and the pool can never go back to any
    /// other state other than being dissolved.
    Destroying,
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl ::codec::Encode for PoolState {
            fn size_hint(&self) -> usize {
                1_usize +
                    match *self {
                        PoolState::Open => { 0_usize }
                        PoolState::Blocked => { 0_usize }
                        PoolState::Destroying => { 0_usize }
                        _ => 0_usize,
                    }
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                match *self {
                    PoolState::Open => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(0usize as
                                ::core::primitive::u8);
                    }
                    PoolState::Blocked => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(1usize as
                                ::core::primitive::u8);
                    }
                    PoolState::Destroying => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(2usize as
                                ::core::primitive::u8);
                    }
                    _ => (),
                }
            }
        }
        #[automatically_derived]
        impl ::codec::EncodeLike for PoolState { }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl ::codec::Decode for PoolState {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy.read_byte().map_err(|e|
                                e.chain("Could not decode `PoolState`, failed to read variant byte"))?
                    {
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 0usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        { ::core::result::Result::Ok(PoolState::Open) })();
                    }
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 1usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        { ::core::result::Result::Ok(PoolState::Blocked) })();
                    }
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 2usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        { ::core::result::Result::Ok(PoolState::Destroying) })();
                    }
                    _ => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Err(<_ as
                                                        ::core::convert::Into<_>>::into("Could not decode `PoolState`, variant doesn't exist"))
                                        })();
                    }
                }
            }
        }
    };
const _: () =
    {
        impl ::codec::MaxEncodedLen for PoolState {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.max(0_usize).max(0_usize).max(0_usize).saturating_add(1)
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl ::scale_info::TypeInfo for PoolState {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("PoolState",
                                    "pallet_nomination_pools",
                                    &[])).type_params(::alloc::vec::Vec::new()).docs(&["A pool's possible states."]).variant(::scale_info::build::Variants::new().variant("Open",
                                |v|
                                    v.index(0usize as
                                                ::core::primitive::u8).docs(&["The pool is open to be joined, and is working normally."])).variant("Blocked",
                            |v|
                                v.index(1usize as
                                            ::core::primitive::u8).docs(&["The pool is blocked. No one else can join."])).variant("Destroying",
                        |v|
                            v.index(2usize as
                                        ::core::primitive::u8).docs(&["The pool is in the process of being destroyed.",
                                            "",
                                            "All members can now be permissionlessly unbonded, and the pool can never go back to any",
                                            "other state other than being dissolved."])))
            }
        }
        ;
    };
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for PoolState { }
#[automatically_derived]
impl ::core::cmp::PartialEq for PoolState {
    #[inline]
    fn eq(&self, other: &PoolState) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
    }
}
const _: () =
    {
        #[automatically_derived]
        impl ::core::fmt::Debug for PoolState {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                match *self {
                    Self::Open => fmt.write_str("PoolState::Open"),
                    Self::Blocked => fmt.write_str("PoolState::Blocked"),
                    Self::Destroying => fmt.write_str("PoolState::Destroying"),
                }
            }
        }
    };
#[automatically_derived]
impl ::core::clone::Clone for PoolState {
    #[inline]
    fn clone(&self) -> PoolState { *self }
}
#[automatically_derived]
impl ::core::marker::Copy for PoolState { }
/// Pool administration roles.
///
/// Any pool has a depositor, which can never change. But, all the other roles are optional, and
/// cannot exist. Note that if `root` is set to `None`, it basically means that the roles of this
/// pool can never change again (except via governance).
pub struct PoolRoles<AccountId> {
    /// Creates the pool and is the initial member. They can only leave the pool once all other
    /// members have left. Once they fully leave, the pool is destroyed.
    pub depositor: AccountId,
    /// Can change the nominator, bouncer, or itself and can perform any of the actions the
    /// nominator or bouncer can.
    pub root: Option<AccountId>,
    /// Can select which validators the pool nominates.
    pub nominator: Option<AccountId>,
    /// Can change the pools state and kick members if the pool is blocked.
    pub bouncer: Option<AccountId>,
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<AccountId> ::codec::Encode for PoolRoles<AccountId> where
            AccountId: ::codec::Encode, AccountId: ::codec::Encode,
            Option<AccountId>: ::codec::Encode,
            Option<AccountId>: ::codec::Encode,
            Option<AccountId>: ::codec::Encode,
            Option<AccountId>: ::codec::Encode,
            Option<AccountId>: ::codec::Encode,
            Option<AccountId>: ::codec::Encode {
            fn size_hint(&self) -> usize {
                0_usize.saturating_add(::codec::Encode::size_hint(&self.depositor)).saturating_add(::codec::Encode::size_hint(&self.root)).saturating_add(::codec::Encode::size_hint(&self.nominator)).saturating_add(::codec::Encode::size_hint(&self.bouncer))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                ::codec::Encode::encode_to(&self.depositor,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.root, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.nominator,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.bouncer, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<AccountId> ::codec::EncodeLike for PoolRoles<AccountId> where
            AccountId: ::codec::Encode, AccountId: ::codec::Encode,
            Option<AccountId>: ::codec::Encode,
            Option<AccountId>: ::codec::Encode,
            Option<AccountId>: ::codec::Encode,
            Option<AccountId>: ::codec::Encode,
            Option<AccountId>: ::codec::Encode,
            Option<AccountId>: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<AccountId> ::codec::Decode for PoolRoles<AccountId> where
            AccountId: ::codec::Decode, AccountId: ::codec::Decode,
            Option<AccountId>: ::codec::Decode,
            Option<AccountId>: ::codec::Decode,
            Option<AccountId>: ::codec::Decode,
            Option<AccountId>: ::codec::Decode,
            Option<AccountId>: ::codec::Decode,
            Option<AccountId>: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(PoolRoles::<AccountId> {
                        depositor: {
                            let __codec_res_edqy =
                                <AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `PoolRoles::depositor`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        root: {
                            let __codec_res_edqy =
                                <Option<AccountId> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `PoolRoles::root`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        nominator: {
                            let __codec_res_edqy =
                                <Option<AccountId> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `PoolRoles::nominator`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        bouncer: {
                            let __codec_res_edqy =
                                <Option<AccountId> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `PoolRoles::bouncer`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                    })
            }
        }
    };
const _: () =
    {
        impl<AccountId> ::codec::MaxEncodedLen for PoolRoles<AccountId> where
            AccountId: ::codec::MaxEncodedLen,
            AccountId: ::codec::MaxEncodedLen,
            Option<AccountId>: ::codec::MaxEncodedLen,
            Option<AccountId>: ::codec::MaxEncodedLen,
            Option<AccountId>: ::codec::MaxEncodedLen,
            Option<AccountId>: ::codec::MaxEncodedLen,
            Option<AccountId>: ::codec::MaxEncodedLen,
            Option<AccountId>: ::codec::MaxEncodedLen {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.saturating_add(<AccountId>::max_encoded_len()).saturating_add(<Option<AccountId>>::max_encoded_len()).saturating_add(<Option<AccountId>>::max_encoded_len()).saturating_add(<Option<AccountId>>::max_encoded_len())
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<AccountId> ::scale_info::TypeInfo for PoolRoles<AccountId> where
            AccountId: ::scale_info::TypeInfo + 'static,
            Option<AccountId>: ::scale_info::TypeInfo + 'static,
            Option<AccountId>: ::scale_info::TypeInfo + 'static,
            Option<AccountId>: ::scale_info::TypeInfo + 'static,
            AccountId: ::scale_info::TypeInfo + 'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("PoolRoles",
                                    "pallet_nomination_pools",
                                    &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("AccountId",
                                                ::core::option::Option::Some(::scale_info::meta_type::<AccountId>()))]))).docs(&["Pool administration roles.",
                                    "",
                                    "Any pool has a depositor, which can never change. But, all the other roles are optional, and",
                                    "cannot exist. Note that if `root` is set to `None`, it basically means that the roles of this",
                                    "pool can never change again (except via governance)."]).composite(::scale_info::build::Fields::named().field(|f|
                                        f.ty::<AccountId>().name("depositor").type_name("AccountId").docs(&["Creates the pool and is the initial member. They can only leave the pool once all other",
                                                        "members have left. Once they fully leave, the pool is destroyed."])).field(|f|
                                    f.ty::<Option<AccountId>>().name("root").type_name("Option<AccountId>").docs(&["Can change the nominator, bouncer, or itself and can perform any of the actions the",
                                                    "nominator or bouncer can."])).field(|f|
                                f.ty::<Option<AccountId>>().name("nominator").type_name("Option<AccountId>").docs(&["Can select which validators the pool nominates."])).field(|f|
                            f.ty::<Option<AccountId>>().name("bouncer").type_name("Option<AccountId>").docs(&["Can change the pools state and kick members if the pool is blocked."])))
            }
        }
        ;
    };
#[automatically_derived]
impl<AccountId: ::core::fmt::Debug> ::core::fmt::Debug for
    PoolRoles<AccountId> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field4_finish(f, "PoolRoles",
            "depositor", &self.depositor, "root", &self.root, "nominator",
            &self.nominator, "bouncer", &&self.bouncer)
    }
}
#[automatically_derived]
impl<AccountId> ::core::marker::StructuralPartialEq for PoolRoles<AccountId> {
}
#[automatically_derived]
impl<AccountId: ::core::cmp::PartialEq> ::core::cmp::PartialEq for
    PoolRoles<AccountId> {
    #[inline]
    fn eq(&self, other: &PoolRoles<AccountId>) -> bool {
        self.depositor == other.depositor && self.root == other.root &&
                self.nominator == other.nominator &&
            self.bouncer == other.bouncer
    }
}
#[automatically_derived]
impl<AccountId: ::core::clone::Clone> ::core::clone::Clone for
    PoolRoles<AccountId> {
    #[inline]
    fn clone(&self) -> PoolRoles<AccountId> {
        PoolRoles {
            depositor: ::core::clone::Clone::clone(&self.depositor),
            root: ::core::clone::Clone::clone(&self.root),
            nominator: ::core::clone::Clone::clone(&self.nominator),
            bouncer: ::core::clone::Clone::clone(&self.bouncer),
        }
    }
}
pub enum CommissionClaimPermission<AccountId> {
    Permissionless,
    Account(AccountId),
}
#[automatically_derived]
impl<AccountId> ::core::marker::StructuralPartialEq for
    CommissionClaimPermission<AccountId> {
}
#[automatically_derived]
impl<AccountId: ::core::cmp::PartialEq> ::core::cmp::PartialEq for
    CommissionClaimPermission<AccountId> {
    #[inline]
    fn eq(&self, other: &CommissionClaimPermission<AccountId>) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag &&
            match (self, other) {
                (CommissionClaimPermission::Account(__self_0),
                    CommissionClaimPermission::Account(__arg1_0)) =>
                    *__self_0 == *__arg1_0,
                _ => true,
            }
    }
}
#[automatically_derived]
impl<AccountId> ::core::marker::StructuralEq for
    CommissionClaimPermission<AccountId> {
}
#[automatically_derived]
impl<AccountId: ::core::cmp::Eq> ::core::cmp::Eq for
    CommissionClaimPermission<AccountId> {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<AccountId>;
    }
}
#[automatically_derived]
impl<AccountId: ::core::marker::Copy> ::core::marker::Copy for
    CommissionClaimPermission<AccountId> {
}
#[automatically_derived]
impl<AccountId: ::core::clone::Clone> ::core::clone::Clone for
    CommissionClaimPermission<AccountId> {
    #[inline]
    fn clone(&self) -> CommissionClaimPermission<AccountId> {
        match self {
            CommissionClaimPermission::Permissionless =>
                CommissionClaimPermission::Permissionless,
            CommissionClaimPermission::Account(__self_0) =>
                CommissionClaimPermission::Account(::core::clone::Clone::clone(__self_0)),
        }
    }
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<AccountId> ::codec::Encode for
            CommissionClaimPermission<AccountId> where
            AccountId: ::codec::Encode, AccountId: ::codec::Encode {
            fn size_hint(&self) -> usize {
                1_usize +
                    match *self {
                        CommissionClaimPermission::Permissionless => { 0_usize }
                        CommissionClaimPermission::Account(ref aa) => {
                            0_usize.saturating_add(::codec::Encode::size_hint(aa))
                        }
                        _ => 0_usize,
                    }
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                match *self {
                    CommissionClaimPermission::Permissionless => {

                        #[allow(clippy :: unnecessary_cast)]
                        __codec_dest_edqy.push_byte(0usize as
                                ::core::primitive::u8);
                    }
                    CommissionClaimPermission::Account(ref aa) => {
                        __codec_dest_edqy.push_byte(1usize as
                                ::core::primitive::u8);
                        ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                    }
                    _ => (),
                }
            }
        }
        #[automatically_derived]
        impl<AccountId> ::codec::EncodeLike for
            CommissionClaimPermission<AccountId> where
            AccountId: ::codec::Encode, AccountId: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<AccountId> ::codec::Decode for
            CommissionClaimPermission<AccountId> where
            AccountId: ::codec::Decode, AccountId: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy.read_byte().map_err(|e|
                                e.chain("Could not decode `CommissionClaimPermission`, failed to read variant byte"))?
                    {
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 0usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Ok(CommissionClaimPermission::<AccountId>::Permissionless)
                                        })();
                    }
                        #[allow(clippy :: unnecessary_cast)]
                        __codec_x_edqy if
                        __codec_x_edqy == 1usize as ::core::primitive::u8 => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Ok(CommissionClaimPermission::<AccountId>::Account({
                                                        let __codec_res_edqy =
                                                            <AccountId as ::codec::Decode>::decode(__codec_input_edqy);
                                                        match __codec_res_edqy {
                                                            ::core::result::Result::Err(e) =>
                                                                return ::core::result::Result::Err(e.chain("Could not decode `CommissionClaimPermission::Account.0`")),
                                                            ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                __codec_res_edqy,
                                                        }
                                                    }))
                                        })();
                    }
                    _ => {

                        #[allow(clippy :: redundant_closure_call)]
                        return (move ||
                                        {
                                            ::core::result::Result::Err(<_ as
                                                        ::core::convert::Into<_>>::into("Could not decode `CommissionClaimPermission`, variant doesn't exist"))
                                        })();
                    }
                }
            }
        }
    };
impl<AccountId> core::fmt::Debug for CommissionClaimPermission<AccountId>
    where AccountId: core::fmt::Debug {
    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Self::Permissionless =>
                fmt.debug_tuple("CommissionClaimPermission::Permissionless").finish(),
            Self::Account(ref a0) =>
                fmt.debug_tuple("CommissionClaimPermission::Account").field(a0).finish(),
            _ => Ok(()),
        }
    }
}
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<AccountId> ::scale_info::TypeInfo for
            CommissionClaimPermission<AccountId> where
            AccountId: ::scale_info::TypeInfo + 'static,
            AccountId: ::scale_info::TypeInfo + 'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("CommissionClaimPermission",
                                "pallet_nomination_pools",
                                &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("AccountId",
                                            ::core::option::Option::Some(::scale_info::meta_type::<AccountId>()))]))).variant(::scale_info::build::Variants::new().variant("Permissionless",
                            |v|
                                v.index(0usize as
                                        ::core::primitive::u8)).variant("Account",
                        |v|
                            v.index(1usize as
                                        ::core::primitive::u8).fields(::scale_info::build::Fields::unnamed().field(|f|
                                        f.ty::<AccountId>().type_name("AccountId")))))
            }
        }
        ;
    };
const _: () =
    {
        impl<AccountId> ::codec::MaxEncodedLen for
            CommissionClaimPermission<AccountId> where
            AccountId: ::codec::MaxEncodedLen,
            AccountId: ::codec::MaxEncodedLen {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.max(0_usize).max(0_usize.saturating_add(<AccountId>::max_encoded_len())).saturating_add(1)
            }
        }
    };
/// Pool commission.
///
/// The pool `root` can set commission configuration after pool creation. By default, all commission
/// values are `None`. Pool `root` can also set `max` and `change_rate` configurations before
/// setting an initial `current` commission.
///
/// `current` is a tuple of the commission percentage and payee of commission. `throttle_from`
/// keeps track of which block `current` was last updated. A `max` commission value can only be
/// decreased after the initial value is set, to prevent commission from repeatedly increasing.
///
/// An optional commission `change_rate` allows the pool to set strict limits to how much commission
/// can change in each update, and how often updates can take place.
#[codec(mel_bound(T : Config))]
#[scale_info(skip_type_params(T))]
pub struct Commission<T: Config> {
    /// Optional commission rate of the pool along with the account commission is paid to.
    pub current: Option<(Perbill, T::AccountId)>,
    /// Optional maximum commission that can be set by the pool `root`. Once set, this value can
    /// only be updated to a decreased value.
    pub max: Option<Perbill>,
    /// Optional configuration around how often commission can be updated, and when the last
    /// commission update took place.
    pub change_rate: Option<CommissionChangeRate<BlockNumberFor<T>>>,
    /// The block from where throttling should be checked from. This value will be updated on all
    /// commission updates and when setting an initial `change_rate`.
    pub throttle_from: Option<BlockNumberFor<T>>,
    pub claim_permission: Option<CommissionClaimPermission<T::AccountId>>,
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for Commission<T> where
            Option<(Perbill, T::AccountId)>: ::codec::Encode,
            Option<(Perbill, T::AccountId)>: ::codec::Encode,
            Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Encode,
            Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Encode,
            Option<BlockNumberFor<T>>: ::codec::Encode,
            Option<BlockNumberFor<T>>: ::codec::Encode,
            Option<CommissionClaimPermission<T::AccountId>>: ::codec::Encode,
            Option<CommissionClaimPermission<T::AccountId>>: ::codec::Encode {
            fn size_hint(&self) -> usize {
                0_usize.saturating_add(::codec::Encode::size_hint(&self.current)).saturating_add(::codec::Encode::size_hint(&self.max)).saturating_add(::codec::Encode::size_hint(&self.change_rate)).saturating_add(::codec::Encode::size_hint(&self.throttle_from)).saturating_add(::codec::Encode::size_hint(&self.claim_permission))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                ::codec::Encode::encode_to(&self.current, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.max, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.change_rate,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.throttle_from,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.claim_permission,
                    __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for Commission<T> where
            Option<(Perbill, T::AccountId)>: ::codec::Encode,
            Option<(Perbill, T::AccountId)>: ::codec::Encode,
            Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Encode,
            Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Encode,
            Option<BlockNumberFor<T>>: ::codec::Encode,
            Option<BlockNumberFor<T>>: ::codec::Encode,
            Option<CommissionClaimPermission<T::AccountId>>: ::codec::Encode,
            Option<CommissionClaimPermission<T::AccountId>>: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for Commission<T> where
            Option<(Perbill, T::AccountId)>: ::codec::Decode,
            Option<(Perbill, T::AccountId)>: ::codec::Decode,
            Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Decode,
            Option<CommissionChangeRate<BlockNumberFor<T>>>: ::codec::Decode,
            Option<BlockNumberFor<T>>: ::codec::Decode,
            Option<BlockNumberFor<T>>: ::codec::Decode,
            Option<CommissionClaimPermission<T::AccountId>>: ::codec::Decode,
            Option<CommissionClaimPermission<T::AccountId>>: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(Commission::<T> {
                        current: {
                            let __codec_res_edqy =
                                <Option<(Perbill, T::AccountId)> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `Commission::current`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        max: {
                            let __codec_res_edqy =
                                <Option<Perbill> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `Commission::max`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        change_rate: {
                            let __codec_res_edqy =
                                <Option<CommissionChangeRate<BlockNumberFor<T>>> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `Commission::change_rate`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        throttle_from: {
                            let __codec_res_edqy =
                                <Option<BlockNumberFor<T>> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `Commission::throttle_from`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        claim_permission: {
                            let __codec_res_edqy =
                                <Option<CommissionClaimPermission<T::AccountId>> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `Commission::claim_permission`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                    })
            }
        }
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::default::Default for Commission<T> {
            fn default() -> Self {
                Self {
                    current: ::core::default::Default::default(),
                    max: ::core::default::Default::default(),
                    change_rate: ::core::default::Default::default(),
                    throttle_from: ::core::default::Default::default(),
                    claim_permission: ::core::default::Default::default(),
                }
            }
        }
    };
const _: () =
    {
        impl<T: Config> ::codec::MaxEncodedLen for Commission<T> where
            T: Config {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.saturating_add(<Option<(Perbill,
                                            T::AccountId)>>::max_encoded_len()).saturating_add(<Option<Perbill>>::max_encoded_len()).saturating_add(<Option<CommissionChangeRate<BlockNumberFor<T>>>>::max_encoded_len()).saturating_add(<Option<BlockNumberFor<T>>>::max_encoded_len()).saturating_add(<Option<CommissionClaimPermission<T::AccountId>>>::max_encoded_len())
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<T: Config> ::scale_info::TypeInfo for Commission<T> where
            Option<(Perbill, T::AccountId)>: ::scale_info::TypeInfo + 'static,
            Option<CommissionChangeRate<BlockNumberFor<T>>>: ::scale_info::TypeInfo +
            'static, Option<BlockNumberFor<T>>: ::scale_info::TypeInfo +
            'static,
            Option<CommissionClaimPermission<T::AccountId>>: ::scale_info::TypeInfo +
            'static, T: Config + 'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("Commission",
                                    "pallet_nomination_pools",
                                    &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                ::core::option::Option::None)]))).docs(&["Pool commission.",
                                    "",
                                    "The pool `root` can set commission configuration after pool creation. By default, all commission",
                                    "values are `None`. Pool `root` can also set `max` and `change_rate` configurations before",
                                    "setting an initial `current` commission.", "",
                                    "`current` is a tuple of the commission percentage and payee of commission. `throttle_from`",
                                    "keeps track of which block `current` was last updated. A `max` commission value can only be",
                                    "decreased after the initial value is set, to prevent commission from repeatedly increasing.",
                                    "",
                                    "An optional commission `change_rate` allows the pool to set strict limits to how much commission",
                                    "can change in each update, and how often updates can take place."]).composite(::scale_info::build::Fields::named().field(|f|
                                            f.ty::<Option<(Perbill,
                                                            T::AccountId)>>().name("current").type_name("Option<(Perbill, T::AccountId)>").docs(&["Optional commission rate of the pool along with the account commission is paid to."])).field(|f|
                                        f.ty::<Option<Perbill>>().name("max").type_name("Option<Perbill>").docs(&["Optional maximum commission that can be set by the pool `root`. Once set, this value can",
                                                        "only be updated to a decreased value."])).field(|f|
                                    f.ty::<Option<CommissionChangeRate<BlockNumberFor<T>>>>().name("change_rate").type_name("Option<CommissionChangeRate<BlockNumberFor<T>>>").docs(&["Optional configuration around how often commission can be updated, and when the last",
                                                    "commission update took place."])).field(|f|
                                f.ty::<Option<BlockNumberFor<T>>>().name("throttle_from").type_name("Option<BlockNumberFor<T>>").docs(&["The block from where throttling should be checked from. This value will be updated on all",
                                                "commission updates and when setting an initial `change_rate`."])).field(|f|
                            f.ty::<Option<CommissionClaimPermission<T::AccountId>>>().name("claim_permission").type_name("Option<CommissionClaimPermission<T::AccountId>>")))
            }
        }
        ;
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::fmt::Debug for Commission<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                fmt.debug_struct("Commission").field("current",
                                        &self.current).field("max",
                                    &self.max).field("change_rate",
                                &self.change_rate).field("throttle_from",
                            &self.throttle_from).field("claim_permission",
                        &self.claim_permission).finish()
            }
        }
    };
#[automatically_derived]
impl<T: Config> ::core::marker::StructuralPartialEq for Commission<T> { }
#[automatically_derived]
impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for
    Commission<T> where T::AccountId: ::core::cmp::PartialEq,
    T::AccountId: ::core::cmp::PartialEq {
    #[inline]
    fn eq(&self, other: &Commission<T>) -> bool {
        self.current == other.current && self.max == other.max &&
                    self.change_rate == other.change_rate &&
                self.throttle_from == other.throttle_from &&
            self.claim_permission == other.claim_permission
    }
}
#[automatically_derived]
impl<T: ::core::marker::Copy + Config> ::core::marker::Copy for Commission<T>
    where T::AccountId: ::core::marker::Copy,
    T::AccountId: ::core::marker::Copy {
}
#[automatically_derived]
impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for Commission<T>
    where T::AccountId: ::core::clone::Clone,
    T::AccountId: ::core::clone::Clone {
    #[inline]
    fn clone(&self) -> Commission<T> {
        Commission {
            current: ::core::clone::Clone::clone(&self.current),
            max: ::core::clone::Clone::clone(&self.max),
            change_rate: ::core::clone::Clone::clone(&self.change_rate),
            throttle_from: ::core::clone::Clone::clone(&self.throttle_from),
            claim_permission: ::core::clone::Clone::clone(&self.claim_permission),
        }
    }
}
impl<T: Config> Commission<T> {
    /// Returns true if the current commission updating to `to` would exhaust the change rate
    /// limits.
    ///
    /// A commission update will be throttled (disallowed) if:
    /// 1. not enough blocks have passed since the `throttle_from` block, if exists, or
    /// 2. the new commission is greater than the maximum allowed increase.
    fn throttling(&self, to: &Perbill) -> bool {
        if let Some(t) = self.change_rate.as_ref() {
                let commission_as_percent =
                    self.current.as_ref().map(|(x, _)|
                                *x).unwrap_or(Perbill::zero());
                if *to <= commission_as_percent { return false }
                if (*to).saturating_sub(commission_as_percent) >
                            t.max_increase {
                        return true
                    }
                return self.throttle_from.map_or_else(||
                            {
                                {
                                    let lvl = ::log::Level::Error;
                                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                lvl <= ::log::max_level() {
                                            ::log::__private_api::log(format_args!("{0}: {1:?}",
                                                    ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                                    "throttle_from should exist if change_rate is set"), lvl,
                                                &("runtime::defensive", "pallet_nomination_pools",
                                                        "substrate/frame/nomination-pools/src/lib.rs"), 749u32,
                                                ::log::__private_api::Option::None);
                                        }
                                };
                                if true {
                                        if !false {
                                                {
                                                    ::core::panicking::panic_fmt(format_args!("{0}: {1:?}",
                                                            ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                                            "throttle_from should exist if change_rate is set"));
                                                }
                                            };
                                    };
                                ;
                                true
                            },
                        |f|
                            {
                                if t.min_delay == Zero::zero() {
                                        false
                                    } else {
                                       let blocks_surpassed =
                                           <frame_system::Pallet<T>>::block_number().saturating_sub(f);
                                       blocks_surpassed < t.min_delay
                                   }
                            })
            }
        false
    }
    /// Gets the pool's current commission, or returns Perbill::zero if none is set.
    /// Bounded to global max if current is greater than `GlobalMaxCommission`.
    fn current(&self) -> Perbill {
        self.current.as_ref().map_or(Perbill::zero(),
                |(c, _)|
                    *c).min(GlobalMaxCommission::<T>::get().unwrap_or(Bounded::max_value()))
    }
    /// Set the pool's commission.
    ///
    /// Update commission based on `current`. If a `None` is supplied, allow the commission to be
    /// removed without any change rate restrictions. Updates `throttle_from` to the current block.
    /// If the supplied commission is zero, `None` will be inserted and `payee` will be ignored.
    fn try_update_current(&mut self,
        current: &Option<(Perbill, T::AccountId)>) -> DispatchResult {
        self.current =
            match current {
                None => None,
                Some((commission, payee)) => {
                    {
                        if !!self.throttling(commission) {
                                {
                                    return Err(Error::<T>::CommissionChangeThrottled.into())
                                };
                            }
                    };
                    {
                        if !(commission <=
                                        &GlobalMaxCommission::<T>::get().unwrap_or(Bounded::max_value()))
                                {
                                {
                                    return Err(Error::<T>::CommissionExceedsGlobalMaximum.into())
                                };
                            }
                    };
                    {
                        if !self.max.map_or(true, |m| commission <= &m) {
                                { return Err(Error::<T>::CommissionExceedsMaximum.into()) };
                            }
                    };
                    if commission.is_zero() {
                            None
                        } else { Some((*commission, payee.clone())) }
                }
            };
        self.register_update();
        Ok(())
    }
    /// Set the pool's maximum commission.
    ///
    /// The pool's maximum commission can initially be set to any value, and only smaller values
    /// thereafter. If larger values are attempted, this function will return a dispatch error.
    ///
    /// If `current.0` is larger than the updated max commission value, `current.0` will also be
    /// updated to the new maximum. This will also register a `throttle_from` update.
    /// A `PoolCommissionUpdated` event is triggered if `current.0` is updated.
    fn try_update_max(&mut self, pool_id: PoolId, new_max: Perbill)
        -> DispatchResult {
        {
            if !(new_max <=
                            GlobalMaxCommission::<T>::get().unwrap_or(Bounded::max_value()))
                    {
                    {
                        return Err(Error::<T>::CommissionExceedsGlobalMaximum.into())
                    };
                }
        };
        if let Some(old) = self.max.as_mut() {
                if new_max > *old {
                        return Err(Error::<T>::MaxCommissionRestricted.into())
                    }
                *old = new_max;
            } else { self.max = Some(new_max) };
        let updated_current =
            self.current.as_mut().map(|(c, _)|
                        {
                            let u = *c > new_max;
                            *c = (*c).min(new_max);
                            u
                        }).unwrap_or(false);
        if updated_current {
                if let Some((_, payee)) = self.current.as_ref() {
                        Pallet::<T>::deposit_event(Event::<T>::PoolCommissionUpdated {
                                pool_id,
                                current: Some((new_max, payee.clone())),
                            });
                    }
                self.register_update();
            }
        Ok(())
    }
    /// Set the pool's commission `change_rate`.
    ///
    /// Once a change rate configuration has been set, only more restrictive values can be set
    /// thereafter. These restrictions translate to increased `min_delay` values and decreased
    /// `max_increase` values.
    ///
    /// Update `throttle_from` to the current block upon setting change rate for the first time, so
    /// throttling can be checked from this block.
    fn try_update_change_rate(&mut self,
        change_rate: CommissionChangeRate<BlockNumberFor<T>>)
        -> DispatchResult {
        {
            if !!&self.less_restrictive(&change_rate) {
                    {
                        return Err(Error::<T>::CommissionChangeRateNotAllowed.into())
                    };
                }
        };
        if self.change_rate.is_none() { self.register_update(); }
        self.change_rate = Some(change_rate);
        Ok(())
    }
    /// Updates a commission's `throttle_from` field to the current block.
    fn register_update(&mut self) {
        self.throttle_from = Some(<frame_system::Pallet<T>>::block_number());
    }
    /// Checks whether a change rate is less restrictive than the current change rate, if any.
    ///
    /// No change rate will always be less restrictive than some change rate, so where no
    /// `change_rate` is currently set, `false` is returned.
    fn less_restrictive(&self, new: &CommissionChangeRate<BlockNumberFor<T>>)
        -> bool {
        self.change_rate.as_ref().map(|c|
                    new.max_increase > c.max_increase ||
                        new.min_delay < c.min_delay).unwrap_or(false)
    }
}
/// Pool commission change rate preferences.
///
/// The pool root is able to set a commission change rate for their pool. A commission change rate
/// consists of 2 values; (1) the maximum allowed commission change, and (2) the minimum amount of
/// blocks that must elapse before commission updates are allowed again.
///
/// Commission change rates are not applied to decreases in commission.
pub struct CommissionChangeRate<BlockNumber> {
    /// The maximum amount the commission can be updated by per `min_delay` period.
    pub max_increase: Perbill,
    /// How often an update can take place.
    pub min_delay: BlockNumber,
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<BlockNumber> ::codec::Encode for
            CommissionChangeRate<BlockNumber> where
            BlockNumber: ::codec::Encode, BlockNumber: ::codec::Encode {
            fn size_hint(&self) -> usize {
                0_usize.saturating_add(::codec::Encode::size_hint(&self.max_increase)).saturating_add(::codec::Encode::size_hint(&self.min_delay))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                ::codec::Encode::encode_to(&self.max_increase,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.min_delay,
                    __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<BlockNumber> ::codec::EncodeLike for
            CommissionChangeRate<BlockNumber> where
            BlockNumber: ::codec::Encode, BlockNumber: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<BlockNumber> ::codec::Decode for
            CommissionChangeRate<BlockNumber> where
            BlockNumber: ::codec::Decode, BlockNumber: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(CommissionChangeRate::<BlockNumber> {
                        max_increase: {
                            let __codec_res_edqy =
                                <Perbill as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `CommissionChangeRate::max_increase`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        min_delay: {
                            let __codec_res_edqy =
                                <BlockNumber as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `CommissionChangeRate::min_delay`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                    })
            }
        }
    };
const _: () =
    {
        impl<BlockNumber> ::codec::MaxEncodedLen for
            CommissionChangeRate<BlockNumber> where
            BlockNumber: ::codec::MaxEncodedLen,
            BlockNumber: ::codec::MaxEncodedLen {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.saturating_add(<Perbill>::max_encoded_len()).saturating_add(<BlockNumber>::max_encoded_len())
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<BlockNumber> ::scale_info::TypeInfo for
            CommissionChangeRate<BlockNumber> where
            BlockNumber: ::scale_info::TypeInfo + 'static,
            BlockNumber: ::scale_info::TypeInfo + 'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("CommissionChangeRate",
                                    "pallet_nomination_pools",
                                    &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("BlockNumber",
                                                ::core::option::Option::Some(::scale_info::meta_type::<BlockNumber>()))]))).docs(&["Pool commission change rate preferences.",
                                    "",
                                    "The pool root is able to set a commission change rate for their pool. A commission change rate",
                                    "consists of 2 values; (1) the maximum allowed commission change, and (2) the minimum amount of",
                                    "blocks that must elapse before commission updates are allowed again.",
                                    "",
                                    "Commission change rates are not applied to decreases in commission."]).composite(::scale_info::build::Fields::named().field(|f|
                                f.ty::<Perbill>().name("max_increase").type_name("Perbill").docs(&["The maximum amount the commission can be updated by per `min_delay` period."])).field(|f|
                            f.ty::<BlockNumber>().name("min_delay").type_name("BlockNumber").docs(&["How often an update can take place."])))
            }
        }
        ;
    };
#[automatically_derived]
impl<BlockNumber: ::core::fmt::Debug> ::core::fmt::Debug for
    CommissionChangeRate<BlockNumber> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(f,
            "CommissionChangeRate", "max_increase", &self.max_increase,
            "min_delay", &&self.min_delay)
    }
}
#[automatically_derived]
impl<BlockNumber> ::core::marker::StructuralPartialEq for
    CommissionChangeRate<BlockNumber> {
}
#[automatically_derived]
impl<BlockNumber: ::core::cmp::PartialEq> ::core::cmp::PartialEq for
    CommissionChangeRate<BlockNumber> {
    #[inline]
    fn eq(&self, other: &CommissionChangeRate<BlockNumber>) -> bool {
        self.max_increase == other.max_increase &&
            self.min_delay == other.min_delay
    }
}
#[automatically_derived]
impl<BlockNumber: ::core::marker::Copy> ::core::marker::Copy for
    CommissionChangeRate<BlockNumber> {
}
#[automatically_derived]
impl<BlockNumber: ::core::clone::Clone> ::core::clone::Clone for
    CommissionChangeRate<BlockNumber> {
    #[inline]
    fn clone(&self) -> CommissionChangeRate<BlockNumber> {
        CommissionChangeRate {
            max_increase: ::core::clone::Clone::clone(&self.max_increase),
            min_delay: ::core::clone::Clone::clone(&self.min_delay),
        }
    }
}
/// Pool permissions and state
#[codec(mel_bound(T : Config))]
#[scale_info(skip_type_params(T))]
pub struct BondedPoolInner<T: Config> {
    /// The commission rate of the pool.
    pub commission: Commission<T>,
    /// Count of members that belong to the pool.
    pub member_counter: u32,
    /// Total points of all the members in the pool who are actively bonded.
    pub points: BalanceOf<T>,
    /// See [`PoolRoles`].
    pub roles: PoolRoles<T::AccountId>,
    /// The current state of the pool.
    pub state: PoolState,
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for BondedPoolInner<T> where
            Commission<T>: ::codec::Encode, Commission<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            PoolRoles<T::AccountId>: ::codec::Encode,
            PoolRoles<T::AccountId>: ::codec::Encode {
            fn size_hint(&self) -> usize {
                0_usize.saturating_add(::codec::Encode::size_hint(&self.commission)).saturating_add(::codec::Encode::size_hint(&self.member_counter)).saturating_add(::codec::Encode::size_hint(&self.points)).saturating_add(::codec::Encode::size_hint(&self.roles)).saturating_add(::codec::Encode::size_hint(&self.state))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                ::codec::Encode::encode_to(&self.commission,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.member_counter,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.points, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.roles, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.state, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for BondedPoolInner<T> where
            Commission<T>: ::codec::Encode, Commission<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            PoolRoles<T::AccountId>: ::codec::Encode,
            PoolRoles<T::AccountId>: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for BondedPoolInner<T> where
            Commission<T>: ::codec::Decode, Commission<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
            PoolRoles<T::AccountId>: ::codec::Decode,
            PoolRoles<T::AccountId>: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(BondedPoolInner::<T> {
                        commission: {
                            let __codec_res_edqy =
                                <Commission<T> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `BondedPoolInner::commission`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        member_counter: {
                            let __codec_res_edqy =
                                <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `BondedPoolInner::member_counter`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        points: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `BondedPoolInner::points`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        roles: {
                            let __codec_res_edqy =
                                <PoolRoles<T::AccountId> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `BondedPoolInner::roles`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        state: {
                            let __codec_res_edqy =
                                <PoolState as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `BondedPoolInner::state`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                    })
            }
        }
    };
const _: () =
    {
        impl<T: Config> ::codec::MaxEncodedLen for BondedPoolInner<T> where
            T: Config {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.saturating_add(<Commission<T>>::max_encoded_len()).saturating_add(<u32>::max_encoded_len()).saturating_add(<BalanceOf<T>>::max_encoded_len()).saturating_add(<PoolRoles<T::AccountId>>::max_encoded_len()).saturating_add(<PoolState>::max_encoded_len())
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<T: Config> ::scale_info::TypeInfo for BondedPoolInner<T> where
            Commission<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::TypeInfo + 'static,
            PoolRoles<T::AccountId>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("BondedPoolInner",
                                    "pallet_nomination_pools",
                                    &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                ::core::option::Option::None)]))).docs(&["Pool permissions and state"]).composite(::scale_info::build::Fields::named().field(|f|
                                            f.ty::<Commission<T>>().name("commission").type_name("Commission<T>").docs(&["The commission rate of the pool."])).field(|f|
                                        f.ty::<u32>().name("member_counter").type_name("u32").docs(&["Count of members that belong to the pool."])).field(|f|
                                    f.ty::<BalanceOf<T>>().name("points").type_name("BalanceOf<T>").docs(&["Total points of all the members in the pool who are actively bonded."])).field(|f|
                                f.ty::<PoolRoles<T::AccountId>>().name("roles").type_name("PoolRoles<T::AccountId>").docs(&["See [`PoolRoles`]."])).field(|f|
                            f.ty::<PoolState>().name("state").type_name("PoolState").docs(&["The current state of the pool."])))
            }
        }
        ;
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::fmt::Debug for BondedPoolInner<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                fmt.debug_struct("BondedPoolInner").field("commission",
                                        &self.commission).field("member_counter",
                                    &self.member_counter).field("points",
                                &self.points).field("roles",
                            &self.roles).field("state", &self.state).finish()
            }
        }
    };
#[automatically_derived]
impl<T: Config> ::core::marker::StructuralPartialEq for BondedPoolInner<T> { }
#[automatically_derived]
impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for
    BondedPoolInner<T> where T::AccountId: ::core::cmp::PartialEq {
    #[inline]
    fn eq(&self, other: &BondedPoolInner<T>) -> bool {
        self.commission == other.commission &&
                        self.member_counter == other.member_counter &&
                    self.points == other.points && self.roles == other.roles &&
            self.state == other.state
    }
}
#[automatically_derived]
impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for
    BondedPoolInner<T> where T::AccountId: ::core::clone::Clone {
    #[inline]
    fn clone(&self) -> BondedPoolInner<T> {
        BondedPoolInner {
            commission: ::core::clone::Clone::clone(&self.commission),
            member_counter: ::core::clone::Clone::clone(&self.member_counter),
            points: ::core::clone::Clone::clone(&self.points),
            roles: ::core::clone::Clone::clone(&self.roles),
            state: ::core::clone::Clone::clone(&self.state),
        }
    }
}
/// A wrapper for bonded pools, with utility functions.
///
/// The main purpose of this is to wrap a [`BondedPoolInner`], with the account
/// + id of the pool, for easier access.
pub struct BondedPool<T: Config> {
    /// The identifier of the pool.
    id: PoolId,
    /// The inner fields.
    inner: BondedPoolInner<T>,
}
#[automatically_derived]
impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for BondedPool<T>
    {
    #[inline]
    fn clone(&self) -> BondedPool<T> {
        BondedPool {
            id: ::core::clone::Clone::clone(&self.id),
            inner: ::core::clone::Clone::clone(&self.inner),
        }
    }
}
#[automatically_derived]
impl<T: Config> ::core::marker::StructuralPartialEq for BondedPool<T> { }
#[automatically_derived]
impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for
    BondedPool<T> {
    #[inline]
    fn eq(&self, other: &BondedPool<T>) -> bool {
        self.id == other.id && self.inner == other.inner
    }
}
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::fmt::Debug for BondedPool<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                fmt.debug_struct("BondedPool").field("id",
                            &self.id).field("inner", &self.inner).finish()
            }
        }
    };
impl<T: Config> sp_std::ops::Deref for BondedPool<T> {
    type Target = BondedPoolInner<T>;
    fn deref(&self) -> &Self::Target { &self.inner }
}
impl<T: Config> sp_std::ops::DerefMut for BondedPool<T> {
    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.inner }
}
impl<T: Config> BondedPool<T> {
    /// Create a new bonded pool with the given roles and identifier.
    fn new(id: PoolId, roles: PoolRoles<T::AccountId>) -> Self {
        Self {
            id,
            inner: BondedPoolInner {
                commission: Commission::default(),
                member_counter: Zero::zero(),
                points: Zero::zero(),
                roles,
                state: PoolState::Open,
            },
        }
    }
    /// Get [`Self`] from storage. Returns `None` if no entry for `pool_account` exists.
    pub fn get(id: PoolId) -> Option<Self> {
        BondedPools::<T>::try_get(id).ok().map(|inner| Self { id, inner })
    }
    /// Get the bonded account id of this pool.
    fn bonded_account(&self) -> T::AccountId {
        Pallet::<T>::create_bonded_account(self.id)
    }
    /// Get the reward account id of this pool.
    fn reward_account(&self) -> T::AccountId {
        Pallet::<T>::create_reward_account(self.id)
    }
    /// Consume self and put into storage.
    fn put(self) { BondedPools::<T>::insert(self.id, self.inner); }
    /// Consume self and remove from storage.
    fn remove(self) { BondedPools::<T>::remove(self.id); }
    /// Convert the given amount of balance to points given the current pool state.
    ///
    /// This is often used for bonding and issuing new funds into the pool.
    fn balance_to_point(&self, new_funds: BalanceOf<T>) -> BalanceOf<T> {
        let bonded_balance =
            T::Staking::active_stake(&self.bonded_account()).unwrap_or(Zero::zero());
        Pallet::<T>::balance_to_point(bonded_balance, self.points, new_funds)
    }
    /// Convert the given number of points to balance given the current pool state.
    ///
    /// This is often used for unbonding.
    fn points_to_balance(&self, points: BalanceOf<T>) -> BalanceOf<T> {
        let bonded_balance =
            T::Staking::active_stake(&self.bonded_account()).unwrap_or(Zero::zero());
        Pallet::<T>::point_to_balance(bonded_balance, self.points, points)
    }
    /// Issue points to [`Self`] for `new_funds`.
    fn issue(&mut self, new_funds: BalanceOf<T>) -> BalanceOf<T> {
        let points_to_issue = self.balance_to_point(new_funds);
        self.points = self.points.saturating_add(points_to_issue);
        points_to_issue
    }
    /// Dissolve some points from the pool i.e. unbond the given amount of points from this pool.
    /// This is the opposite of issuing some funds into the pool.
    ///
    /// Mutates self in place, but does not write anything to storage.
    ///
    /// Returns the equivalent balance amount that actually needs to get unbonded.
    fn dissolve(&mut self, points: BalanceOf<T>) -> BalanceOf<T> {
        let balance = self.points_to_balance(points);
        self.points = self.points.saturating_sub(points);
        balance
    }
    /// Increment the member counter. Ensures that the pool and system member limits are
    /// respected.
    fn try_inc_members(&mut self) -> Result<(), DispatchError> {
        {
            if !MaxPoolMembersPerPool::<T>::get().map_or(true,
                            |max_per_pool| self.member_counter < max_per_pool) {
                    { return Err(Error::<T>::MaxPoolMembers.into()) };
                }
        };
        {
            if !MaxPoolMembers::<T>::get().map_or(true,
                            |max| PoolMembers::<T>::count() < max) {
                    { return Err(Error::<T>::MaxPoolMembers.into()) };
                }
        };
        self.member_counter =
            self.member_counter.checked_add(1).ok_or(Error::<T>::OverflowRisk)?;
        Ok(())
    }
    /// Decrement the member counter.
    fn dec_members(mut self) -> Self {
        self.member_counter = self.member_counter.defensive_saturating_sub(1);
        self
    }
    /// The pools balance that is transferable provided it is expendable by staking pallet.
    fn transferable_balance(&self) -> BalanceOf<T> {
        let account = self.bonded_account();
        T::Currency::balance(&account).saturating_sub(T::Staking::active_stake(&account).unwrap_or_default())
    }
    fn is_root(&self, who: &T::AccountId) -> bool {
        self.roles.root.as_ref().map_or(false, |root| root == who)
    }
    fn is_bouncer(&self, who: &T::AccountId) -> bool {
        self.roles.bouncer.as_ref().map_or(false, |bouncer| bouncer == who)
    }
    fn can_update_roles(&self, who: &T::AccountId) -> bool {
        self.is_root(who)
    }
    fn can_nominate(&self, who: &T::AccountId) -> bool {
        self.is_root(who) ||
            self.roles.nominator.as_ref().map_or(false,
                |nominator| nominator == who)
    }
    fn can_kick(&self, who: &T::AccountId) -> bool {
        self.state == PoolState::Blocked &&
            (self.is_root(who) || self.is_bouncer(who))
    }
    fn can_toggle_state(&self, who: &T::AccountId) -> bool {
        (self.is_root(who) || self.is_bouncer(who)) && !self.is_destroying()
    }
    fn can_set_metadata(&self, who: &T::AccountId) -> bool {
        self.is_root(who) || self.is_bouncer(who)
    }
    fn can_manage_commission(&self, who: &T::AccountId) -> bool {
        self.is_root(who)
    }
    fn can_claim_commission(&self, who: &T::AccountId) -> bool {
        if let Some(permission) = self.commission.claim_permission.as_ref() {
                match permission {
                    CommissionClaimPermission::Permissionless => true,
                    CommissionClaimPermission::Account(account) =>
                        account == who || self.is_root(who),
                }
            } else { self.is_root(who) }
    }
    fn is_destroying(&self) -> bool {
        match self.state { PoolState::Destroying => true, _ => false, }
    }
    fn is_destroying_and_only_depositor(&self,
        alleged_depositor_points: BalanceOf<T>) -> bool {
        self.is_destroying() && self.points == alleged_depositor_points &&
            self.member_counter == 1
    }
    /// Whether or not the pool is ok to be in `PoolSate::Open`. If this returns an `Err`, then the
    /// pool is unrecoverable and should be in the destroying state.
    fn ok_to_be_open(&self) -> Result<(), DispatchError> {
        {
            if !!self.is_destroying() {
                    { return Err(Error::<T>::CanNotChangeState.into()) };
                }
        };
        let bonded_balance =
            T::Staking::active_stake(&self.bonded_account()).unwrap_or(Zero::zero());
        {
            if !!bonded_balance.is_zero() {
                    { return Err(Error::<T>::OverflowRisk.into()) };
                }
        };
        let points_to_balance_ratio_floor = self.points.div(bonded_balance);
        let max_points_to_balance = T::MaxPointsToBalance::get();
        {
            if !(points_to_balance_ratio_floor < max_points_to_balance.into())
                    {
                    { return Err(Error::<T>::OverflowRisk.into()) };
                }
        };
        Ok(())
    }
    /// Check that the pool can accept a member with `new_funds`.
    fn ok_to_join(&self) -> Result<(), DispatchError> {
        {
            if !(self.state == PoolState::Open) {
                    { return Err(Error::<T>::NotOpen.into()) };
                }
        };
        self.ok_to_be_open()?;
        Ok(())
    }
    fn ok_to_unbond_with(&self, caller: &T::AccountId,
        target_account: &T::AccountId, target_member: &PoolMember<T>,
        unbonding_points: BalanceOf<T>) -> Result<(), DispatchError> {
        let is_permissioned = caller == target_account;
        let is_depositor = *target_account == self.roles.depositor;
        let is_full_unbond =
            unbonding_points == target_member.active_points();
        let balance_after_unbond =
            {
                let new_depositor_points =
                    target_member.active_points().saturating_sub(unbonding_points);
                let mut target_member_after_unbond = (*target_member).clone();
                target_member_after_unbond.points = new_depositor_points;
                target_member_after_unbond.active_balance()
            };
        {
            if !(is_permissioned || is_full_unbond) {
                    {
                        return Err(Error::<T>::PartialUnbondNotAllowedPermissionlessly.into())
                    };
                }
        };
        {
            if !(is_full_unbond ||
                            balance_after_unbond >=
                                if is_depositor {
                                        Pallet::<T>::depositor_min_bond()
                                    } else { MinJoinBond::<T>::get() }) {
                    { return Err(Error::<T>::MinimumBondNotMet.into()) };
                }
        };
        match (is_permissioned, is_depositor) {
            (true, false) => (),
            (true, true) => {
                if self.is_destroying_and_only_depositor(target_member.active_points())
                        {} else {
                       {
                           if !!is_full_unbond {
                                   { return Err(Error::<T>::MinimumBondNotMet.into()) };
                               }
                       };
                   }
            }
            (false, false) => {
                if true {
                        if !is_full_unbond {
                                ::core::panicking::panic("assertion failed: is_full_unbond")
                            };
                    };
                {
                    if !(self.can_kick(caller) || self.is_destroying()) {
                            { return Err(Error::<T>::NotKickerOrDestroying.into()) };
                        }
                }
            }
            (false, true) => {
                return Err(Error::<T>::DoesNotHavePermission.into())
            }
        };
        Ok(())
    }
    /// # Returns
    ///
    /// * Ok(()) if [`Call::withdraw_unbonded`] can be called, `Err(DispatchError)` otherwise.
    fn ok_to_withdraw_unbonded_with(&self, caller: &T::AccountId,
        target_account: &T::AccountId) -> Result<(), DispatchError> {
        let is_permissioned = caller == target_account;
        {
            if !(is_permissioned || self.can_kick(caller) ||
                            self.is_destroying()) {
                    { return Err(Error::<T>::NotKickerOrDestroying.into()) };
                }
        };
        Ok(())
    }
    /// Bond exactly `amount` from `who`'s funds into this pool. Increases the [`TotalValueLocked`]
    /// by `amount`.
    ///
    /// If the bond is [`BondType::Create`], [`Staking::bond`] is called, and `who` is allowed to be
    /// killed. Otherwise, [`Staking::bond_extra`] is called and `who` cannot be killed.
    ///
    /// Returns `Ok(points_issues)`, `Err` otherwise.
    fn try_bond_funds(&mut self, who: &T::AccountId, amount: BalanceOf<T>,
        ty: BondType) -> Result<BalanceOf<T>, DispatchError> {
        let bonded_account = self.bonded_account();
        T::Currency::transfer(who, &bonded_account, amount,
                match ty {
                    BondType::Create => Preservation::Expendable,
                    BondType::Later => Preservation::Preserve,
                })?;
        let points_issued = self.issue(amount);
        match ty {
            BondType::Create =>
                T::Staking::bond(&bonded_account, amount,
                        &self.reward_account())?,
            BondType::Later =>
                T::Staking::bond_extra(&bonded_account, amount)?,
        }
        TotalValueLocked::<T>::mutate(|tvl|
                { tvl.saturating_accrue(amount); });
        Ok(points_issued)
    }
    fn set_state(&mut self, state: PoolState) {
        if self.state != state {
                self.state = state;
                Pallet::<T>::deposit_event(Event::<T>::StateChanged {
                        pool_id: self.id,
                        new_state: state,
                    });
            };
    }
    /// Withdraw all the funds that are already unlocked from staking for the
    /// [`BondedPool::bonded_account`].
    ///
    /// Also reduces the [`TotalValueLocked`] by the difference of the
    /// [`T::Staking::total_stake`] of the [`BondedPool::bonded_account`] that might occur by
    /// [`T::Staking::withdraw_unbonded`].
    ///
    /// Returns the result of [`T::Staking::withdraw_unbonded`]
    fn withdraw_from_staking(&self, num_slashing_spans: u32)
        -> Result<bool, DispatchError> {
        let bonded_account = self.bonded_account();
        let prev_total =
            T::Staking::total_stake(&bonded_account.clone()).unwrap_or_default();
        let outcome =
            T::Staking::withdraw_unbonded(bonded_account.clone(),
                num_slashing_spans);
        let diff =
            prev_total.defensive_saturating_sub(T::Staking::total_stake(&bonded_account).unwrap_or_default());
        TotalValueLocked::<T>::mutate(|tvl| { tvl.saturating_reduce(diff); });
        outcome
    }
}
/// A reward pool.
///
/// A reward pool is not so much a pool anymore, since it does not contain any shares or points.
/// Rather, simply to fit nicely next to bonded pool and unbonding pools in terms of terminology. In
/// reality, a reward pool is just a container for a few pool-dependent data related to the rewards.
#[codec(mel_bound(T : Config))]
#[scale_info(skip_type_params(T))]
pub struct RewardPool<T: Config> {
    /// The last recorded value of the reward counter.
    ///
    /// This is updated ONLY when the points in the bonded pool change, which means `join`,
    /// `bond_extra` and `unbond`, all of which is done through `update_recorded`.
    last_recorded_reward_counter: T::RewardCounter,
    /// The last recorded total payouts of the reward pool.
    ///
    /// Payouts is essentially income of the pool.
    ///
    /// Update criteria is same as that of `last_recorded_reward_counter`.
    last_recorded_total_payouts: BalanceOf<T>,
    /// Total amount that this pool has paid out so far to the members.
    total_rewards_claimed: BalanceOf<T>,
    /// The amount of commission pending to be claimed.
    total_commission_pending: BalanceOf<T>,
    /// The amount of commission that has been claimed.
    total_commission_claimed: BalanceOf<T>,
}
#[automatically_derived]
impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for RewardPool<T>
    where T::RewardCounter: ::core::clone::Clone {
    #[inline]
    fn clone(&self) -> RewardPool<T> {
        RewardPool {
            last_recorded_reward_counter: ::core::clone::Clone::clone(&self.last_recorded_reward_counter),
            last_recorded_total_payouts: ::core::clone::Clone::clone(&self.last_recorded_total_payouts),
            total_rewards_claimed: ::core::clone::Clone::clone(&self.total_rewards_claimed),
            total_commission_pending: ::core::clone::Clone::clone(&self.total_commission_pending),
            total_commission_claimed: ::core::clone::Clone::clone(&self.total_commission_claimed),
        }
    }
}
#[automatically_derived]
impl<T: Config> ::core::marker::StructuralPartialEq for RewardPool<T> { }
#[automatically_derived]
impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for
    RewardPool<T> where T::RewardCounter: ::core::cmp::PartialEq {
    #[inline]
    fn eq(&self, other: &RewardPool<T>) -> bool {
        self.last_recorded_reward_counter ==
                            other.last_recorded_reward_counter &&
                        self.last_recorded_total_payouts ==
                            other.last_recorded_total_payouts &&
                    self.total_rewards_claimed == other.total_rewards_claimed &&
                self.total_commission_pending ==
                    other.total_commission_pending &&
            self.total_commission_claimed == other.total_commission_claimed
    }
}
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::default::Default for RewardPool<T> {
            fn default() -> Self {
                Self {
                    last_recorded_reward_counter: ::core::default::Default::default(),
                    last_recorded_total_payouts: ::core::default::Default::default(),
                    total_rewards_claimed: ::core::default::Default::default(),
                    total_commission_pending: ::core::default::Default::default(),
                    total_commission_claimed: ::core::default::Default::default(),
                }
            }
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for RewardPool<T> where
            T::RewardCounter: ::codec::Encode,
            T::RewardCounter: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode {
            fn size_hint(&self) -> usize {
                0_usize.saturating_add(::codec::Encode::size_hint(&self.last_recorded_reward_counter)).saturating_add(::codec::Encode::size_hint(&self.last_recorded_total_payouts)).saturating_add(::codec::Encode::size_hint(&self.total_rewards_claimed)).saturating_add(::codec::Encode::size_hint(&self.total_commission_pending)).saturating_add(::codec::Encode::size_hint(&self.total_commission_claimed))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                ::codec::Encode::encode_to(&self.last_recorded_reward_counter,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.last_recorded_total_payouts,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.total_rewards_claimed,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.total_commission_pending,
                    __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.total_commission_claimed,
                    __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for RewardPool<T> where
            T::RewardCounter: ::codec::Encode,
            T::RewardCounter: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for RewardPool<T> where
            T::RewardCounter: ::codec::Decode,
            T::RewardCounter: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(RewardPool::<T> {
                        last_recorded_reward_counter: {
                            let __codec_res_edqy =
                                <T::RewardCounter as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `RewardPool::last_recorded_reward_counter`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        last_recorded_total_payouts: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `RewardPool::last_recorded_total_payouts`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        total_rewards_claimed: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `RewardPool::total_rewards_claimed`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        total_commission_pending: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `RewardPool::total_commission_pending`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        total_commission_claimed: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `RewardPool::total_commission_claimed`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                    })
            }
        }
    };
const _: () =
    {
        impl<T: Config> ::codec::MaxEncodedLen for RewardPool<T> where
            T: Config {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.saturating_add(<T::RewardCounter>::max_encoded_len()).saturating_add(<BalanceOf<T>>::max_encoded_len()).saturating_add(<BalanceOf<T>>::max_encoded_len()).saturating_add(<BalanceOf<T>>::max_encoded_len()).saturating_add(<BalanceOf<T>>::max_encoded_len())
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<T: Config> ::scale_info::TypeInfo for RewardPool<T> where
            T::RewardCounter: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::TypeInfo + 'static, T: Config +
            'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("RewardPool",
                                    "pallet_nomination_pools",
                                    &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                ::core::option::Option::None)]))).docs(&["A reward pool.",
                                    "",
                                    "A reward pool is not so much a pool anymore, since it does not contain any shares or points.",
                                    "Rather, simply to fit nicely next to bonded pool and unbonding pools in terms of terminology. In",
                                    "reality, a reward pool is just a container for a few pool-dependent data related to the rewards."]).composite(::scale_info::build::Fields::named().field(|f|
                                            f.ty::<T::RewardCounter>().name("last_recorded_reward_counter").type_name("T::RewardCounter").docs(&["The last recorded value of the reward counter.",
                                                            "",
                                                            "This is updated ONLY when the points in the bonded pool change, which means `join`,",
                                                            "`bond_extra` and `unbond`, all of which is done through `update_recorded`."])).field(|f|
                                        f.ty::<BalanceOf<T>>().name("last_recorded_total_payouts").type_name("BalanceOf<T>").docs(&["The last recorded total payouts of the reward pool.",
                                                        "", "Payouts is essentially income of the pool.", "",
                                                        "Update criteria is same as that of `last_recorded_reward_counter`."])).field(|f|
                                    f.ty::<BalanceOf<T>>().name("total_rewards_claimed").type_name("BalanceOf<T>").docs(&["Total amount that this pool has paid out so far to the members."])).field(|f|
                                f.ty::<BalanceOf<T>>().name("total_commission_pending").type_name("BalanceOf<T>").docs(&["The amount of commission pending to be claimed."])).field(|f|
                            f.ty::<BalanceOf<T>>().name("total_commission_claimed").type_name("BalanceOf<T>").docs(&["The amount of commission that has been claimed."])))
            }
        }
        ;
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::fmt::Debug for RewardPool<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                fmt.debug_struct("RewardPool").field("last_recorded_reward_counter",
                                        &self.last_recorded_reward_counter).field("last_recorded_total_payouts",
                                    &self.last_recorded_total_payouts).field("total_rewards_claimed",
                                &self.total_rewards_claimed).field("total_commission_pending",
                            &self.total_commission_pending).field("total_commission_claimed",
                        &self.total_commission_claimed).finish()
            }
        }
    };
impl<T: Config> RewardPool<T> {
    /// Getter for [`RewardPool::last_recorded_reward_counter`].
    pub(crate) fn last_recorded_reward_counter(&self) -> T::RewardCounter {
        self.last_recorded_reward_counter
    }
    /// Register some rewards that are claimed from the pool by the members.
    fn register_claimed_reward(&mut self, reward: BalanceOf<T>) {
        self.total_rewards_claimed =
            self.total_rewards_claimed.saturating_add(reward);
    }
    /// Update the recorded values of the reward pool.
    ///
    /// This function MUST be called whenever the points in the bonded pool change, AND whenever the
    /// the pools commission is updated. The reason for the former is that a change in pool points
    /// will alter the share of the reward balance among pool members, and the reason for the latter
    /// is that a change in commission will alter the share of the reward balance among the pool.
    fn update_records(&mut self, id: PoolId, bonded_points: BalanceOf<T>,
        commission: Perbill) -> Result<(), Error<T>> {
        let balance = Self::current_balance(id);
        let (current_reward_counter, new_pending_commission) =
            self.current_reward_counter(id, bonded_points, commission)?;
        self.last_recorded_reward_counter = current_reward_counter;
        self.total_commission_pending =
            self.total_commission_pending.saturating_add(new_pending_commission);
        let last_recorded_total_payouts =
            balance.checked_add(&self.total_rewards_claimed.saturating_add(self.total_commission_claimed)).ok_or(Error::<T>::OverflowRisk)?;
        self.last_recorded_total_payouts =
            self.last_recorded_total_payouts.max(last_recorded_total_payouts);
        Ok(())
    }
    /// Get the current reward counter, based on the given `bonded_points` being the state of the
    /// bonded pool at this time.
    fn current_reward_counter(&self, id: PoolId, bonded_points: BalanceOf<T>,
        commission: Perbill)
        -> Result<(T::RewardCounter, BalanceOf<T>), Error<T>> {
        let balance = Self::current_balance(id);
        let current_payout_balance =
            balance.saturating_add(self.total_rewards_claimed).saturating_add(self.total_commission_claimed).saturating_sub(self.last_recorded_total_payouts);
        let new_pending_commission = commission * current_payout_balance;
        let new_pending_rewards =
            current_payout_balance.saturating_sub(new_pending_commission);
        let current_reward_counter =
            T::RewardCounter::checked_from_rational(new_pending_rewards,
                            bonded_points).and_then(|ref r|
                            self.last_recorded_reward_counter.checked_add(r)).ok_or(Error::<T>::OverflowRisk)?;
        Ok((current_reward_counter, new_pending_commission))
    }
    /// Current free balance of the reward pool.
    ///
    /// This is sum of all the rewards that are claimable by pool members.
    fn current_balance(id: PoolId) -> BalanceOf<T> {
        T::Currency::reducible_balance(&Pallet::<T>::create_reward_account(id),
            Preservation::Expendable, Fortitude::Polite)
    }
}
/// An unbonding pool. This is always mapped with an era.
#[codec(mel_bound(T : Config))]
#[scale_info(skip_type_params(T))]
pub struct UnbondPool<T: Config> {
    /// The points in this pool.
    points: BalanceOf<T>,
    /// The funds in the pool.
    balance: BalanceOf<T>,
}
#[automatically_derived]
impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for UnbondPool<T>
    {
    #[inline]
    fn clone(&self) -> UnbondPool<T> {
        UnbondPool {
            points: ::core::clone::Clone::clone(&self.points),
            balance: ::core::clone::Clone::clone(&self.balance),
        }
    }
}
#[automatically_derived]
impl<T: Config> ::core::marker::StructuralPartialEq for UnbondPool<T> { }
#[automatically_derived]
impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for
    UnbondPool<T> {
    #[inline]
    fn eq(&self, other: &UnbondPool<T>) -> bool {
        self.points == other.points && self.balance == other.balance
    }
}
#[automatically_derived]
impl<T: Config> ::core::marker::StructuralEq for UnbondPool<T> { }
#[automatically_derived]
impl<T: ::core::cmp::Eq + Config> ::core::cmp::Eq for UnbondPool<T> {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<BalanceOf<T>>;
        let _: ::core::cmp::AssertParamIsEq<BalanceOf<T>>;
    }
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for UnbondPool<T> where
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode {
            fn size_hint(&self) -> usize {
                0_usize.saturating_add(::codec::Encode::size_hint(&self.points)).saturating_add(::codec::Encode::size_hint(&self.balance))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                ::codec::Encode::encode_to(&self.points, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.balance, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for UnbondPool<T> where
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
            BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for UnbondPool<T> where
            BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
            BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(UnbondPool::<T> {
                        points: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `UnbondPool::points`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        balance: {
                            let __codec_res_edqy =
                                <BalanceOf<T> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `UnbondPool::balance`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                    })
            }
        }
    };
const _: () =
    {
        impl<T: Config> ::codec::MaxEncodedLen for UnbondPool<T> where
            T: Config {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.saturating_add(<BalanceOf<T>>::max_encoded_len()).saturating_add(<BalanceOf<T>>::max_encoded_len())
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<T: Config> ::scale_info::TypeInfo for UnbondPool<T> where
            BalanceOf<T>: ::scale_info::TypeInfo + 'static,
            BalanceOf<T>: ::scale_info::TypeInfo + 'static, T: Config +
            'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("UnbondPool",
                                    "pallet_nomination_pools",
                                    &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                ::core::option::Option::None)]))).docs(&["An unbonding pool. This is always mapped with an era."]).composite(::scale_info::build::Fields::named().field(|f|
                                f.ty::<BalanceOf<T>>().name("points").type_name("BalanceOf<T>").docs(&["The points in this pool."])).field(|f|
                            f.ty::<BalanceOf<T>>().name("balance").type_name("BalanceOf<T>").docs(&["The funds in the pool."])))
            }
        }
        ;
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::default::Default for UnbondPool<T> {
            fn default() -> Self {
                Self {
                    points: ::core::default::Default::default(),
                    balance: ::core::default::Default::default(),
                }
            }
        }
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::fmt::Debug for UnbondPool<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                fmt.debug_struct("UnbondPool").field("points",
                            &self.points).field("balance", &self.balance).finish()
            }
        }
    };
impl<T: Config> UnbondPool<T> {
    fn balance_to_point(&self, new_funds: BalanceOf<T>) -> BalanceOf<T> {
        Pallet::<T>::balance_to_point(self.balance, self.points, new_funds)
    }
    fn point_to_balance(&self, points: BalanceOf<T>) -> BalanceOf<T> {
        Pallet::<T>::point_to_balance(self.balance, self.points, points)
    }
    /// Issue the equivalent points of `new_funds` into self.
    ///
    /// Returns the actual amounts of points issued.
    fn issue(&mut self, new_funds: BalanceOf<T>) -> BalanceOf<T> {
        let new_points = self.balance_to_point(new_funds);
        self.points = self.points.saturating_add(new_points);
        self.balance = self.balance.saturating_add(new_funds);
        new_points
    }
    /// Dissolve some points from the unbonding pool, reducing the balance of the pool
    /// proportionally. This is the opposite of `issue`.
    ///
    /// Returns the actual amount of `Balance` that was removed from the pool.
    fn dissolve(&mut self, points: BalanceOf<T>) -> BalanceOf<T> {
        let balance_to_unbond = self.point_to_balance(points);
        self.points = self.points.saturating_sub(points);
        self.balance = self.balance.saturating_sub(balance_to_unbond);
        balance_to_unbond
    }
}
#[codec(mel_bound(T : Config))]
#[scale_info(skip_type_params(T))]
pub struct SubPools<T: Config> {
    /// A general, era agnostic pool of funds that have fully unbonded. The pools
    /// of `Self::with_era` will lazily be merged into into this pool if they are
    /// older then `current_era - TotalUnbondingPools`.
    no_era: UnbondPool<T>,
    /// Map of era in which a pool becomes unbonded in => unbond pools.
    with_era: BoundedBTreeMap<EraIndex, UnbondPool<T>,
    TotalUnbondingPools<T>>,
}
#[automatically_derived]
impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for SubPools<T> {
    #[inline]
    fn clone(&self) -> SubPools<T> {
        SubPools {
            no_era: ::core::clone::Clone::clone(&self.no_era),
            with_era: ::core::clone::Clone::clone(&self.with_era),
        }
    }
}
#[automatically_derived]
impl<T: Config> ::core::marker::StructuralPartialEq for SubPools<T> { }
#[automatically_derived]
impl<T: ::core::cmp::PartialEq + Config> ::core::cmp::PartialEq for
    SubPools<T> {
    #[inline]
    fn eq(&self, other: &SubPools<T>) -> bool {
        self.no_era == other.no_era && self.with_era == other.with_era
    }
}
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Encode for SubPools<T> where
            UnbondPool<T>: ::codec::Encode, UnbondPool<T>: ::codec::Encode,
            BoundedBTreeMap<EraIndex, UnbondPool<T>,
            TotalUnbondingPools<T>>: ::codec::Encode,
            BoundedBTreeMap<EraIndex, UnbondPool<T>,
            TotalUnbondingPools<T>>: ::codec::Encode {
            fn size_hint(&self) -> usize {
                0_usize.saturating_add(::codec::Encode::size_hint(&self.no_era)).saturating_add(::codec::Encode::size_hint(&self.with_era))
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output +
                ?::core::marker::Sized>(&self,
                __codec_dest_edqy: &mut __CodecOutputEdqy) {
                ::codec::Encode::encode_to(&self.no_era, __codec_dest_edqy);
                ::codec::Encode::encode_to(&self.with_era, __codec_dest_edqy);
            }
        }
        #[automatically_derived]
        impl<T: Config> ::codec::EncodeLike for SubPools<T> where
            UnbondPool<T>: ::codec::Encode, UnbondPool<T>: ::codec::Encode,
            BoundedBTreeMap<EraIndex, UnbondPool<T>,
            TotalUnbondingPools<T>>: ::codec::Encode,
            BoundedBTreeMap<EraIndex, UnbondPool<T>,
            TotalUnbondingPools<T>>: ::codec::Encode {
        }
    };
#[allow(deprecated)]
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::codec::Decode for SubPools<T> where
            UnbondPool<T>: ::codec::Decode, UnbondPool<T>: ::codec::Decode,
            BoundedBTreeMap<EraIndex, UnbondPool<T>,
            TotalUnbondingPools<T>>: ::codec::Decode,
            BoundedBTreeMap<EraIndex, UnbondPool<T>,
            TotalUnbondingPools<T>>: ::codec::Decode {
            fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                    &mut __CodecInputEdqy)
                -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(SubPools::<T> {
                        no_era: {
                            let __codec_res_edqy =
                                <UnbondPool<T> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `SubPools::no_era`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                        with_era: {
                            let __codec_res_edqy =
                                <BoundedBTreeMap<EraIndex, UnbondPool<T>,
                                        TotalUnbondingPools<T>> as
                                        ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) =>
                                    return ::core::result::Result::Err(e.chain("Could not decode `SubPools::with_era`")),
                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                    __codec_res_edqy,
                            }
                        },
                    })
            }
        }
    };
const _: () =
    {
        impl<T: Config> ::codec::MaxEncodedLen for SubPools<T> where T: Config
            {
            fn max_encoded_len() -> ::core::primitive::usize {
                0_usize.saturating_add(<UnbondPool<T>>::max_encoded_len()).saturating_add(<BoundedBTreeMap<EraIndex,
                            UnbondPool<T>, TotalUnbondingPools<T>>>::max_encoded_len())
            }
        }
    };
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () =
    {
        impl<T: Config> ::scale_info::TypeInfo for SubPools<T> where
            UnbondPool<T>: ::scale_info::TypeInfo + 'static,
            BoundedBTreeMap<EraIndex, UnbondPool<T>,
            TotalUnbondingPools<T>>: ::scale_info::TypeInfo + 'static,
            T: Config + 'static {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("SubPools",
                                "pallet_nomination_pools",
                                &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                            ::core::option::Option::None)]))).composite(::scale_info::build::Fields::named().field(|f|
                                f.ty::<UnbondPool<T>>().name("no_era").type_name("UnbondPool<T>").docs(&["A general, era agnostic pool of funds that have fully unbonded. The pools",
                                                "of `Self::with_era` will lazily be merged into into this pool if they are",
                                                "older then `current_era - TotalUnbondingPools`."])).field(|f|
                            f.ty::<BoundedBTreeMap<EraIndex, UnbondPool<T>,
                                            TotalUnbondingPools<T>>>().name("with_era").type_name("BoundedBTreeMap<EraIndex, UnbondPool<T>, TotalUnbondingPools<T>>").docs(&["Map of era in which a pool becomes unbonded in => unbond pools."])))
            }
        }
        ;
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::default::Default for SubPools<T> {
            fn default() -> Self {
                Self {
                    no_era: ::core::default::Default::default(),
                    with_era: ::core::default::Default::default(),
                }
            }
        }
    };
const _: () =
    {
        #[automatically_derived]
        impl<T: Config> ::core::fmt::Debug for SubPools<T> {
            fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                -> ::core::fmt::Result {
                fmt.debug_struct("SubPools").field("no_era",
                            &self.no_era).field("with_era", &self.with_era).finish()
            }
        }
    };
impl<T: Config> SubPools<T> {
    /// Merge the oldest `with_era` unbond pools into the `no_era` unbond pool.
    ///
    /// This is often used whilst getting the sub-pool from storage, thus it consumes and returns
    /// `Self` for ergonomic purposes.
    fn maybe_merge_pools(mut self, current_era: EraIndex) -> Self {
        if let Some(newest_era_to_remove) =
                    current_era.checked_sub(T::PostUnbondingPoolsWindow::get())
                {
                self.with_era.retain(|k, v|
                        {
                            if *k > newest_era_to_remove {
                                    true
                                } else {
                                   self.no_era.points =
                                       self.no_era.points.saturating_add(v.points);
                                   self.no_era.balance =
                                       self.no_era.balance.saturating_add(v.balance);
                                   false
                               }
                        });
            }
        self
    }
    /// The sum of all unbonding balance, regardless of whether they are actually unlocked or not.
    #[cfg(any(feature = "try-runtime", feature = "fuzzing", test,
    debug_assertions))]
    fn sum_unbonding_balance(&self) -> BalanceOf<T> {
        self.no_era.balance.saturating_add(self.with_era.values().fold(BalanceOf::<T>::zero(),
                |acc, pool| acc.saturating_add(pool.balance)))
    }
}
/// The maximum amount of eras an unbonding pool can exist prior to being merged with the
/// `no_era` pool. This is guaranteed to at least be equal to the staking `UnbondingDuration`. For
/// improved UX [`Config::PostUnbondingPoolsWindow`] should be configured to a non-zero value.
pub struct TotalUnbondingPools<T: Config>(PhantomData<T>);
impl<T: Config> Get<u32> for TotalUnbondingPools<T> {
    fn get() -> u32 {
        T::Staking::bonding_duration() + T::PostUnbondingPoolsWindow::get()
    }
}
#[doc =
r"The `pallet` module in each FRAME pallet hosts the most important items needed
to construct this pallet.

The main components of this pallet are:
- [`Pallet`], which implements all of the dispatchable extrinsics of the pallet, among
other public functions.
	- The subset of the functions that are dispatchable can be identified either in the
	[`dispatchables`] module or in the [`Call`] enum.
- [`storage_types`], which contains the list of all types that are representing a
storage item. Otherwise, all storage items are listed among [*Type Definitions*](#types).
- [`Config`], which contains the configuration trait of this pallet.
- [`Event`] and [`Error`], which are listed among the [*Enums*](#enums).
		"]
pub mod pallet {
    use super::*;
    use frame_support::traits::StorageVersion;
    use frame_system::{ensure_signed, pallet_prelude::*};
    use sp_runtime::Perbill;
    #[doc = " The current storage version."]
    const STORAGE_VERSION: StorageVersion = StorageVersion::new(8);
    #[doc =
    r"
				The `Pallet` struct, the main type that implements traits and standalone
				functions within the pallet.
			"]
    pub struct Pallet<T>(frame_support::__private::sp_std::marker::PhantomData<(T)>);
    const _: () =
        {
            #[automatically_derived]
            impl<T> ::core::clone::Clone for Pallet<T> {
                fn clone(&self) -> Self {
                    Self(::core::clone::Clone::clone(&self.0))
                }
            }
        };
    const _: () =
        {
            impl<T> ::core::cmp::Eq for Pallet<T> {}
        };
    const _: () =
        {
            #[automatically_derived]
            impl<T> ::core::cmp::PartialEq for Pallet<T> {
                fn eq(&self, other: &Self) -> bool {
                    true && self.0 == other.0
                }
            }
        };
    const _: () =
        {
            #[automatically_derived]
            impl<T> ::core::fmt::Debug for Pallet<T> {
                fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    fmt.debug_tuple("Pallet").field(&self.0).finish()
                }
            }
        };
    #[doc =
    r"
Configuration trait of this pallet.

The main purpose of this trait is to act as an interface between this pallet and the runtime in
which it is embedded in. A type, function, or constant in this trait is essentially left to be
configured by the runtime that includes this pallet.

Consequently, a runtime that wants to include this pallet must implement this trait."]
    pub trait Config: frame_system::Config {
        #[doc = " The overarching event type."]
        type RuntimeEvent: From<Event<Self>> +
            IsType<<Self as frame_system::Config>::RuntimeEvent>;
        #[doc = " Weight information for extrinsics in this pallet."]
        type WeightInfo: weights::WeightInfo;
        #[doc = " The currency type used for nomination pool."]
        type Currency: FunMutate<Self::AccountId> +
            FunMutateFreeze<Self::AccountId, Id = Self::RuntimeFreezeReason>;
        #[doc = " The overarching freeze reason."]
        type RuntimeFreezeReason: From<FreezeReason>;
        #[doc = " The type that is used for reward counter."]
        #[doc = ""]
        #[doc =
        " The arithmetic of the reward counter might saturate based on the size of the"]
        #[doc =
        " `Currency::Balance`. If this happens, operations fails. Nonetheless, this type should be"]
        #[doc =
        " chosen such that this failure almost never happens, as if it happens, the pool basically"]
        #[doc =
        " needs to be dismantled (or all pools migrated to a larger `RewardCounter` type, which is"]
        #[doc = " a PITA to do)."]
        #[doc = ""]
        #[doc =
        " See the inline code docs of `Member::pending_rewards` and `RewardPool::update_recorded`"]
        #[doc =
        " for example analysis. A [`sp_runtime::FixedU128`] should be fine for chains with balance"]
        #[doc =
        " types similar to that of Polkadot and Kusama, in the absence of severe slashing (or"]
        #[doc =
        " prevented via a reasonable `MaxPointsToBalance`), for many many years to come."]
        type RewardCounter: FixedPointNumber + MaxEncodedLen + TypeInfo +
            Default + codec::FullCodec;
        #[doc = " The nomination pool\'s pallet id."]
        type PalletId: Get<frame_support::PalletId>;
        #[doc =
        " The maximum pool points-to-balance ratio that an `open` pool can have."]
        #[doc = ""]
        #[doc =
        " This is important in the event slashing takes place and the pool\'s points-to-balance"]
        #[doc = " ratio becomes disproportional."]
        #[doc = ""]
        #[doc =
        " Moreover, this relates to the `RewardCounter` type as well, as the arithmetic operations"]
        #[doc =
        " are a function of number of points, and by setting this value to e.g. 10, you ensure"]
        #[doc =
        " that the total number of points in the system are at most 10 times the total_issuance of"]
        #[doc = " the chain, in the absolute worse case."]
        #[doc = ""]
        #[doc =
        " For a value of 10, the threshold would be a pool points-to-balance ratio of 10:1."]
        #[doc =
        " Such a scenario would also be the equivalent of the pool being 90% slashed."]
        type MaxPointsToBalance: Get<u8>;
        #[doc =
        " The maximum number of simultaneous unbonding chunks that can exist per member."]
        type MaxUnbonding: Get<u32>;
        #[doc =
        " Infallible method for converting `Currency::Balance` to `U256`."]
        type BalanceToU256: Convert<BalanceOf<Self>, U256>;
        #[doc =
        " Infallible method for converting `U256` to `Currency::Balance`."]
        type U256ToBalance: Convert<U256, BalanceOf<Self>>;
        #[doc = " The interface for nominating."]
        type
            Staking: StakingInterface<Balance = BalanceOf<Self>, AccountId =
            Self::AccountId>;
        #[doc =
        " The amount of eras a `SubPools::with_era` pool can exist before it gets merged into the"]
        #[doc =
        " `SubPools::no_era` pool. In other words, this is the amount of eras a member will be"]
        #[doc =
        " able to withdraw from an unbonding pool which is guaranteed to have the correct ratio of"]
        #[doc =
        " points to balance; once the `with_era` pool is merged into the `no_era` pool, the ratio"]
        #[doc =
        " can become skewed due to some slashed ratio getting merged in at some point."]
        type PostUnbondingPoolsWindow: Get<u32>;
        #[doc = " The maximum length, in bytes, that a pools metadata maybe."]
        type MaxMetadataLen: Get<u32>;
    }
    #[doc = " The sum of funds across all pools."]
    #[doc = ""]
    #[doc =
    " This might be lower but never higher than the sum of `total_balance` of all [`PoolMembers`]"]
    #[doc =
    " because calling `pool_withdraw_unbonded` might decrease the total stake of the pool\'s"]
    #[doc =
    " `bonded_account` without adjusting the pallet-internal `UnbondingPool`\'s."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc =
    "Storage type is [`StorageValue`] with value type `BalanceOf < T >`."]
    pub type TotalValueLocked<T: Config> =
        StorageValue<_GeneratedPrefixForStorageTotalValueLocked<T>,
        BalanceOf<T>, ValueQuery>;
    #[doc = " Minimum amount to bond to join a pool."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc =
    "Storage type is [`StorageValue`] with value type `BalanceOf < T >`."]
    pub type MinJoinBond<T: Config> =
        StorageValue<_GeneratedPrefixForStorageMinJoinBond<T>, BalanceOf<T>,
        ValueQuery>;
    #[doc = " Minimum bond required to create a pool."]
    #[doc = ""]
    #[doc =
    " This is the amount that the depositor must put as their initial stake in the pool, as an"]
    #[doc = " indication of \"skin in the game\"."]
    #[doc = ""]
    #[doc =
    " This is the value that will always exist in the staking ledger of the pool bonded account"]
    #[doc = " while all other accounts leave."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc =
    "Storage type is [`StorageValue`] with value type `BalanceOf < T >`."]
    pub type MinCreateBond<T: Config> =
        StorageValue<_GeneratedPrefixForStorageMinCreateBond<T>, BalanceOf<T>,
        ValueQuery>;
    #[doc =
    " Maximum number of nomination pools that can exist. If `None`, then an unbounded number of"]
    #[doc = " pools can exist."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc = "Storage type is [`StorageValue`] with value type `u32`."]
    pub type MaxPools<T: Config> =
        StorageValue<_GeneratedPrefixForStorageMaxPools<T>, u32, OptionQuery>;
    #[doc =
    " Maximum number of members that can exist in the system. If `None`, then the count"]
    #[doc = " members are not bound on a system wide basis."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc = "Storage type is [`StorageValue`] with value type `u32`."]
    pub type MaxPoolMembers<T: Config> =
        StorageValue<_GeneratedPrefixForStorageMaxPoolMembers<T>, u32,
        OptionQuery>;
    #[doc =
    " Maximum number of members that may belong to pool. If `None`, then the count of"]
    #[doc = " members is not bound on a per pool basis."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc = "Storage type is [`StorageValue`] with value type `u32`."]
    pub type MaxPoolMembersPerPool<T: Config> =
        StorageValue<_GeneratedPrefixForStorageMaxPoolMembersPerPool<T>, u32,
        OptionQuery>;
    #[doc =
    " The maximum commission that can be charged by a pool. Used on commission payouts to bound"]
    #[doc =
    " pool commissions that are > `GlobalMaxCommission`, necessary if a future"]
    #[doc =
    " `GlobalMaxCommission` is lower than some current pool commissions."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc = "Storage type is [`StorageValue`] with value type `Perbill`."]
    pub type GlobalMaxCommission<T: Config> =
        StorageValue<_GeneratedPrefixForStorageGlobalMaxCommission<T>,
        Perbill, OptionQuery>;
    #[doc = " Active members."]
    #[doc = ""]
    #[doc = " TWOX-NOTE: SAFE since `AccountId` is a secure hash."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc =
    "Storage type is [`CountedStorageMap`] with key type T :: AccountId and value type PoolMember < T >."]
    pub type PoolMembers<T: Config> =
        CountedStorageMap<_GeneratedPrefixForStoragePoolMembers<T>,
        Twox64Concat, T::AccountId, PoolMember<T>>;
    #[doc = " Storage for bonded pools."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc =
    "Storage type is [`CountedStorageMap`] with key type PoolId and value type BondedPoolInner < T >."]
    pub type BondedPools<T: Config> =
        CountedStorageMap<_GeneratedPrefixForStorageBondedPools<T>,
        Twox64Concat, PoolId, BondedPoolInner<T>>;
    #[doc =
    " Reward pools. This is where there rewards for each pool accumulate. When a members payout is"]
    #[doc =
    " claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc =
    "Storage type is [`CountedStorageMap`] with key type PoolId and value type RewardPool < T >."]
    pub type RewardPools<T: Config> =
        CountedStorageMap<_GeneratedPrefixForStorageRewardPools<T>,
        Twox64Concat, PoolId, RewardPool<T>>;
    #[doc =
    " Groups of unbonding pools. Each group of unbonding pools belongs to a"]
    #[doc =
    " bonded pool, hence the name sub-pools. Keyed by the bonded pools account."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc =
    "Storage type is [`CountedStorageMap`] with key type PoolId and value type SubPools < T >."]
    pub type SubPoolsStorage<T: Config> =
        CountedStorageMap<_GeneratedPrefixForStorageSubPoolsStorage<T>,
        Twox64Concat, PoolId, SubPools<T>>;
    #[doc = " Metadata for the pool."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc =
    "Storage type is [`CountedStorageMap`] with key type PoolId and value type BoundedVec < u8, T :: MaxMetadataLen >."]
    pub type Metadata<T: Config> =
        CountedStorageMap<_GeneratedPrefixForStorageMetadata<T>, Twox64Concat,
        PoolId, BoundedVec<u8, T::MaxMetadataLen>, ValueQuery>;
    #[doc = " Ever increasing number of all pools created so far."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc = "Storage type is [`StorageValue`] with value type `u32`."]
    pub type LastPoolId<T: Config> =
        StorageValue<_GeneratedPrefixForStorageLastPoolId<T>, u32,
        ValueQuery>;
    #[doc = " A reverse lookup from the pool\'s account id to its id."]
    #[doc = ""]
    #[doc =
    " This is only used for slashing. In all other instances, the pool id is used, and the"]
    #[doc = " accounts are deterministically derived from it."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc =
    "Storage type is [`CountedStorageMap`] with key type T :: AccountId and value type PoolId."]
    pub type ReversePoolIdLookup<T: Config> =
        CountedStorageMap<_GeneratedPrefixForStorageReversePoolIdLookup<T>,
        Twox64Concat, T::AccountId, PoolId, OptionQuery>;
    #[doc =
    " Map from a pool member account to their opted claim permission."]
    #[allow(type_alias_bounds)]
    #[doc = ""]
    #[doc =
    "Storage type is [`StorageMap`] with key type `T :: AccountId` and value type `ClaimPermission`."]
    pub type ClaimPermissions<T: Config> =
        StorageMap<_GeneratedPrefixForStorageClaimPermissions<T>,
        Twox64Concat, T::AccountId, ClaimPermission, ValueQuery>;
    #[doc =
    r"
					Can be used to configure the
					[genesis state](https://docs.substrate.io/build/genesis-configuration/)
					of this pallet.
					"]
    #[serde(rename_all = "camelCase")]
    #[serde(deny_unknown_fields)]
    #[serde(bound(serialize = ""))]
    #[serde(bound(deserialize = ""))]
    #[serde(crate = "frame_support::__private::serde")]
    pub struct GenesisConfig<T: Config> {
        pub min_join_bond: BalanceOf<T>,
        pub min_create_bond: BalanceOf<T>,
        pub max_pools: Option<u32>,
        pub max_members_per_pool: Option<u32>,
        pub max_members: Option<u32>,
        pub global_max_commission: Option<Perbill>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            use frame_support::__private::serde as _serde;
            #[automatically_derived]
            impl<T: Config> frame_support::__private::serde::Serialize for
                GenesisConfig<T> {
                fn serialize<__S>(&self, __serializer: __S)
                    ->
                        frame_support::__private::serde::__private::Result<__S::Ok,
                        __S::Error> where
                    __S: frame_support::__private::serde::Serializer {
                    let mut __serde_state =
                        _serde::Serializer::serialize_struct(__serializer,
                                "GenesisConfig", false as usize + 1 + 1 + 1 + 1 + 1 + 1)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "minJoinBond", &self.min_join_bond)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "minCreateBond", &self.min_create_bond)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "maxPools", &self.max_pools)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "maxMembersPerPool", &self.max_members_per_pool)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "maxMembers", &self.max_members)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "globalMaxCommission", &self.global_max_commission)?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            use frame_support::__private::serde as _serde;
            #[automatically_derived]
            impl<'de, T: Config>
                frame_support::__private::serde::Deserialize<'de> for
                GenesisConfig<T> {
                fn deserialize<__D>(__deserializer: __D)
                    ->
                        frame_support::__private::serde::__private::Result<Self,
                        __D::Error> where
                    __D: frame_support::__private::serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ =>
                                    _serde::__private::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                            &"field index 0 <= i < 6")),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                "minJoinBond" => _serde::__private::Ok(__Field::__field0),
                                "minCreateBond" => _serde::__private::Ok(__Field::__field1),
                                "maxPools" => _serde::__private::Ok(__Field::__field2),
                                "maxMembersPerPool" =>
                                    _serde::__private::Ok(__Field::__field3),
                                "maxMembers" => _serde::__private::Ok(__Field::__field4),
                                "globalMaxCommission" =>
                                    _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    _serde::__private::Err(_serde::de::Error::unknown_field(__value,
                                            FIELDS))
                                }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                b"minJoinBond" => _serde::__private::Ok(__Field::__field0),
                                b"minCreateBond" =>
                                    _serde::__private::Ok(__Field::__field1),
                                b"maxPools" => _serde::__private::Ok(__Field::__field2),
                                b"maxMembersPerPool" =>
                                    _serde::__private::Ok(__Field::__field3),
                                b"maxMembers" => _serde::__private::Ok(__Field::__field4),
                                b"globalMaxCommission" =>
                                    _serde::__private::Ok(__Field::__field5),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_field(__value,
                                            FIELDS))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                            -> _serde::__private::Result<Self, __D::Error> where
                            __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                __FieldVisitor)
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de, T: Config> {
                        marker: _serde::__private::PhantomData<GenesisConfig<T>>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de, T: Config> _serde::de::Visitor<'de> for
                        __Visitor<'de, T> {
                        type Value = GenesisConfig<T>;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "struct GenesisConfig")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<BalanceOf<T>>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                    &"struct GenesisConfig with 6 elements")),
                                };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<BalanceOf<T>>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                    &"struct GenesisConfig with 6 elements")),
                                };
                            let __field2 =
                                match _serde::de::SeqAccess::next_element::<Option<u32>>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(2usize,
                                                    &"struct GenesisConfig with 6 elements")),
                                };
                            let __field3 =
                                match _serde::de::SeqAccess::next_element::<Option<u32>>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(3usize,
                                                    &"struct GenesisConfig with 6 elements")),
                                };
                            let __field4 =
                                match _serde::de::SeqAccess::next_element::<Option<u32>>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(4usize,
                                                    &"struct GenesisConfig with 6 elements")),
                                };
                            let __field5 =
                                match _serde::de::SeqAccess::next_element::<Option<Perbill>>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(5usize,
                                                    &"struct GenesisConfig with 6 elements")),
                                };
                            _serde::__private::Ok(GenesisConfig {
                                    min_join_bond: __field0,
                                    min_create_bond: __field1,
                                    max_pools: __field2,
                                    max_members_per_pool: __field3,
                                    max_members: __field4,
                                    global_max_commission: __field5,
                                })
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::MapAccess<'de> {
                            let mut __field0: _serde::__private::Option<BalanceOf<T>> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<BalanceOf<T>> =
                                _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Option<u32>> =
                                _serde::__private::None;
                            let mut __field5:
                                    _serde::__private::Option<Option<Perbill>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                    _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("minJoinBond"));
                                            }
                                        __field0 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<BalanceOf<T>>(&mut __map)?);
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("minCreateBond"));
                                            }
                                        __field1 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<BalanceOf<T>>(&mut __map)?);
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("maxPools"));
                                            }
                                        __field2 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<Option<u32>>(&mut __map)?);
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("maxMembersPerPool"));
                                            }
                                        __field3 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<Option<u32>>(&mut __map)?);
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("maxMembers"));
                                            }
                                        __field4 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<Option<u32>>(&mut __map)?);
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("globalMaxCommission"));
                                            }
                                        __field5 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<Option<Perbill>>(&mut __map)?);
                                    }
                                }
                            }
                            let __field0 =
                                match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("minJoinBond")?,
                                };
                            let __field1 =
                                match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("minCreateBond")?,
                                };
                            let __field2 =
                                match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("maxPools")?,
                                };
                            let __field3 =
                                match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("maxMembersPerPool")?,
                                };
                            let __field4 =
                                match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("maxMembers")?,
                                };
                            let __field5 =
                                match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("globalMaxCommission")?,
                                };
                            _serde::__private::Ok(GenesisConfig {
                                    min_join_bond: __field0,
                                    min_create_bond: __field1,
                                    max_pools: __field2,
                                    max_members_per_pool: __field3,
                                    max_members: __field4,
                                    global_max_commission: __field5,
                                })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] =
                        &["minJoinBond", "minCreateBond", "maxPools",
                                    "maxMembersPerPool", "maxMembers", "globalMaxCommission"];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                        "GenesisConfig", FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GenesisConfig<T>>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    impl<T: Config> Default for GenesisConfig<T> {
        fn default() -> Self {
            Self {
                min_join_bond: Zero::zero(),
                min_create_bond: Zero::zero(),
                max_pools: Some(16),
                max_members_per_pool: Some(32),
                max_members: Some(16 * 32),
                global_max_commission: None,
            }
        }
    }
    impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
        fn build(&self) {
            MinJoinBond::<T>::put(self.min_join_bond);
            MinCreateBond::<T>::put(self.min_create_bond);
            if let Some(max_pools) = self.max_pools {
                    MaxPools::<T>::put(max_pools);
                }
            if let Some(max_members_per_pool) = self.max_members_per_pool {
                    MaxPoolMembersPerPool::<T>::put(max_members_per_pool);
                }
            if let Some(max_members) = self.max_members {
                    MaxPoolMembers::<T>::put(max_members);
                }
            if let Some(global_max_commission) = self.global_max_commission {
                    GlobalMaxCommission::<T>::put(global_max_commission);
                }
        }
    }
    #[doc = " Events of this pallet."]
    #[scale_info(skip_type_params(T), capture_docs = "always")]
    pub enum Event<T: Config> {

        #[doc = " A pool has been created."]
        Created {
            depositor: T::AccountId,
            pool_id: PoolId,
        },

        #[doc = " A member has became bonded in a pool."]
        Bonded {
            member: T::AccountId,
            pool_id: PoolId,
            bonded: BalanceOf<T>,
            joined: bool,
        },

        #[doc = " A payout has been made to a member."]
        PaidOut {
            member: T::AccountId,
            pool_id: PoolId,
            payout: BalanceOf<T>,
        },

        #[doc = " A member has unbonded from their pool."]
        #[doc = ""]
        #[doc =
        " - `balance` is the corresponding balance of the number of points that has been"]
        #[doc =
        "   requested to be unbonded (the argument of the `unbond` transaction) from the bonded"]
        #[doc = "   pool."]
        #[doc =
        " - `points` is the number of points that are issued as a result of `balance` being"]
        #[doc = " dissolved into the corresponding unbonding pool."]
        #[doc = " - `era` is the era in which the balance will be unbonded."]
        #[doc =
        " In the absence of slashing, these values will match. In the presence of slashing, the"]
        #[doc =
        " number of points that are issued in the unbonding pool will be less than the amount"]
        #[doc = " requested to be unbonded."]
        Unbonded {
            member: T::AccountId,
            pool_id: PoolId,
            balance: BalanceOf<T>,
            points: BalanceOf<T>,
            era: EraIndex,
        },

        #[doc = " A member has withdrawn from their pool."]
        #[doc = ""]
        #[doc =
        " The given number of `points` have been dissolved in return of `balance`."]
        #[doc = ""]
        #[doc =
        " Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance"]
        #[doc = " will be 1."]
        Withdrawn {
            member: T::AccountId,
            pool_id: PoolId,
            balance: BalanceOf<T>,
            points: BalanceOf<T>,
        },

        #[doc = " A pool has been destroyed."]
        Destroyed {
            pool_id: PoolId,
        },

        #[doc = " The state of a pool has changed"]
        StateChanged {
            pool_id: PoolId,
            new_state: PoolState,
        },

        #[doc = " A member has been removed from a pool."]
        #[doc = ""]
        #[doc =
        " The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked)."]
        MemberRemoved {
            pool_id: PoolId,
            member: T::AccountId,
        },

        #[doc =
        " The roles of a pool have been updated to the given new roles. Note that the depositor"]
        #[doc = " can never change."]
        RolesUpdated {
            root: Option<T::AccountId>,
            bouncer: Option<T::AccountId>,
            nominator: Option<T::AccountId>,
        },

        #[doc =
        " The active balance of pool `pool_id` has been slashed to `balance`."]
        PoolSlashed {
            pool_id: PoolId,
            balance: BalanceOf<T>,
        },

        #[doc =
        " The unbond pool at `era` of pool `pool_id` has been slashed to `balance`."]
        UnbondingPoolSlashed {
            pool_id: PoolId,
            era: EraIndex,
            balance: BalanceOf<T>,
        },

        #[doc = " A pool\'s commission setting has been changed."]
        PoolCommissionUpdated {
            pool_id: PoolId,
            current: Option<(Perbill, T::AccountId)>,
        },

        #[doc = " A pool\'s maximum commission setting has been changed."]
        PoolMaxCommissionUpdated {
            pool_id: PoolId,
            max_commission: Perbill,
        },

        #[doc = " A pool\'s commission `change_rate` has been changed."]
        PoolCommissionChangeRateUpdated {
            pool_id: PoolId,
            change_rate: CommissionChangeRate<BlockNumberFor<T>>,
        },

        #[doc = " Pool commission claim permission has been updated."]
        PoolCommissionClaimPermissionUpdated {
            pool_id: PoolId,
            permission: Option<CommissionClaimPermission<T::AccountId>>,
        },

        #[doc = " Pool commission has been claimed."]
        PoolCommissionClaimed {
            pool_id: PoolId,
            commission: BalanceOf<T>,
        },

        #[doc = " Topped up deficit in frozen ED of the reward pool."]
        MinBalanceDeficitAdjusted {
            pool_id: PoolId,
            amount: BalanceOf<T>,
        },

        #[doc = " Claimed excess frozen ED of af the reward pool."]
        MinBalanceExcessAdjusted {
            pool_id: PoolId,
            amount: BalanceOf<T>,
        },

        #[doc(hidden)]
        #[codec(skip)]
        __Ignore(frame_support::__private::sp_std::marker::PhantomData<(T)>,
            frame_support::Never),
    }
    const _: () =
        {
            #[automatically_derived]
            impl<T: Config> ::core::clone::Clone for Event<T> {
                fn clone(&self) -> Self {
                    match self {
                        Self::Created { ref depositor, ref pool_id } =>
                            Self::Created {
                                depositor: ::core::clone::Clone::clone(depositor),
                                pool_id: ::core::clone::Clone::clone(pool_id),
                            },
                        Self::Bonded {
                            ref member, ref pool_id, ref bonded, ref joined } =>
                            Self::Bonded {
                                member: ::core::clone::Clone::clone(member),
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                bonded: ::core::clone::Clone::clone(bonded),
                                joined: ::core::clone::Clone::clone(joined),
                            },
                        Self::PaidOut { ref member, ref pool_id, ref payout } =>
                            Self::PaidOut {
                                member: ::core::clone::Clone::clone(member),
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                payout: ::core::clone::Clone::clone(payout),
                            },
                        Self::Unbonded {
                            ref member, ref pool_id, ref balance, ref points, ref era }
                            =>
                            Self::Unbonded {
                                member: ::core::clone::Clone::clone(member),
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                balance: ::core::clone::Clone::clone(balance),
                                points: ::core::clone::Clone::clone(points),
                                era: ::core::clone::Clone::clone(era),
                            },
                        Self::Withdrawn {
                            ref member, ref pool_id, ref balance, ref points } =>
                            Self::Withdrawn {
                                member: ::core::clone::Clone::clone(member),
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                balance: ::core::clone::Clone::clone(balance),
                                points: ::core::clone::Clone::clone(points),
                            },
                        Self::Destroyed { ref pool_id } =>
                            Self::Destroyed {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                            },
                        Self::StateChanged { ref pool_id, ref new_state } =>
                            Self::StateChanged {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                new_state: ::core::clone::Clone::clone(new_state),
                            },
                        Self::MemberRemoved { ref pool_id, ref member } =>
                            Self::MemberRemoved {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                member: ::core::clone::Clone::clone(member),
                            },
                        Self::RolesUpdated { ref root, ref bouncer, ref nominator }
                            =>
                            Self::RolesUpdated {
                                root: ::core::clone::Clone::clone(root),
                                bouncer: ::core::clone::Clone::clone(bouncer),
                                nominator: ::core::clone::Clone::clone(nominator),
                            },
                        Self::PoolSlashed { ref pool_id, ref balance } =>
                            Self::PoolSlashed {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                balance: ::core::clone::Clone::clone(balance),
                            },
                        Self::UnbondingPoolSlashed {
                            ref pool_id, ref era, ref balance } =>
                            Self::UnbondingPoolSlashed {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                era: ::core::clone::Clone::clone(era),
                                balance: ::core::clone::Clone::clone(balance),
                            },
                        Self::PoolCommissionUpdated { ref pool_id, ref current } =>
                            Self::PoolCommissionUpdated {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                current: ::core::clone::Clone::clone(current),
                            },
                        Self::PoolMaxCommissionUpdated {
                            ref pool_id, ref max_commission } =>
                            Self::PoolMaxCommissionUpdated {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                max_commission: ::core::clone::Clone::clone(max_commission),
                            },
                        Self::PoolCommissionChangeRateUpdated {
                            ref pool_id, ref change_rate } =>
                            Self::PoolCommissionChangeRateUpdated {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                change_rate: ::core::clone::Clone::clone(change_rate),
                            },
                        Self::PoolCommissionClaimPermissionUpdated {
                            ref pool_id, ref permission } =>
                            Self::PoolCommissionClaimPermissionUpdated {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                permission: ::core::clone::Clone::clone(permission),
                            },
                        Self::PoolCommissionClaimed { ref pool_id, ref commission }
                            =>
                            Self::PoolCommissionClaimed {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                commission: ::core::clone::Clone::clone(commission),
                            },
                        Self::MinBalanceDeficitAdjusted { ref pool_id, ref amount }
                            =>
                            Self::MinBalanceDeficitAdjusted {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                amount: ::core::clone::Clone::clone(amount),
                            },
                        Self::MinBalanceExcessAdjusted { ref pool_id, ref amount }
                            =>
                            Self::MinBalanceExcessAdjusted {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                amount: ::core::clone::Clone::clone(amount),
                            },
                        Self::__Ignore(ref _0, ref _1) =>
                            Self::__Ignore(::core::clone::Clone::clone(_0),
                                ::core::clone::Clone::clone(_1)),
                    }
                }
            }
        };
    const _: () =
        {
            impl<T: Config> ::core::cmp::Eq for Event<T> {}
        };
    const _: () =
        {
            #[automatically_derived]
            impl<T: Config> ::core::cmp::PartialEq for Event<T> {
                fn eq(&self, other: &Self) -> bool {
                    match (self, other) {
                        (Self::Created { depositor, pool_id }, Self::Created {
                            depositor: _0, pool_id: _1 }) =>
                            true && depositor == _0 && pool_id == _1,
                        (Self::Bonded { member, pool_id, bonded, joined },
                            Self::Bonded {
                            member: _0, pool_id: _1, bonded: _2, joined: _3 }) =>
                            true && member == _0 && pool_id == _1 && bonded == _2 &&
                                joined == _3,
                        (Self::PaidOut { member, pool_id, payout }, Self::PaidOut {
                            member: _0, pool_id: _1, payout: _2 }) =>
                            true && member == _0 && pool_id == _1 && payout == _2,
                        (Self::Unbonded { member, pool_id, balance, points, era },
                            Self::Unbonded {
                            member: _0, pool_id: _1, balance: _2, points: _3, era: _4 })
                            =>
                            true && member == _0 && pool_id == _1 && balance == _2 &&
                                    points == _3 && era == _4,
                        (Self::Withdrawn { member, pool_id, balance, points },
                            Self::Withdrawn {
                            member: _0, pool_id: _1, balance: _2, points: _3 }) =>
                            true && member == _0 && pool_id == _1 && balance == _2 &&
                                points == _3,
                        (Self::Destroyed { pool_id }, Self::Destroyed { pool_id: _0
                            }) => true && pool_id == _0,
                        (Self::StateChanged { pool_id, new_state },
                            Self::StateChanged { pool_id: _0, new_state: _1 }) =>
                            true && pool_id == _0 && new_state == _1,
                        (Self::MemberRemoved { pool_id, member },
                            Self::MemberRemoved { pool_id: _0, member: _1 }) =>
                            true && pool_id == _0 && member == _1,
                        (Self::RolesUpdated { root, bouncer, nominator },
                            Self::RolesUpdated { root: _0, bouncer: _1, nominator: _2 })
                            => true && root == _0 && bouncer == _1 && nominator == _2,
                        (Self::PoolSlashed { pool_id, balance }, Self::PoolSlashed {
                            pool_id: _0, balance: _1 }) =>
                            true && pool_id == _0 && balance == _1,
                        (Self::UnbondingPoolSlashed { pool_id, era, balance },
                            Self::UnbondingPoolSlashed {
                            pool_id: _0, era: _1, balance: _2 }) =>
                            true && pool_id == _0 && era == _1 && balance == _2,
                        (Self::PoolCommissionUpdated { pool_id, current },
                            Self::PoolCommissionUpdated { pool_id: _0, current: _1 }) =>
                            true && pool_id == _0 && current == _1,
                        (Self::PoolMaxCommissionUpdated { pool_id, max_commission },
                            Self::PoolMaxCommissionUpdated {
                            pool_id: _0, max_commission: _1 }) =>
                            true && pool_id == _0 && max_commission == _1,
                        (Self::PoolCommissionChangeRateUpdated {
                            pool_id, change_rate },
                            Self::PoolCommissionChangeRateUpdated {
                            pool_id: _0, change_rate: _1 }) =>
                            true && pool_id == _0 && change_rate == _1,
                        (Self::PoolCommissionClaimPermissionUpdated {
                            pool_id, permission },
                            Self::PoolCommissionClaimPermissionUpdated {
                            pool_id: _0, permission: _1 }) =>
                            true && pool_id == _0 && permission == _1,
                        (Self::PoolCommissionClaimed { pool_id, commission },
                            Self::PoolCommissionClaimed { pool_id: _0, commission: _1 })
                            => true && pool_id == _0 && commission == _1,
                        (Self::MinBalanceDeficitAdjusted { pool_id, amount },
                            Self::MinBalanceDeficitAdjusted { pool_id: _0, amount: _1 })
                            => true && pool_id == _0 && amount == _1,
                        (Self::MinBalanceExcessAdjusted { pool_id, amount },
                            Self::MinBalanceExcessAdjusted { pool_id: _0, amount: _1 })
                            => true && pool_id == _0 && amount == _1,
                        (Self::__Ignore(_0, _1), Self::__Ignore(_0_other, _1_other))
                            => true && _0 == _0_other && _1 == _1_other,
                        (Self::Created { .. }, Self::Bonded { .. }) => false,
                        (Self::Created { .. }, Self::PaidOut { .. }) => false,
                        (Self::Created { .. }, Self::Unbonded { .. }) => false,
                        (Self::Created { .. }, Self::Withdrawn { .. }) => false,
                        (Self::Created { .. }, Self::Destroyed { .. }) => false,
                        (Self::Created { .. }, Self::StateChanged { .. }) => false,
                        (Self::Created { .. }, Self::MemberRemoved { .. }) => false,
                        (Self::Created { .. }, Self::RolesUpdated { .. }) => false,
                        (Self::Created { .. }, Self::PoolSlashed { .. }) => false,
                        (Self::Created { .. }, Self::UnbondingPoolSlashed { .. }) =>
                            false,
                        (Self::Created { .. }, Self::PoolCommissionUpdated { .. })
                            => false,
                        (Self::Created { .. }, Self::PoolMaxCommissionUpdated { ..
                            }) => false,
                        (Self::Created { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::Created { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::Created { .. }, Self::PoolCommissionClaimed { .. })
                            => false,
                        (Self::Created { .. }, Self::MinBalanceDeficitAdjusted { ..
                            }) => false,
                        (Self::Created { .. }, Self::MinBalanceExcessAdjusted { ..
                            }) => false,
                        (Self::Created { .. }, Self::__Ignore { .. }) => false,
                        (Self::Bonded { .. }, Self::Created { .. }) => false,
                        (Self::Bonded { .. }, Self::PaidOut { .. }) => false,
                        (Self::Bonded { .. }, Self::Unbonded { .. }) => false,
                        (Self::Bonded { .. }, Self::Withdrawn { .. }) => false,
                        (Self::Bonded { .. }, Self::Destroyed { .. }) => false,
                        (Self::Bonded { .. }, Self::StateChanged { .. }) => false,
                        (Self::Bonded { .. }, Self::MemberRemoved { .. }) => false,
                        (Self::Bonded { .. }, Self::RolesUpdated { .. }) => false,
                        (Self::Bonded { .. }, Self::PoolSlashed { .. }) => false,
                        (Self::Bonded { .. }, Self::UnbondingPoolSlashed { .. }) =>
                            false,
                        (Self::Bonded { .. }, Self::PoolCommissionUpdated { .. }) =>
                            false,
                        (Self::Bonded { .. }, Self::PoolMaxCommissionUpdated { .. })
                            => false,
                        (Self::Bonded { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::Bonded { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::Bonded { .. }, Self::PoolCommissionClaimed { .. }) =>
                            false,
                        (Self::Bonded { .. }, Self::MinBalanceDeficitAdjusted { ..
                            }) => false,
                        (Self::Bonded { .. }, Self::MinBalanceExcessAdjusted { .. })
                            => false,
                        (Self::Bonded { .. }, Self::__Ignore { .. }) => false,
                        (Self::PaidOut { .. }, Self::Created { .. }) => false,
                        (Self::PaidOut { .. }, Self::Bonded { .. }) => false,
                        (Self::PaidOut { .. }, Self::Unbonded { .. }) => false,
                        (Self::PaidOut { .. }, Self::Withdrawn { .. }) => false,
                        (Self::PaidOut { .. }, Self::Destroyed { .. }) => false,
                        (Self::PaidOut { .. }, Self::StateChanged { .. }) => false,
                        (Self::PaidOut { .. }, Self::MemberRemoved { .. }) => false,
                        (Self::PaidOut { .. }, Self::RolesUpdated { .. }) => false,
                        (Self::PaidOut { .. }, Self::PoolSlashed { .. }) => false,
                        (Self::PaidOut { .. }, Self::UnbondingPoolSlashed { .. }) =>
                            false,
                        (Self::PaidOut { .. }, Self::PoolCommissionUpdated { .. })
                            => false,
                        (Self::PaidOut { .. }, Self::PoolMaxCommissionUpdated { ..
                            }) => false,
                        (Self::PaidOut { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::PaidOut { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::PaidOut { .. }, Self::PoolCommissionClaimed { .. })
                            => false,
                        (Self::PaidOut { .. }, Self::MinBalanceDeficitAdjusted { ..
                            }) => false,
                        (Self::PaidOut { .. }, Self::MinBalanceExcessAdjusted { ..
                            }) => false,
                        (Self::PaidOut { .. }, Self::__Ignore { .. }) => false,
                        (Self::Unbonded { .. }, Self::Created { .. }) => false,
                        (Self::Unbonded { .. }, Self::Bonded { .. }) => false,
                        (Self::Unbonded { .. }, Self::PaidOut { .. }) => false,
                        (Self::Unbonded { .. }, Self::Withdrawn { .. }) => false,
                        (Self::Unbonded { .. }, Self::Destroyed { .. }) => false,
                        (Self::Unbonded { .. }, Self::StateChanged { .. }) => false,
                        (Self::Unbonded { .. }, Self::MemberRemoved { .. }) =>
                            false,
                        (Self::Unbonded { .. }, Self::RolesUpdated { .. }) => false,
                        (Self::Unbonded { .. }, Self::PoolSlashed { .. }) => false,
                        (Self::Unbonded { .. }, Self::UnbondingPoolSlashed { .. })
                            => false,
                        (Self::Unbonded { .. }, Self::PoolCommissionUpdated { .. })
                            => false,
                        (Self::Unbonded { .. }, Self::PoolMaxCommissionUpdated { ..
                            }) => false,
                        (Self::Unbonded { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::Unbonded { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::Unbonded { .. }, Self::PoolCommissionClaimed { .. })
                            => false,
                        (Self::Unbonded { .. }, Self::MinBalanceDeficitAdjusted { ..
                            }) => false,
                        (Self::Unbonded { .. }, Self::MinBalanceExcessAdjusted { ..
                            }) => false,
                        (Self::Unbonded { .. }, Self::__Ignore { .. }) => false,
                        (Self::Withdrawn { .. }, Self::Created { .. }) => false,
                        (Self::Withdrawn { .. }, Self::Bonded { .. }) => false,
                        (Self::Withdrawn { .. }, Self::PaidOut { .. }) => false,
                        (Self::Withdrawn { .. }, Self::Unbonded { .. }) => false,
                        (Self::Withdrawn { .. }, Self::Destroyed { .. }) => false,
                        (Self::Withdrawn { .. }, Self::StateChanged { .. }) =>
                            false,
                        (Self::Withdrawn { .. }, Self::MemberRemoved { .. }) =>
                            false,
                        (Self::Withdrawn { .. }, Self::RolesUpdated { .. }) =>
                            false,
                        (Self::Withdrawn { .. }, Self::PoolSlashed { .. }) => false,
                        (Self::Withdrawn { .. }, Self::UnbondingPoolSlashed { .. })
                            => false,
                        (Self::Withdrawn { .. }, Self::PoolCommissionUpdated { .. })
                            => false,
                        (Self::Withdrawn { .. }, Self::PoolMaxCommissionUpdated { ..
                            }) => false,
                        (Self::Withdrawn { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::Withdrawn { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::Withdrawn { .. }, Self::PoolCommissionClaimed { .. })
                            => false,
                        (Self::Withdrawn { .. }, Self::MinBalanceDeficitAdjusted {
                            .. }) => false,
                        (Self::Withdrawn { .. }, Self::MinBalanceExcessAdjusted { ..
                            }) => false,
                        (Self::Withdrawn { .. }, Self::__Ignore { .. }) => false,
                        (Self::Destroyed { .. }, Self::Created { .. }) => false,
                        (Self::Destroyed { .. }, Self::Bonded { .. }) => false,
                        (Self::Destroyed { .. }, Self::PaidOut { .. }) => false,
                        (Self::Destroyed { .. }, Self::Unbonded { .. }) => false,
                        (Self::Destroyed { .. }, Self::Withdrawn { .. }) => false,
                        (Self::Destroyed { .. }, Self::StateChanged { .. }) =>
                            false,
                        (Self::Destroyed { .. }, Self::MemberRemoved { .. }) =>
                            false,
                        (Self::Destroyed { .. }, Self::RolesUpdated { .. }) =>
                            false,
                        (Self::Destroyed { .. }, Self::PoolSlashed { .. }) => false,
                        (Self::Destroyed { .. }, Self::UnbondingPoolSlashed { .. })
                            => false,
                        (Self::Destroyed { .. }, Self::PoolCommissionUpdated { .. })
                            => false,
                        (Self::Destroyed { .. }, Self::PoolMaxCommissionUpdated { ..
                            }) => false,
                        (Self::Destroyed { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::Destroyed { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::Destroyed { .. }, Self::PoolCommissionClaimed { .. })
                            => false,
                        (Self::Destroyed { .. }, Self::MinBalanceDeficitAdjusted {
                            .. }) => false,
                        (Self::Destroyed { .. }, Self::MinBalanceExcessAdjusted { ..
                            }) => false,
                        (Self::Destroyed { .. }, Self::__Ignore { .. }) => false,
                        (Self::StateChanged { .. }, Self::Created { .. }) => false,
                        (Self::StateChanged { .. }, Self::Bonded { .. }) => false,
                        (Self::StateChanged { .. }, Self::PaidOut { .. }) => false,
                        (Self::StateChanged { .. }, Self::Unbonded { .. }) => false,
                        (Self::StateChanged { .. }, Self::Withdrawn { .. }) =>
                            false,
                        (Self::StateChanged { .. }, Self::Destroyed { .. }) =>
                            false,
                        (Self::StateChanged { .. }, Self::MemberRemoved { .. }) =>
                            false,
                        (Self::StateChanged { .. }, Self::RolesUpdated { .. }) =>
                            false,
                        (Self::StateChanged { .. }, Self::PoolSlashed { .. }) =>
                            false,
                        (Self::StateChanged { .. }, Self::UnbondingPoolSlashed { ..
                            }) => false,
                        (Self::StateChanged { .. }, Self::PoolCommissionUpdated { ..
                            }) => false,
                        (Self::StateChanged { .. }, Self::PoolMaxCommissionUpdated {
                            .. }) => false,
                        (Self::StateChanged { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::StateChanged { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::StateChanged { .. }, Self::PoolCommissionClaimed { ..
                            }) => false,
                        (Self::StateChanged { .. },
                            Self::MinBalanceDeficitAdjusted { .. }) => false,
                        (Self::StateChanged { .. }, Self::MinBalanceExcessAdjusted {
                            .. }) => false,
                        (Self::StateChanged { .. }, Self::__Ignore { .. }) => false,
                        (Self::MemberRemoved { .. }, Self::Created { .. }) => false,
                        (Self::MemberRemoved { .. }, Self::Bonded { .. }) => false,
                        (Self::MemberRemoved { .. }, Self::PaidOut { .. }) => false,
                        (Self::MemberRemoved { .. }, Self::Unbonded { .. }) =>
                            false,
                        (Self::MemberRemoved { .. }, Self::Withdrawn { .. }) =>
                            false,
                        (Self::MemberRemoved { .. }, Self::Destroyed { .. }) =>
                            false,
                        (Self::MemberRemoved { .. }, Self::StateChanged { .. }) =>
                            false,
                        (Self::MemberRemoved { .. }, Self::RolesUpdated { .. }) =>
                            false,
                        (Self::MemberRemoved { .. }, Self::PoolSlashed { .. }) =>
                            false,
                        (Self::MemberRemoved { .. }, Self::UnbondingPoolSlashed { ..
                            }) => false,
                        (Self::MemberRemoved { .. }, Self::PoolCommissionUpdated {
                            .. }) => false,
                        (Self::MemberRemoved { .. },
                            Self::PoolMaxCommissionUpdated { .. }) => false,
                        (Self::MemberRemoved { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::MemberRemoved { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::MemberRemoved { .. }, Self::PoolCommissionClaimed {
                            .. }) => false,
                        (Self::MemberRemoved { .. },
                            Self::MinBalanceDeficitAdjusted { .. }) => false,
                        (Self::MemberRemoved { .. },
                            Self::MinBalanceExcessAdjusted { .. }) => false,
                        (Self::MemberRemoved { .. }, Self::__Ignore { .. }) =>
                            false,
                        (Self::RolesUpdated { .. }, Self::Created { .. }) => false,
                        (Self::RolesUpdated { .. }, Self::Bonded { .. }) => false,
                        (Self::RolesUpdated { .. }, Self::PaidOut { .. }) => false,
                        (Self::RolesUpdated { .. }, Self::Unbonded { .. }) => false,
                        (Self::RolesUpdated { .. }, Self::Withdrawn { .. }) =>
                            false,
                        (Self::RolesUpdated { .. }, Self::Destroyed { .. }) =>
                            false,
                        (Self::RolesUpdated { .. }, Self::StateChanged { .. }) =>
                            false,
                        (Self::RolesUpdated { .. }, Self::MemberRemoved { .. }) =>
                            false,
                        (Self::RolesUpdated { .. }, Self::PoolSlashed { .. }) =>
                            false,
                        (Self::RolesUpdated { .. }, Self::UnbondingPoolSlashed { ..
                            }) => false,
                        (Self::RolesUpdated { .. }, Self::PoolCommissionUpdated { ..
                            }) => false,
                        (Self::RolesUpdated { .. }, Self::PoolMaxCommissionUpdated {
                            .. }) => false,
                        (Self::RolesUpdated { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::RolesUpdated { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::RolesUpdated { .. }, Self::PoolCommissionClaimed { ..
                            }) => false,
                        (Self::RolesUpdated { .. },
                            Self::MinBalanceDeficitAdjusted { .. }) => false,
                        (Self::RolesUpdated { .. }, Self::MinBalanceExcessAdjusted {
                            .. }) => false,
                        (Self::RolesUpdated { .. }, Self::__Ignore { .. }) => false,
                        (Self::PoolSlashed { .. }, Self::Created { .. }) => false,
                        (Self::PoolSlashed { .. }, Self::Bonded { .. }) => false,
                        (Self::PoolSlashed { .. }, Self::PaidOut { .. }) => false,
                        (Self::PoolSlashed { .. }, Self::Unbonded { .. }) => false,
                        (Self::PoolSlashed { .. }, Self::Withdrawn { .. }) => false,
                        (Self::PoolSlashed { .. }, Self::Destroyed { .. }) => false,
                        (Self::PoolSlashed { .. }, Self::StateChanged { .. }) =>
                            false,
                        (Self::PoolSlashed { .. }, Self::MemberRemoved { .. }) =>
                            false,
                        (Self::PoolSlashed { .. }, Self::RolesUpdated { .. }) =>
                            false,
                        (Self::PoolSlashed { .. }, Self::UnbondingPoolSlashed { ..
                            }) => false,
                        (Self::PoolSlashed { .. }, Self::PoolCommissionUpdated { ..
                            }) => false,
                        (Self::PoolSlashed { .. }, Self::PoolMaxCommissionUpdated {
                            .. }) => false,
                        (Self::PoolSlashed { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::PoolSlashed { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::PoolSlashed { .. }, Self::PoolCommissionClaimed { ..
                            }) => false,
                        (Self::PoolSlashed { .. }, Self::MinBalanceDeficitAdjusted {
                            .. }) => false,
                        (Self::PoolSlashed { .. }, Self::MinBalanceExcessAdjusted {
                            .. }) => false,
                        (Self::PoolSlashed { .. }, Self::__Ignore { .. }) => false,
                        (Self::UnbondingPoolSlashed { .. }, Self::Created { .. }) =>
                            false,
                        (Self::UnbondingPoolSlashed { .. }, Self::Bonded { .. }) =>
                            false,
                        (Self::UnbondingPoolSlashed { .. }, Self::PaidOut { .. }) =>
                            false,
                        (Self::UnbondingPoolSlashed { .. }, Self::Unbonded { .. })
                            => false,
                        (Self::UnbondingPoolSlashed { .. }, Self::Withdrawn { .. })
                            => false,
                        (Self::UnbondingPoolSlashed { .. }, Self::Destroyed { .. })
                            => false,
                        (Self::UnbondingPoolSlashed { .. }, Self::StateChanged { ..
                            }) => false,
                        (Self::UnbondingPoolSlashed { .. }, Self::MemberRemoved { ..
                            }) => false,
                        (Self::UnbondingPoolSlashed { .. }, Self::RolesUpdated { ..
                            }) => false,
                        (Self::UnbondingPoolSlashed { .. }, Self::PoolSlashed { ..
                            }) => false,
                        (Self::UnbondingPoolSlashed { .. },
                            Self::PoolCommissionUpdated { .. }) => false,
                        (Self::UnbondingPoolSlashed { .. },
                            Self::PoolMaxCommissionUpdated { .. }) => false,
                        (Self::UnbondingPoolSlashed { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::UnbondingPoolSlashed { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::UnbondingPoolSlashed { .. },
                            Self::PoolCommissionClaimed { .. }) => false,
                        (Self::UnbondingPoolSlashed { .. },
                            Self::MinBalanceDeficitAdjusted { .. }) => false,
                        (Self::UnbondingPoolSlashed { .. },
                            Self::MinBalanceExcessAdjusted { .. }) => false,
                        (Self::UnbondingPoolSlashed { .. }, Self::__Ignore { .. })
                            => false,
                        (Self::PoolCommissionUpdated { .. }, Self::Created { .. })
                            => false,
                        (Self::PoolCommissionUpdated { .. }, Self::Bonded { .. }) =>
                            false,
                        (Self::PoolCommissionUpdated { .. }, Self::PaidOut { .. })
                            => false,
                        (Self::PoolCommissionUpdated { .. }, Self::Unbonded { .. })
                            => false,
                        (Self::PoolCommissionUpdated { .. }, Self::Withdrawn { .. })
                            => false,
                        (Self::PoolCommissionUpdated { .. }, Self::Destroyed { .. })
                            => false,
                        (Self::PoolCommissionUpdated { .. }, Self::StateChanged { ..
                            }) => false,
                        (Self::PoolCommissionUpdated { .. }, Self::MemberRemoved {
                            .. }) => false,
                        (Self::PoolCommissionUpdated { .. }, Self::RolesUpdated { ..
                            }) => false,
                        (Self::PoolCommissionUpdated { .. }, Self::PoolSlashed { ..
                            }) => false,
                        (Self::PoolCommissionUpdated { .. },
                            Self::UnbondingPoolSlashed { .. }) => false,
                        (Self::PoolCommissionUpdated { .. },
                            Self::PoolMaxCommissionUpdated { .. }) => false,
                        (Self::PoolCommissionUpdated { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::PoolCommissionUpdated { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::PoolCommissionUpdated { .. },
                            Self::PoolCommissionClaimed { .. }) => false,
                        (Self::PoolCommissionUpdated { .. },
                            Self::MinBalanceDeficitAdjusted { .. }) => false,
                        (Self::PoolCommissionUpdated { .. },
                            Self::MinBalanceExcessAdjusted { .. }) => false,
                        (Self::PoolCommissionUpdated { .. }, Self::__Ignore { .. })
                            => false,
                        (Self::PoolMaxCommissionUpdated { .. }, Self::Created { ..
                            }) => false,
                        (Self::PoolMaxCommissionUpdated { .. }, Self::Bonded { .. })
                            => false,
                        (Self::PoolMaxCommissionUpdated { .. }, Self::PaidOut { ..
                            }) => false,
                        (Self::PoolMaxCommissionUpdated { .. }, Self::Unbonded { ..
                            }) => false,
                        (Self::PoolMaxCommissionUpdated { .. }, Self::Withdrawn { ..
                            }) => false,
                        (Self::PoolMaxCommissionUpdated { .. }, Self::Destroyed { ..
                            }) => false,
                        (Self::PoolMaxCommissionUpdated { .. }, Self::StateChanged {
                            .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. },
                            Self::MemberRemoved { .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. }, Self::RolesUpdated {
                            .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. }, Self::PoolSlashed {
                            .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. },
                            Self::UnbondingPoolSlashed { .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. },
                            Self::PoolCommissionUpdated { .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. },
                            Self::PoolCommissionClaimed { .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. },
                            Self::MinBalanceDeficitAdjusted { .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. },
                            Self::MinBalanceExcessAdjusted { .. }) => false,
                        (Self::PoolMaxCommissionUpdated { .. }, Self::__Ignore { ..
                            }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::Created { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::Bonded { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::PaidOut { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::Unbonded { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::Withdrawn { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::Destroyed { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::StateChanged { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::MemberRemoved { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::RolesUpdated { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::PoolSlashed { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::UnbondingPoolSlashed { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::PoolCommissionUpdated { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::PoolMaxCommissionUpdated { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::PoolCommissionClaimed { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::MinBalanceDeficitAdjusted { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::MinBalanceExcessAdjusted { .. }) => false,
                        (Self::PoolCommissionChangeRateUpdated { .. },
                            Self::__Ignore { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::Created { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::Bonded { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::PaidOut { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::Unbonded { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::Withdrawn { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::Destroyed { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::StateChanged { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::MemberRemoved { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::RolesUpdated { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::PoolSlashed { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::UnbondingPoolSlashed { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::PoolCommissionUpdated { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::PoolMaxCommissionUpdated { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::PoolCommissionClaimed { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::MinBalanceDeficitAdjusted { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::MinBalanceExcessAdjusted { .. }) => false,
                        (Self::PoolCommissionClaimPermissionUpdated { .. },
                            Self::__Ignore { .. }) => false,
                        (Self::PoolCommissionClaimed { .. }, Self::Created { .. })
                            => false,
                        (Self::PoolCommissionClaimed { .. }, Self::Bonded { .. }) =>
                            false,
                        (Self::PoolCommissionClaimed { .. }, Self::PaidOut { .. })
                            => false,
                        (Self::PoolCommissionClaimed { .. }, Self::Unbonded { .. })
                            => false,
                        (Self::PoolCommissionClaimed { .. }, Self::Withdrawn { .. })
                            => false,
                        (Self::PoolCommissionClaimed { .. }, Self::Destroyed { .. })
                            => false,
                        (Self::PoolCommissionClaimed { .. }, Self::StateChanged { ..
                            }) => false,
                        (Self::PoolCommissionClaimed { .. }, Self::MemberRemoved {
                            .. }) => false,
                        (Self::PoolCommissionClaimed { .. }, Self::RolesUpdated { ..
                            }) => false,
                        (Self::PoolCommissionClaimed { .. }, Self::PoolSlashed { ..
                            }) => false,
                        (Self::PoolCommissionClaimed { .. },
                            Self::UnbondingPoolSlashed { .. }) => false,
                        (Self::PoolCommissionClaimed { .. },
                            Self::PoolCommissionUpdated { .. }) => false,
                        (Self::PoolCommissionClaimed { .. },
                            Self::PoolMaxCommissionUpdated { .. }) => false,
                        (Self::PoolCommissionClaimed { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::PoolCommissionClaimed { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::PoolCommissionClaimed { .. },
                            Self::MinBalanceDeficitAdjusted { .. }) => false,
                        (Self::PoolCommissionClaimed { .. },
                            Self::MinBalanceExcessAdjusted { .. }) => false,
                        (Self::PoolCommissionClaimed { .. }, Self::__Ignore { .. })
                            => false,
                        (Self::MinBalanceDeficitAdjusted { .. }, Self::Created { ..
                            }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. }, Self::Bonded { ..
                            }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. }, Self::PaidOut { ..
                            }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. }, Self::Unbonded { ..
                            }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. }, Self::Withdrawn {
                            .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. }, Self::Destroyed {
                            .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. },
                            Self::StateChanged { .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. },
                            Self::MemberRemoved { .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. },
                            Self::RolesUpdated { .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. }, Self::PoolSlashed {
                            .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. },
                            Self::UnbondingPoolSlashed { .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. },
                            Self::PoolCommissionUpdated { .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. },
                            Self::PoolMaxCommissionUpdated { .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. },
                            Self::PoolCommissionClaimed { .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. },
                            Self::MinBalanceExcessAdjusted { .. }) => false,
                        (Self::MinBalanceDeficitAdjusted { .. }, Self::__Ignore { ..
                            }) => false,
                        (Self::MinBalanceExcessAdjusted { .. }, Self::Created { ..
                            }) => false,
                        (Self::MinBalanceExcessAdjusted { .. }, Self::Bonded { .. })
                            => false,
                        (Self::MinBalanceExcessAdjusted { .. }, Self::PaidOut { ..
                            }) => false,
                        (Self::MinBalanceExcessAdjusted { .. }, Self::Unbonded { ..
                            }) => false,
                        (Self::MinBalanceExcessAdjusted { .. }, Self::Withdrawn { ..
                            }) => false,
                        (Self::MinBalanceExcessAdjusted { .. }, Self::Destroyed { ..
                            }) => false,
                        (Self::MinBalanceExcessAdjusted { .. }, Self::StateChanged {
                            .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. },
                            Self::MemberRemoved { .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. }, Self::RolesUpdated {
                            .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. }, Self::PoolSlashed {
                            .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. },
                            Self::UnbondingPoolSlashed { .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. },
                            Self::PoolCommissionUpdated { .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. },
                            Self::PoolMaxCommissionUpdated { .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. },
                            Self::PoolCommissionClaimed { .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. },
                            Self::MinBalanceDeficitAdjusted { .. }) => false,
                        (Self::MinBalanceExcessAdjusted { .. }, Self::__Ignore { ..
                            }) => false,
                        (Self::__Ignore { .. }, Self::Created { .. }) => false,
                        (Self::__Ignore { .. }, Self::Bonded { .. }) => false,
                        (Self::__Ignore { .. }, Self::PaidOut { .. }) => false,
                        (Self::__Ignore { .. }, Self::Unbonded { .. }) => false,
                        (Self::__Ignore { .. }, Self::Withdrawn { .. }) => false,
                        (Self::__Ignore { .. }, Self::Destroyed { .. }) => false,
                        (Self::__Ignore { .. }, Self::StateChanged { .. }) => false,
                        (Self::__Ignore { .. }, Self::MemberRemoved { .. }) =>
                            false,
                        (Self::__Ignore { .. }, Self::RolesUpdated { .. }) => false,
                        (Self::__Ignore { .. }, Self::PoolSlashed { .. }) => false,
                        (Self::__Ignore { .. }, Self::UnbondingPoolSlashed { .. })
                            => false,
                        (Self::__Ignore { .. }, Self::PoolCommissionUpdated { .. })
                            => false,
                        (Self::__Ignore { .. }, Self::PoolMaxCommissionUpdated { ..
                            }) => false,
                        (Self::__Ignore { .. },
                            Self::PoolCommissionChangeRateUpdated { .. }) => false,
                        (Self::__Ignore { .. },
                            Self::PoolCommissionClaimPermissionUpdated { .. }) => false,
                        (Self::__Ignore { .. }, Self::PoolCommissionClaimed { .. })
                            => false,
                        (Self::__Ignore { .. }, Self::MinBalanceDeficitAdjusted { ..
                            }) => false,
                        (Self::__Ignore { .. }, Self::MinBalanceExcessAdjusted { ..
                            }) => false,
                    }
                }
            }
        };
    const _: () =
        {
            #[automatically_derived]
            impl<T: Config> ::core::fmt::Debug for Event<T> {
                fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    match *self {
                        Self::Created { ref depositor, ref pool_id } => {
                            fmt.debug_struct("Event::Created").field("depositor",
                                        &depositor).field("pool_id", &pool_id).finish()
                        }
                        Self::Bonded {
                            ref member, ref pool_id, ref bonded, ref joined } => {
                            fmt.debug_struct("Event::Bonded").field("member",
                                                &member).field("pool_id",
                                            &pool_id).field("bonded",
                                        &bonded).field("joined", &joined).finish()
                        }
                        Self::PaidOut { ref member, ref pool_id, ref payout } => {
                            fmt.debug_struct("Event::PaidOut").field("member",
                                            &member).field("pool_id",
                                        &pool_id).field("payout", &payout).finish()
                        }
                        Self::Unbonded {
                            ref member, ref pool_id, ref balance, ref points, ref era }
                            => {
                            fmt.debug_struct("Event::Unbonded").field("member",
                                                    &member).field("pool_id",
                                                &pool_id).field("balance",
                                            &balance).field("points",
                                        &points).field("era", &era).finish()
                        }
                        Self::Withdrawn {
                            ref member, ref pool_id, ref balance, ref points } => {
                            fmt.debug_struct("Event::Withdrawn").field("member",
                                                &member).field("pool_id",
                                            &pool_id).field("balance",
                                        &balance).field("points", &points).finish()
                        }
                        Self::Destroyed { ref pool_id } => {
                            fmt.debug_struct("Event::Destroyed").field("pool_id",
                                    &pool_id).finish()
                        }
                        Self::StateChanged { ref pool_id, ref new_state } => {
                            fmt.debug_struct("Event::StateChanged").field("pool_id",
                                        &pool_id).field("new_state", &new_state).finish()
                        }
                        Self::MemberRemoved { ref pool_id, ref member } => {
                            fmt.debug_struct("Event::MemberRemoved").field("pool_id",
                                        &pool_id).field("member", &member).finish()
                        }
                        Self::RolesUpdated { ref root, ref bouncer, ref nominator }
                            => {
                            fmt.debug_struct("Event::RolesUpdated").field("root",
                                            &root).field("bouncer",
                                        &bouncer).field("nominator", &nominator).finish()
                        }
                        Self::PoolSlashed { ref pool_id, ref balance } => {
                            fmt.debug_struct("Event::PoolSlashed").field("pool_id",
                                        &pool_id).field("balance", &balance).finish()
                        }
                        Self::UnbondingPoolSlashed {
                            ref pool_id, ref era, ref balance } => {
                            fmt.debug_struct("Event::UnbondingPoolSlashed").field("pool_id",
                                            &pool_id).field("era",
                                        &era).field("balance", &balance).finish()
                        }
                        Self::PoolCommissionUpdated { ref pool_id, ref current } =>
                            {
                            fmt.debug_struct("Event::PoolCommissionUpdated").field("pool_id",
                                        &pool_id).field("current", &current).finish()
                        }
                        Self::PoolMaxCommissionUpdated {
                            ref pool_id, ref max_commission } => {
                            fmt.debug_struct("Event::PoolMaxCommissionUpdated").field("pool_id",
                                        &pool_id).field("max_commission", &max_commission).finish()
                        }
                        Self::PoolCommissionChangeRateUpdated {
                            ref pool_id, ref change_rate } => {
                            fmt.debug_struct("Event::PoolCommissionChangeRateUpdated").field("pool_id",
                                        &pool_id).field("change_rate", &change_rate).finish()
                        }
                        Self::PoolCommissionClaimPermissionUpdated {
                            ref pool_id, ref permission } => {
                            fmt.debug_struct("Event::PoolCommissionClaimPermissionUpdated").field("pool_id",
                                        &pool_id).field("permission", &permission).finish()
                        }
                        Self::PoolCommissionClaimed { ref pool_id, ref commission }
                            => {
                            fmt.debug_struct("Event::PoolCommissionClaimed").field("pool_id",
                                        &pool_id).field("commission", &commission).finish()
                        }
                        Self::MinBalanceDeficitAdjusted { ref pool_id, ref amount }
                            => {
                            fmt.debug_struct("Event::MinBalanceDeficitAdjusted").field("pool_id",
                                        &pool_id).field("amount", &amount).finish()
                        }
                        Self::MinBalanceExcessAdjusted { ref pool_id, ref amount }
                            => {
                            fmt.debug_struct("Event::MinBalanceExcessAdjusted").field("pool_id",
                                        &pool_id).field("amount", &amount).finish()
                        }
                        Self::__Ignore(ref _0, ref _1) => {
                            fmt.debug_tuple("Event::__Ignore").field(&_0).field(&_1).finish()
                        }
                    }
                }
            }
        };
    #[allow(deprecated)]
    const _: () =
        {
            #[automatically_derived]
            impl<T: Config> ::codec::Encode for Event<T> where
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                Option<(Perbill, T::AccountId)>: ::codec::Encode,
                Option<(Perbill, T::AccountId)>: ::codec::Encode,
                CommissionChangeRate<BlockNumberFor<T>>: ::codec::Encode,
                CommissionChangeRate<BlockNumberFor<T>>: ::codec::Encode,
                Option<CommissionClaimPermission<T::AccountId>>: ::codec::Encode,
                Option<CommissionClaimPermission<T::AccountId>>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode {
                fn size_hint(&self) -> usize {
                    1_usize +
                        match *self {
                            Event::Created { ref depositor, ref pool_id } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(depositor)).saturating_add(::codec::Encode::size_hint(pool_id))
                            }
                            Event::Bonded {
                                ref member, ref pool_id, ref bonded, ref joined } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(member)).saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(bonded)).saturating_add(::codec::Encode::size_hint(joined))
                            }
                            Event::PaidOut { ref member, ref pool_id, ref payout } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(member)).saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(payout))
                            }
                            Event::Unbonded {
                                ref member, ref pool_id, ref balance, ref points, ref era }
                                => {
                                0_usize.saturating_add(::codec::Encode::size_hint(member)).saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(balance)).saturating_add(::codec::Encode::size_hint(points)).saturating_add(::codec::Encode::size_hint(era))
                            }
                            Event::Withdrawn {
                                ref member, ref pool_id, ref balance, ref points } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(member)).saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(balance)).saturating_add(::codec::Encode::size_hint(points))
                            }
                            Event::Destroyed { ref pool_id } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id))
                            }
                            Event::StateChanged { ref pool_id, ref new_state } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(new_state))
                            }
                            Event::MemberRemoved { ref pool_id, ref member } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(member))
                            }
                            Event::RolesUpdated { ref root, ref bouncer, ref nominator }
                                => {
                                0_usize.saturating_add(::codec::Encode::size_hint(root)).saturating_add(::codec::Encode::size_hint(bouncer)).saturating_add(::codec::Encode::size_hint(nominator))
                            }
                            Event::PoolSlashed { ref pool_id, ref balance } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(balance))
                            }
                            Event::UnbondingPoolSlashed {
                                ref pool_id, ref era, ref balance } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(era)).saturating_add(::codec::Encode::size_hint(balance))
                            }
                            Event::PoolCommissionUpdated { ref pool_id, ref current } =>
                                {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(current))
                            }
                            Event::PoolMaxCommissionUpdated {
                                ref pool_id, ref max_commission } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(max_commission))
                            }
                            Event::PoolCommissionChangeRateUpdated {
                                ref pool_id, ref change_rate } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(change_rate))
                            }
                            Event::PoolCommissionClaimPermissionUpdated {
                                ref pool_id, ref permission } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(permission))
                            }
                            Event::PoolCommissionClaimed { ref pool_id, ref commission }
                                => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(commission))
                            }
                            Event::MinBalanceDeficitAdjusted { ref pool_id, ref amount }
                                => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(amount))
                            }
                            Event::MinBalanceExcessAdjusted { ref pool_id, ref amount }
                                => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(amount))
                            }
                            _ => 0_usize,
                        }
                }
                fn encode_to<__CodecOutputEdqy: ::codec::Output +
                    ?::core::marker::Sized>(&self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        Event::Created { ref depositor, ref pool_id } => {
                            __codec_dest_edqy.push_byte(0usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(depositor, __codec_dest_edqy);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                        }
                        Event::Bonded {
                            ref member, ref pool_id, ref bonded, ref joined } => {
                            __codec_dest_edqy.push_byte(1usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(member, __codec_dest_edqy);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(bonded, __codec_dest_edqy);
                            ::codec::Encode::encode_to(joined, __codec_dest_edqy);
                        }
                        Event::PaidOut { ref member, ref pool_id, ref payout } => {
                            __codec_dest_edqy.push_byte(2usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(member, __codec_dest_edqy);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(payout, __codec_dest_edqy);
                        }
                        Event::Unbonded {
                            ref member, ref pool_id, ref balance, ref points, ref era }
                            => {
                            __codec_dest_edqy.push_byte(3usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(member, __codec_dest_edqy);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(balance, __codec_dest_edqy);
                            ::codec::Encode::encode_to(points, __codec_dest_edqy);
                            ::codec::Encode::encode_to(era, __codec_dest_edqy);
                        }
                        Event::Withdrawn {
                            ref member, ref pool_id, ref balance, ref points } => {
                            __codec_dest_edqy.push_byte(4usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(member, __codec_dest_edqy);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(balance, __codec_dest_edqy);
                            ::codec::Encode::encode_to(points, __codec_dest_edqy);
                        }
                        Event::Destroyed { ref pool_id } => {
                            __codec_dest_edqy.push_byte(5usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                        }
                        Event::StateChanged { ref pool_id, ref new_state } => {
                            __codec_dest_edqy.push_byte(6usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(new_state, __codec_dest_edqy);
                        }
                        Event::MemberRemoved { ref pool_id, ref member } => {
                            __codec_dest_edqy.push_byte(7usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(member, __codec_dest_edqy);
                        }
                        Event::RolesUpdated { ref root, ref bouncer, ref nominator }
                            => {
                            __codec_dest_edqy.push_byte(8usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(root, __codec_dest_edqy);
                            ::codec::Encode::encode_to(bouncer, __codec_dest_edqy);
                            ::codec::Encode::encode_to(nominator, __codec_dest_edqy);
                        }
                        Event::PoolSlashed { ref pool_id, ref balance } => {
                            __codec_dest_edqy.push_byte(9usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(balance, __codec_dest_edqy);
                        }
                        Event::UnbondingPoolSlashed {
                            ref pool_id, ref era, ref balance } => {
                            __codec_dest_edqy.push_byte(10usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(era, __codec_dest_edqy);
                            ::codec::Encode::encode_to(balance, __codec_dest_edqy);
                        }
                        Event::PoolCommissionUpdated { ref pool_id, ref current } =>
                            {
                            __codec_dest_edqy.push_byte(11usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(current, __codec_dest_edqy);
                        }
                        Event::PoolMaxCommissionUpdated {
                            ref pool_id, ref max_commission } => {
                            __codec_dest_edqy.push_byte(12usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(max_commission,
                                __codec_dest_edqy);
                        }
                        Event::PoolCommissionChangeRateUpdated {
                            ref pool_id, ref change_rate } => {
                            __codec_dest_edqy.push_byte(13usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(change_rate, __codec_dest_edqy);
                        }
                        Event::PoolCommissionClaimPermissionUpdated {
                            ref pool_id, ref permission } => {
                            __codec_dest_edqy.push_byte(14usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(permission, __codec_dest_edqy);
                        }
                        Event::PoolCommissionClaimed { ref pool_id, ref commission }
                            => {
                            __codec_dest_edqy.push_byte(15usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(commission, __codec_dest_edqy);
                        }
                        Event::MinBalanceDeficitAdjusted { ref pool_id, ref amount }
                            => {
                            __codec_dest_edqy.push_byte(16usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(amount, __codec_dest_edqy);
                        }
                        Event::MinBalanceExcessAdjusted { ref pool_id, ref amount }
                            => {
                            __codec_dest_edqy.push_byte(17usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(amount, __codec_dest_edqy);
                        }
                        _ => (),
                    }
                }
            }
            #[automatically_derived]
            impl<T: Config> ::codec::EncodeLike for Event<T> where
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                T::AccountId: ::codec::Encode, T::AccountId: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                Option<T::AccountId>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                Option<(Perbill, T::AccountId)>: ::codec::Encode,
                Option<(Perbill, T::AccountId)>: ::codec::Encode,
                CommissionChangeRate<BlockNumberFor<T>>: ::codec::Encode,
                CommissionChangeRate<BlockNumberFor<T>>: ::codec::Encode,
                Option<CommissionClaimPermission<T::AccountId>>: ::codec::Encode,
                Option<CommissionClaimPermission<T::AccountId>>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode,
                BalanceOf<T>: ::codec::Encode, BalanceOf<T>: ::codec::Encode {
            }
        };
    #[allow(deprecated)]
    const _: () =
        {
            #[automatically_derived]
            impl<T: Config> ::codec::Decode for Event<T> where
                T::AccountId: ::codec::Decode, T::AccountId: ::codec::Decode,
                T::AccountId: ::codec::Decode, T::AccountId: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
                T::AccountId: ::codec::Decode, T::AccountId: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
                T::AccountId: ::codec::Decode, T::AccountId: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
                T::AccountId: ::codec::Decode, T::AccountId: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
                T::AccountId: ::codec::Decode, T::AccountId: ::codec::Decode,
                Option<T::AccountId>: ::codec::Decode,
                Option<T::AccountId>: ::codec::Decode,
                Option<T::AccountId>: ::codec::Decode,
                Option<T::AccountId>: ::codec::Decode,
                Option<T::AccountId>: ::codec::Decode,
                Option<T::AccountId>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
                Option<(Perbill, T::AccountId)>: ::codec::Decode,
                Option<(Perbill, T::AccountId)>: ::codec::Decode,
                CommissionChangeRate<BlockNumberFor<T>>: ::codec::Decode,
                CommissionChangeRate<BlockNumberFor<T>>: ::codec::Decode,
                Option<CommissionClaimPermission<T::AccountId>>: ::codec::Decode,
                Option<CommissionClaimPermission<T::AccountId>>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode,
                BalanceOf<T>: ::codec::Decode, BalanceOf<T>: ::codec::Decode {
                fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                        &mut __CodecInputEdqy)
                    -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy.read_byte().map_err(|e|
                                    e.chain("Could not decode `Event`, failed to read variant byte"))?
                        {
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 0usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::Created {
                                                        depositor: {
                                                            let __codec_res_edqy =
                                                                <T::AccountId as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Created::depositor`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Created::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 1usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::Bonded {
                                                        member: {
                                                            let __codec_res_edqy =
                                                                <T::AccountId as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Bonded::member`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Bonded::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        bonded: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Bonded::bonded`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        joined: {
                                                            let __codec_res_edqy =
                                                                <bool as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Bonded::joined`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 2usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::PaidOut {
                                                        member: {
                                                            let __codec_res_edqy =
                                                                <T::AccountId as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PaidOut::member`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PaidOut::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        payout: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PaidOut::payout`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 3usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::Unbonded {
                                                        member: {
                                                            let __codec_res_edqy =
                                                                <T::AccountId as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Unbonded::member`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Unbonded::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        balance: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Unbonded::balance`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        points: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Unbonded::points`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        era: {
                                                            let __codec_res_edqy =
                                                                <EraIndex as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Unbonded::era`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 4usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::Withdrawn {
                                                        member: {
                                                            let __codec_res_edqy =
                                                                <T::AccountId as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Withdrawn::member`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Withdrawn::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        balance: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Withdrawn::balance`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        points: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Withdrawn::points`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 5usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::Destroyed {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::Destroyed::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 6usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::StateChanged {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::StateChanged::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        new_state: {
                                                            let __codec_res_edqy =
                                                                <PoolState as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::StateChanged::new_state`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 7usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::MemberRemoved {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::MemberRemoved::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        member: {
                                                            let __codec_res_edqy =
                                                                <T::AccountId as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::MemberRemoved::member`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 8usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::RolesUpdated {
                                                        root: {
                                                            let __codec_res_edqy =
                                                                <Option<T::AccountId> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::RolesUpdated::root`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        bouncer: {
                                                            let __codec_res_edqy =
                                                                <Option<T::AccountId> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::RolesUpdated::bouncer`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        nominator: {
                                                            let __codec_res_edqy =
                                                                <Option<T::AccountId> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::RolesUpdated::nominator`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 9usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::PoolSlashed {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolSlashed::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        balance: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolSlashed::balance`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 10usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::UnbondingPoolSlashed {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::UnbondingPoolSlashed::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        era: {
                                                            let __codec_res_edqy =
                                                                <EraIndex as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::UnbondingPoolSlashed::era`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        balance: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::UnbondingPoolSlashed::balance`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 11usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::PoolCommissionUpdated {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolCommissionUpdated::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        current: {
                                                            let __codec_res_edqy =
                                                                <Option<(Perbill, T::AccountId)> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolCommissionUpdated::current`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 12usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::PoolMaxCommissionUpdated {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolMaxCommissionUpdated::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        max_commission: {
                                                            let __codec_res_edqy =
                                                                <Perbill as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolMaxCommissionUpdated::max_commission`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 13usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::PoolCommissionChangeRateUpdated {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolCommissionChangeRateUpdated::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        change_rate: {
                                                            let __codec_res_edqy =
                                                                <CommissionChangeRate<BlockNumberFor<T>> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolCommissionChangeRateUpdated::change_rate`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 14usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::PoolCommissionClaimPermissionUpdated {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolCommissionClaimPermissionUpdated::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        permission: {
                                                            let __codec_res_edqy =
                                                                <Option<CommissionClaimPermission<T::AccountId>> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolCommissionClaimPermissionUpdated::permission`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 15usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::PoolCommissionClaimed {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolCommissionClaimed::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        commission: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::PoolCommissionClaimed::commission`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 16usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::MinBalanceDeficitAdjusted {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::MinBalanceDeficitAdjusted::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        amount: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::MinBalanceDeficitAdjusted::amount`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 17usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Event::<T>::MinBalanceExcessAdjusted {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::MinBalanceExcessAdjusted::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        amount: {
                                                            let __codec_res_edqy =
                                                                <BalanceOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Event::MinBalanceExcessAdjusted::amount`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                        _ => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Err(<_ as
                                                            ::core::convert::Into<_>>::into("Could not decode `Event`, variant doesn't exist"))
                                            })();
                        }
                    }
                }
            }
        };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            impl<T: Config> ::scale_info::TypeInfo for Event<T> where
                T::AccountId: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                Option<T::AccountId>: ::scale_info::TypeInfo + 'static,
                Option<T::AccountId>: ::scale_info::TypeInfo + 'static,
                Option<T::AccountId>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                Option<(Perbill, T::AccountId)>: ::scale_info::TypeInfo +
                'static,
                CommissionChangeRate<BlockNumberFor<T>>: ::scale_info::TypeInfo +
                'static,
                Option<CommissionClaimPermission<T::AccountId>>: ::scale_info::TypeInfo +
                'static, BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::TypeInfo + 'static,
                frame_support::__private::sp_std::marker::PhantomData<(T)>: ::scale_info::TypeInfo +
                'static, T: Config + 'static {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("Event",
                                        "pallet_nomination_pools::pallet",
                                        &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                    ::core::option::Option::None)]))).docs_always(&["Events of this pallet."]).variant(::scale_info::build::Variants::new().variant("Created",
                                                                                                |v|
                                                                                                    v.index(0usize as
                                                                                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                        f.ty::<T::AccountId>().name("depositor").type_name("T::AccountId")).field(|f|
                                                                                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId"))).docs_always(&["A pool has been created."])).variant("Bonded",
                                                                                            |v|
                                                                                                v.index(1usize as
                                                                                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                            f.ty::<T::AccountId>().name("member").type_name("T::AccountId")).field(|f|
                                                                                                                        f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                                                    f.ty::<BalanceOf<T>>().name("bonded").type_name("BalanceOf<T>")).field(|f|
                                                                                                                f.ty::<bool>().name("joined").type_name("bool"))).docs_always(&["A member has became bonded in a pool."])).variant("PaidOut",
                                                                                        |v|
                                                                                            v.index(2usize as
                                                                                                            ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                    f.ty::<T::AccountId>().name("member").type_name("T::AccountId")).field(|f|
                                                                                                                f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                                            f.ty::<BalanceOf<T>>().name("payout").type_name("BalanceOf<T>"))).docs_always(&["A payout has been made to a member."])).variant("Unbonded",
                                                                                    |v|
                                                                                        v.index(3usize as
                                                                                                        ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                        f.ty::<T::AccountId>().name("member").type_name("T::AccountId")).field(|f|
                                                                                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                                                f.ty::<BalanceOf<T>>().name("balance").type_name("BalanceOf<T>")).field(|f|
                                                                                                            f.ty::<BalanceOf<T>>().name("points").type_name("BalanceOf<T>")).field(|f|
                                                                                                        f.ty::<EraIndex>().name("era").type_name("EraIndex"))).docs_always(&["A member has unbonded from their pool.",
                                                                                                        "",
                                                                                                        "- `balance` is the corresponding balance of the number of points that has been",
                                                                                                        "  requested to be unbonded (the argument of the `unbond` transaction) from the bonded",
                                                                                                        "  pool.",
                                                                                                        "- `points` is the number of points that are issued as a result of `balance` being",
                                                                                                        "dissolved into the corresponding unbonding pool.",
                                                                                                        "- `era` is the era in which the balance will be unbonded.",
                                                                                                        "In the absence of slashing, these values will match. In the presence of slashing, the",
                                                                                                        "number of points that are issued in the unbonding pool will be less than the amount",
                                                                                                        "requested to be unbonded."])).variant("Withdrawn",
                                                                                |v|
                                                                                    v.index(4usize as
                                                                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                f.ty::<T::AccountId>().name("member").type_name("T::AccountId")).field(|f|
                                                                                                            f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                                        f.ty::<BalanceOf<T>>().name("balance").type_name("BalanceOf<T>")).field(|f|
                                                                                                    f.ty::<BalanceOf<T>>().name("points").type_name("BalanceOf<T>"))).docs_always(&["A member has withdrawn from their pool.",
                                                                                                    "",
                                                                                                    "The given number of `points` have been dissolved in return of `balance`.",
                                                                                                    "",
                                                                                                    "Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance",
                                                                                                    "will be 1."])).variant("Destroyed",
                                                                            |v|
                                                                                v.index(5usize as
                                                                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                f.ty::<PoolId>().name("pool_id").type_name("PoolId"))).docs_always(&["A pool has been destroyed."])).variant("StateChanged",
                                                                        |v|
                                                                            v.index(6usize as
                                                                                            ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                            f.ty::<PoolState>().name("new_state").type_name("PoolState"))).docs_always(&["The state of a pool has changed"])).variant("MemberRemoved",
                                                                    |v|
                                                                        v.index(7usize as
                                                                                        ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                            f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                        f.ty::<T::AccountId>().name("member").type_name("T::AccountId"))).docs_always(&["A member has been removed from a pool.",
                                                                                        "",
                                                                                        "The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked)."])).variant("RolesUpdated",
                                                                |v|
                                                                    v.index(8usize as
                                                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                            f.ty::<Option<T::AccountId>>().name("root").type_name("Option<T::AccountId>")).field(|f|
                                                                                        f.ty::<Option<T::AccountId>>().name("bouncer").type_name("Option<T::AccountId>")).field(|f|
                                                                                    f.ty::<Option<T::AccountId>>().name("nominator").type_name("Option<T::AccountId>"))).docs_always(&["The roles of a pool have been updated to the given new roles. Note that the depositor",
                                                                                    "can never change."])).variant("PoolSlashed",
                                                            |v|
                                                                v.index(9usize as
                                                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                f.ty::<BalanceOf<T>>().name("balance").type_name("BalanceOf<T>"))).docs_always(&["The active balance of pool `pool_id` has been slashed to `balance`."])).variant("UnbondingPoolSlashed",
                                                        |v|
                                                            v.index(10usize as
                                                                            ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                f.ty::<EraIndex>().name("era").type_name("EraIndex")).field(|f|
                                                                            f.ty::<BalanceOf<T>>().name("balance").type_name("BalanceOf<T>"))).docs_always(&["The unbond pool at `era` of pool `pool_id` has been slashed to `balance`."])).variant("PoolCommissionUpdated",
                                                    |v|
                                                        v.index(11usize as
                                                                        ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                            f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                        f.ty::<Option<(Perbill,
                                                                                    T::AccountId)>>().name("current").type_name("Option<(Perbill, T::AccountId)>"))).docs_always(&["A pool's commission setting has been changed."])).variant("PoolMaxCommissionUpdated",
                                                |v|
                                                    v.index(12usize as
                                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                        f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                    f.ty::<Perbill>().name("max_commission").type_name("Perbill"))).docs_always(&["A pool's maximum commission setting has been changed."])).variant("PoolCommissionChangeRateUpdated",
                                            |v|
                                                v.index(13usize as
                                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                f.ty::<CommissionChangeRate<BlockNumberFor<T>>>().name("change_rate").type_name("CommissionChangeRate<BlockNumberFor<T>>"))).docs_always(&["A pool's commission `change_rate` has been changed."])).variant("PoolCommissionClaimPermissionUpdated",
                                        |v|
                                            v.index(14usize as
                                                            ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                            f.ty::<Option<CommissionClaimPermission<T::AccountId>>>().name("permission").type_name("Option<CommissionClaimPermission<T::AccountId>>"))).docs_always(&["Pool commission claim permission has been updated."])).variant("PoolCommissionClaimed",
                                    |v|
                                        v.index(15usize as
                                                        ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                            f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                        f.ty::<BalanceOf<T>>().name("commission").type_name("BalanceOf<T>"))).docs_always(&["Pool commission has been claimed."])).variant("MinBalanceDeficitAdjusted",
                                |v|
                                    v.index(16usize as
                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                        f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                    f.ty::<BalanceOf<T>>().name("amount").type_name("BalanceOf<T>"))).docs_always(&["Topped up deficit in frozen ED of the reward pool."])).variant("MinBalanceExcessAdjusted",
                            |v|
                                v.index(17usize as
                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                f.ty::<BalanceOf<T>>().name("amount").type_name("BalanceOf<T>"))).docs_always(&["Claimed excess frozen ED of af the reward pool."])))
                }
            }
            ;
        };
    #[scale_info(skip_type_params(T), capture_docs = "always")]
    #[doc = "The `Error` enum of this pallet."]
    pub enum Error<T> {

        #[doc(hidden)]
        #[codec(skip)]
        __Ignore(frame_support::__private::sp_std::marker::PhantomData<(T)>,
            frame_support::Never),

        #[doc = " A (bonded) pool id does not exist."]
        PoolNotFound,

        #[doc = " An account is not a member."]
        PoolMemberNotFound,

        #[doc =
        " A reward pool does not exist. In all cases this is a system logic error."]
        RewardPoolNotFound,

        #[doc = " A sub pool does not exist."]
        SubPoolsNotFound,

        #[doc =
        " An account is already delegating in another pool. An account may only belong to one"]
        #[doc = " pool at a time."]
        AccountBelongsToOtherPool,

        #[doc =
        " The member is fully unbonded (and thus cannot access the bonded and reward pool"]
        #[doc = " anymore to, for example, collect rewards)."]
        FullyUnbonding,

        #[doc =
        " The member cannot unbond further chunks due to reaching the limit."]
        MaxUnbondingLimit,

        #[doc =
        " None of the funds can be withdrawn yet because the bonding duration has not passed."]
        CannotWithdrawAny,

        #[doc =
        " The amount does not meet the minimum bond to either join or create a pool."]
        #[doc = ""]
        #[doc =
        " The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The"]
        #[doc =
        " caller does not have nominating permissions for the pool. Members can never unbond to a"]
        #[doc = " value below `MinJoinBond`."]
        MinimumBondNotMet,

        #[doc =
        " The transaction could not be executed due to overflow risk for the pool."]
        OverflowRisk,

        #[doc =
        " A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for"]
        #[doc = " other members to be permissionlessly unbonded."]
        NotDestroying,

        #[doc =
        " The caller does not have nominating permissions for the pool."]
        NotNominator,

        #[doc =
        " Either a) the caller cannot make a valid kick or b) the pool is not destroying."]
        NotKickerOrDestroying,

        #[doc = " The pool is not open to join"]
        NotOpen,

        #[doc = " The system is maxed out on pools."]
        MaxPools,

        #[doc = " Too many members in the pool or system."]
        MaxPoolMembers,

        #[doc = " The pools state cannot be changed."]
        CanNotChangeState,

        #[doc = " The caller does not have adequate permissions."]
        DoesNotHavePermission,

        #[doc = " Metadata exceeds [`Config::MaxMetadataLen`]"]
        MetadataExceedsMaxLen,

        #[doc =
        " Some error occurred that should never happen. This should be reported to the"]
        #[doc = " maintainers."]
        Defensive(DefensiveError),

        #[doc = " Partial unbonding now allowed permissionlessly."]
        PartialUnbondNotAllowedPermissionlessly,

        #[doc =
        " The pool\'s max commission cannot be set higher than the existing value."]
        MaxCommissionRestricted,

        #[doc =
        " The supplied commission exceeds the max allowed commission."]
        CommissionExceedsMaximum,

        #[doc = " The supplied commission exceeds global maximum commission."]
        CommissionExceedsGlobalMaximum,

        #[doc =
        " Not enough blocks have surpassed since the last commission update."]
        CommissionChangeThrottled,

        #[doc =
        " The submitted changes to commission change rate are not allowed."]
        CommissionChangeRateNotAllowed,

        #[doc = " There is no pending commission to claim."]
        NoPendingCommission,

        #[doc = " No commission current has been set."]
        NoCommissionCurrentSet,

        #[doc = " Pool id currently in use."]
        PoolIdInUse,

        #[doc = " Pool id provided is not correct/usable."]
        InvalidPoolId,

        #[doc =
        " Bonding extra is restricted to the exact pending reward amount."]
        BondExtraRestricted,

        #[doc = " No imbalance in the ED deposit for the pool."]
        NothingToAdjust,
    }
    #[allow(deprecated)]
    const _: () =
        {
            #[automatically_derived]
            impl<T> ::codec::Encode for Error<T> {
                fn size_hint(&self) -> usize {
                    1_usize +
                        match *self {
                            Error::PoolNotFound => { 0_usize }
                            Error::PoolMemberNotFound => { 0_usize }
                            Error::RewardPoolNotFound => { 0_usize }
                            Error::SubPoolsNotFound => { 0_usize }
                            Error::AccountBelongsToOtherPool => { 0_usize }
                            Error::FullyUnbonding => { 0_usize }
                            Error::MaxUnbondingLimit => { 0_usize }
                            Error::CannotWithdrawAny => { 0_usize }
                            Error::MinimumBondNotMet => { 0_usize }
                            Error::OverflowRisk => { 0_usize }
                            Error::NotDestroying => { 0_usize }
                            Error::NotNominator => { 0_usize }
                            Error::NotKickerOrDestroying => { 0_usize }
                            Error::NotOpen => { 0_usize }
                            Error::MaxPools => { 0_usize }
                            Error::MaxPoolMembers => { 0_usize }
                            Error::CanNotChangeState => { 0_usize }
                            Error::DoesNotHavePermission => { 0_usize }
                            Error::MetadataExceedsMaxLen => { 0_usize }
                            Error::Defensive(ref aa) => {
                                0_usize.saturating_add(::codec::Encode::size_hint(aa))
                            }
                            Error::PartialUnbondNotAllowedPermissionlessly => {
                                0_usize
                            }
                            Error::MaxCommissionRestricted => { 0_usize }
                            Error::CommissionExceedsMaximum => { 0_usize }
                            Error::CommissionExceedsGlobalMaximum => { 0_usize }
                            Error::CommissionChangeThrottled => { 0_usize }
                            Error::CommissionChangeRateNotAllowed => { 0_usize }
                            Error::NoPendingCommission => { 0_usize }
                            Error::NoCommissionCurrentSet => { 0_usize }
                            Error::PoolIdInUse => { 0_usize }
                            Error::InvalidPoolId => { 0_usize }
                            Error::BondExtraRestricted => { 0_usize }
                            Error::NothingToAdjust => { 0_usize }
                            _ => 0_usize,
                        }
                }
                fn encode_to<__CodecOutputEdqy: ::codec::Output +
                    ?::core::marker::Sized>(&self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        Error::PoolNotFound => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(0usize as
                                    ::core::primitive::u8);
                        }
                        Error::PoolMemberNotFound => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(1usize as
                                    ::core::primitive::u8);
                        }
                        Error::RewardPoolNotFound => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(2usize as
                                    ::core::primitive::u8);
                        }
                        Error::SubPoolsNotFound => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(3usize as
                                    ::core::primitive::u8);
                        }
                        Error::AccountBelongsToOtherPool => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(4usize as
                                    ::core::primitive::u8);
                        }
                        Error::FullyUnbonding => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(5usize as
                                    ::core::primitive::u8);
                        }
                        Error::MaxUnbondingLimit => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(6usize as
                                    ::core::primitive::u8);
                        }
                        Error::CannotWithdrawAny => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(7usize as
                                    ::core::primitive::u8);
                        }
                        Error::MinimumBondNotMet => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(8usize as
                                    ::core::primitive::u8);
                        }
                        Error::OverflowRisk => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(9usize as
                                    ::core::primitive::u8);
                        }
                        Error::NotDestroying => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(10usize as
                                    ::core::primitive::u8);
                        }
                        Error::NotNominator => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(11usize as
                                    ::core::primitive::u8);
                        }
                        Error::NotKickerOrDestroying => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(12usize as
                                    ::core::primitive::u8);
                        }
                        Error::NotOpen => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(13usize as
                                    ::core::primitive::u8);
                        }
                        Error::MaxPools => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(14usize as
                                    ::core::primitive::u8);
                        }
                        Error::MaxPoolMembers => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(15usize as
                                    ::core::primitive::u8);
                        }
                        Error::CanNotChangeState => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(16usize as
                                    ::core::primitive::u8);
                        }
                        Error::DoesNotHavePermission => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(17usize as
                                    ::core::primitive::u8);
                        }
                        Error::MetadataExceedsMaxLen => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(18usize as
                                    ::core::primitive::u8);
                        }
                        Error::Defensive(ref aa) => {
                            __codec_dest_edqy.push_byte(19usize as
                                    ::core::primitive::u8);
                            ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                        }
                        Error::PartialUnbondNotAllowedPermissionlessly => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(20usize as
                                    ::core::primitive::u8);
                        }
                        Error::MaxCommissionRestricted => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(21usize as
                                    ::core::primitive::u8);
                        }
                        Error::CommissionExceedsMaximum => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(22usize as
                                    ::core::primitive::u8);
                        }
                        Error::CommissionExceedsGlobalMaximum => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(23usize as
                                    ::core::primitive::u8);
                        }
                        Error::CommissionChangeThrottled => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(24usize as
                                    ::core::primitive::u8);
                        }
                        Error::CommissionChangeRateNotAllowed => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(25usize as
                                    ::core::primitive::u8);
                        }
                        Error::NoPendingCommission => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(26usize as
                                    ::core::primitive::u8);
                        }
                        Error::NoCommissionCurrentSet => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(27usize as
                                    ::core::primitive::u8);
                        }
                        Error::PoolIdInUse => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(28usize as
                                    ::core::primitive::u8);
                        }
                        Error::InvalidPoolId => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(29usize as
                                    ::core::primitive::u8);
                        }
                        Error::BondExtraRestricted => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(30usize as
                                    ::core::primitive::u8);
                        }
                        Error::NothingToAdjust => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(31usize as
                                    ::core::primitive::u8);
                        }
                        _ => (),
                    }
                }
            }
            #[automatically_derived]
            impl<T> ::codec::EncodeLike for Error<T> { }
        };
    #[allow(deprecated)]
    const _: () =
        {
            #[automatically_derived]
            impl<T> ::codec::Decode for Error<T> {
                fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                        &mut __CodecInputEdqy)
                    -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy.read_byte().map_err(|e|
                                    e.chain("Could not decode `Error`, failed to read variant byte"))?
                        {
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 0usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            { ::core::result::Result::Ok(Error::<T>::PoolNotFound) })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 1usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::PoolMemberNotFound)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 2usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::RewardPoolNotFound)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 3usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::SubPoolsNotFound)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 4usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::AccountBelongsToOtherPool)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 5usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::FullyUnbonding)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 6usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::MaxUnbondingLimit)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 7usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::CannotWithdrawAny)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 8usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::MinimumBondNotMet)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 9usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            { ::core::result::Result::Ok(Error::<T>::OverflowRisk) })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 10usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::NotDestroying)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 11usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            { ::core::result::Result::Ok(Error::<T>::NotNominator) })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 12usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::NotKickerOrDestroying)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 13usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            { ::core::result::Result::Ok(Error::<T>::NotOpen) })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 14usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            { ::core::result::Result::Ok(Error::<T>::MaxPools) })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 15usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::MaxPoolMembers)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 16usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::CanNotChangeState)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 17usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::DoesNotHavePermission)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 18usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::MetadataExceedsMaxLen)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 19usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::Defensive({
                                                            let __codec_res_edqy =
                                                                <DefensiveError as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Error::Defensive.0`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        }))
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 20usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::PartialUnbondNotAllowedPermissionlessly)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 21usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::MaxCommissionRestricted)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 22usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::CommissionExceedsMaximum)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 23usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::CommissionExceedsGlobalMaximum)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 24usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::CommissionChangeThrottled)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 25usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::CommissionChangeRateNotAllowed)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 26usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::NoPendingCommission)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 27usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::NoCommissionCurrentSet)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 28usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            { ::core::result::Result::Ok(Error::<T>::PoolIdInUse) })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 29usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::InvalidPoolId)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 30usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::BondExtraRestricted)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 31usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Error::<T>::NothingToAdjust)
                                            })();
                        }
                        _ => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Err(<_ as
                                                            ::core::convert::Into<_>>::into("Could not decode `Error`, variant doesn't exist"))
                                            })();
                        }
                    }
                }
            }
        };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            impl<T> ::scale_info::TypeInfo for Error<T> where
                frame_support::__private::sp_std::marker::PhantomData<(T)>: ::scale_info::TypeInfo +
                'static, T: 'static {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("Error",
                                        "pallet_nomination_pools::pallet",
                                        &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                    ::core::option::Option::None)]))).docs_always(&["The `Error` enum of this pallet."]).variant(::scale_info::build::Variants::new().variant("PoolNotFound",
                                                                                                                                                        |v|
                                                                                                                                                            v.index(0usize as
                                                                                                                                                                        ::core::primitive::u8).docs_always(&["A (bonded) pool id does not exist."])).variant("PoolMemberNotFound",
                                                                                                                                                    |v|
                                                                                                                                                        v.index(1usize as
                                                                                                                                                                    ::core::primitive::u8).docs_always(&["An account is not a member."])).variant("RewardPoolNotFound",
                                                                                                                                                |v|
                                                                                                                                                    v.index(2usize as
                                                                                                                                                                ::core::primitive::u8).docs_always(&["A reward pool does not exist. In all cases this is a system logic error."])).variant("SubPoolsNotFound",
                                                                                                                                            |v|
                                                                                                                                                v.index(3usize as
                                                                                                                                                            ::core::primitive::u8).docs_always(&["A sub pool does not exist."])).variant("AccountBelongsToOtherPool",
                                                                                                                                        |v|
                                                                                                                                            v.index(4usize as
                                                                                                                                                        ::core::primitive::u8).docs_always(&["An account is already delegating in another pool. An account may only belong to one",
                                                                                                                                                            "pool at a time."])).variant("FullyUnbonding",
                                                                                                                                    |v|
                                                                                                                                        v.index(5usize as
                                                                                                                                                    ::core::primitive::u8).docs_always(&["The member is fully unbonded (and thus cannot access the bonded and reward pool",
                                                                                                                                                        "anymore to, for example, collect rewards)."])).variant("MaxUnbondingLimit",
                                                                                                                                |v|
                                                                                                                                    v.index(6usize as
                                                                                                                                                ::core::primitive::u8).docs_always(&["The member cannot unbond further chunks due to reaching the limit."])).variant("CannotWithdrawAny",
                                                                                                                            |v|
                                                                                                                                v.index(7usize as
                                                                                                                                            ::core::primitive::u8).docs_always(&["None of the funds can be withdrawn yet because the bonding duration has not passed."])).variant("MinimumBondNotMet",
                                                                                                                        |v|
                                                                                                                            v.index(8usize as
                                                                                                                                        ::core::primitive::u8).docs_always(&["The amount does not meet the minimum bond to either join or create a pool.",
                                                                                                                                            "",
                                                                                                                                            "The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The",
                                                                                                                                            "caller does not have nominating permissions for the pool. Members can never unbond to a",
                                                                                                                                            "value below `MinJoinBond`."])).variant("OverflowRisk",
                                                                                                                    |v|
                                                                                                                        v.index(9usize as
                                                                                                                                    ::core::primitive::u8).docs_always(&["The transaction could not be executed due to overflow risk for the pool."])).variant("NotDestroying",
                                                                                                                |v|
                                                                                                                    v.index(10usize as
                                                                                                                                ::core::primitive::u8).docs_always(&["A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for",
                                                                                                                                    "other members to be permissionlessly unbonded."])).variant("NotNominator",
                                                                                                            |v|
                                                                                                                v.index(11usize as
                                                                                                                            ::core::primitive::u8).docs_always(&["The caller does not have nominating permissions for the pool."])).variant("NotKickerOrDestroying",
                                                                                                        |v|
                                                                                                            v.index(12usize as
                                                                                                                        ::core::primitive::u8).docs_always(&["Either a) the caller cannot make a valid kick or b) the pool is not destroying."])).variant("NotOpen",
                                                                                                    |v|
                                                                                                        v.index(13usize as
                                                                                                                    ::core::primitive::u8).docs_always(&["The pool is not open to join"])).variant("MaxPools",
                                                                                                |v|
                                                                                                    v.index(14usize as
                                                                                                                ::core::primitive::u8).docs_always(&["The system is maxed out on pools."])).variant("MaxPoolMembers",
                                                                                            |v|
                                                                                                v.index(15usize as
                                                                                                            ::core::primitive::u8).docs_always(&["Too many members in the pool or system."])).variant("CanNotChangeState",
                                                                                        |v|
                                                                                            v.index(16usize as
                                                                                                        ::core::primitive::u8).docs_always(&["The pools state cannot be changed."])).variant("DoesNotHavePermission",
                                                                                    |v|
                                                                                        v.index(17usize as
                                                                                                    ::core::primitive::u8).docs_always(&["The caller does not have adequate permissions."])).variant("MetadataExceedsMaxLen",
                                                                                |v|
                                                                                    v.index(18usize as
                                                                                                ::core::primitive::u8).docs_always(&["Metadata exceeds [`Config::MaxMetadataLen`]"])).variant("Defensive",
                                                                            |v|
                                                                                v.index(19usize as
                                                                                                ::core::primitive::u8).fields(::scale_info::build::Fields::unnamed().field(|f|
                                                                                                f.ty::<DefensiveError>().type_name("DefensiveError"))).docs_always(&["Some error occurred that should never happen. This should be reported to the",
                                                                                                "maintainers."])).variant("PartialUnbondNotAllowedPermissionlessly",
                                                                        |v|
                                                                            v.index(20usize as
                                                                                        ::core::primitive::u8).docs_always(&["Partial unbonding now allowed permissionlessly."])).variant("MaxCommissionRestricted",
                                                                    |v|
                                                                        v.index(21usize as
                                                                                    ::core::primitive::u8).docs_always(&["The pool's max commission cannot be set higher than the existing value."])).variant("CommissionExceedsMaximum",
                                                                |v|
                                                                    v.index(22usize as
                                                                                ::core::primitive::u8).docs_always(&["The supplied commission exceeds the max allowed commission."])).variant("CommissionExceedsGlobalMaximum",
                                                            |v|
                                                                v.index(23usize as
                                                                            ::core::primitive::u8).docs_always(&["The supplied commission exceeds global maximum commission."])).variant("CommissionChangeThrottled",
                                                        |v|
                                                            v.index(24usize as
                                                                        ::core::primitive::u8).docs_always(&["Not enough blocks have surpassed since the last commission update."])).variant("CommissionChangeRateNotAllowed",
                                                    |v|
                                                        v.index(25usize as
                                                                    ::core::primitive::u8).docs_always(&["The submitted changes to commission change rate are not allowed."])).variant("NoPendingCommission",
                                                |v|
                                                    v.index(26usize as
                                                                ::core::primitive::u8).docs_always(&["There is no pending commission to claim."])).variant("NoCommissionCurrentSet",
                                            |v|
                                                v.index(27usize as
                                                            ::core::primitive::u8).docs_always(&["No commission current has been set."])).variant("PoolIdInUse",
                                        |v|
                                            v.index(28usize as
                                                        ::core::primitive::u8).docs_always(&["Pool id currently in use."])).variant("InvalidPoolId",
                                    |v|
                                        v.index(29usize as
                                                    ::core::primitive::u8).docs_always(&["Pool id provided is not correct/usable."])).variant("BondExtraRestricted",
                                |v|
                                    v.index(30usize as
                                                ::core::primitive::u8).docs_always(&["Bonding extra is restricted to the exact pending reward amount."])).variant("NothingToAdjust",
                            |v|
                                v.index(31usize as
                                            ::core::primitive::u8).docs_always(&["No imbalance in the ED deposit for the pool."])))
                }
            }
            ;
        };
    const _: () =
        {
            impl<T> frame_support::traits::PalletError for Error<T> {
                const MAX_ENCODED_SIZE: usize =
                    {
                        let mut size = 1_usize;
                        let mut tmp = 0_usize;
                        tmp =
                            1_usize.saturating_add(<DefensiveError as
                                    frame_support::traits::PalletError>::MAX_ENCODED_SIZE);
                        size = if tmp > size { tmp } else { size };
                        tmp = 0_usize;
                        size
                    };
            }
        };
    pub enum DefensiveError {

        #[doc = " There isn\'t enough space in the unbond pool."]
        NotEnoughSpaceInUnbondPool,

        #[doc = " A (bonded) pool id does not exist."]
        PoolNotFound,

        #[doc =
        " A reward pool does not exist. In all cases this is a system logic error."]
        RewardPoolNotFound,

        #[doc = " A sub pool does not exist."]
        SubPoolsNotFound,

        #[doc =
        " The bonded account should only be killed by the staking system when the depositor is"]
        #[doc = " withdrawing"]
        BondedStashKilledPrematurely,
    }
    #[allow(deprecated)]
    const _: () =
        {
            #[automatically_derived]
            impl ::codec::Encode for DefensiveError {
                fn size_hint(&self) -> usize {
                    1_usize +
                        match *self {
                            DefensiveError::NotEnoughSpaceInUnbondPool => { 0_usize }
                            DefensiveError::PoolNotFound => { 0_usize }
                            DefensiveError::RewardPoolNotFound => { 0_usize }
                            DefensiveError::SubPoolsNotFound => { 0_usize }
                            DefensiveError::BondedStashKilledPrematurely => { 0_usize }
                            _ => 0_usize,
                        }
                }
                fn encode_to<__CodecOutputEdqy: ::codec::Output +
                    ?::core::marker::Sized>(&self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        DefensiveError::NotEnoughSpaceInUnbondPool => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(0usize as
                                    ::core::primitive::u8);
                        }
                        DefensiveError::PoolNotFound => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(1usize as
                                    ::core::primitive::u8);
                        }
                        DefensiveError::RewardPoolNotFound => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(2usize as
                                    ::core::primitive::u8);
                        }
                        DefensiveError::SubPoolsNotFound => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(3usize as
                                    ::core::primitive::u8);
                        }
                        DefensiveError::BondedStashKilledPrematurely => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(4usize as
                                    ::core::primitive::u8);
                        }
                        _ => (),
                    }
                }
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for DefensiveError { }
        };
    #[allow(deprecated)]
    const _: () =
        {
            #[automatically_derived]
            impl ::codec::Decode for DefensiveError {
                fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                        &mut __CodecInputEdqy)
                    -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy.read_byte().map_err(|e|
                                    e.chain("Could not decode `DefensiveError`, failed to read variant byte"))?
                        {
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 0usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(DefensiveError::NotEnoughSpaceInUnbondPool)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 1usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(DefensiveError::PoolNotFound)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 2usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(DefensiveError::RewardPoolNotFound)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 3usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(DefensiveError::SubPoolsNotFound)
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 4usize as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(DefensiveError::BondedStashKilledPrematurely)
                                            })();
                        }
                        _ => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Err(<_ as
                                                            ::core::convert::Into<_>>::into("Could not decode `DefensiveError`, variant doesn't exist"))
                                            })();
                        }
                    }
                }
            }
        };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DefensiveError { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DefensiveError {
        #[inline]
        fn eq(&self, other: &DefensiveError) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            impl ::scale_info::TypeInfo for DefensiveError {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("DefensiveError",
                                    "pallet_nomination_pools::pallet",
                                    &[])).type_params(::alloc::vec::Vec::new()).variant(::scale_info::build::Variants::new().variant("NotEnoughSpaceInUnbondPool",
                                            |v|
                                                v.index(0usize as
                                                            ::core::primitive::u8).docs(&["There isn't enough space in the unbond pool."])).variant("PoolNotFound",
                                        |v|
                                            v.index(1usize as
                                                        ::core::primitive::u8).docs(&["A (bonded) pool id does not exist."])).variant("RewardPoolNotFound",
                                    |v|
                                        v.index(2usize as
                                                    ::core::primitive::u8).docs(&["A reward pool does not exist. In all cases this is a system logic error."])).variant("SubPoolsNotFound",
                                |v|
                                    v.index(3usize as
                                                ::core::primitive::u8).docs(&["A sub pool does not exist."])).variant("BondedStashKilledPrematurely",
                            |v|
                                v.index(4usize as
                                            ::core::primitive::u8).docs(&["The bonded account should only be killed by the staking system when the depositor is",
                                                "withdrawing"])))
                }
            }
            ;
        };
    const _: () =
        {
            impl frame_support::traits::PalletError for DefensiveError {
                const MAX_ENCODED_SIZE: usize = 1;
            }
        };
    impl core::fmt::Debug for DefensiveError {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::NotEnoughSpaceInUnbondPool =>
                    fmt.debug_tuple("DefensiveError::NotEnoughSpaceInUnbondPool").finish(),
                Self::PoolNotFound =>
                    fmt.debug_tuple("DefensiveError::PoolNotFound").finish(),
                Self::RewardPoolNotFound =>
                    fmt.debug_tuple("DefensiveError::RewardPoolNotFound").finish(),
                Self::SubPoolsNotFound =>
                    fmt.debug_tuple("DefensiveError::SubPoolsNotFound").finish(),
                Self::BondedStashKilledPrematurely =>
                    fmt.debug_tuple("DefensiveError::BondedStashKilledPrematurely").finish(),
                _ => Ok(()),
            }
        }
    }
    impl<T> From<DefensiveError> for Error<T> {
        fn from(e: DefensiveError) -> Error<T> { Error::<T>::Defensive(e) }
    }
    #[doc = " A reason for freezing funds."]
    pub enum FreezeReason {

        #[doc =
        " Pool reward account is restricted from going below Existential Deposit."]
        #[codec(index = 0)]
        PoolMinBalance,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FreezeReason { }
    #[automatically_derived]
    impl ::core::clone::Clone for FreezeReason {
        #[inline]
        fn clone(&self) -> FreezeReason { *self }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FreezeReason { }
    #[automatically_derived]
    impl ::core::cmp::Eq for FreezeReason {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FreezeReason { }
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FreezeReason {
        #[inline]
        fn eq(&self, other: &FreezeReason) -> bool { true }
    }
    #[allow(deprecated)]
    const _: () =
        {
            #[automatically_derived]
            impl ::codec::Encode for FreezeReason {
                fn size_hint(&self) -> usize {
                    1_usize +
                        match *self {
                            FreezeReason::PoolMinBalance => { 0_usize }
                            _ => 0_usize,
                        }
                }
                fn encode_to<__CodecOutputEdqy: ::codec::Output +
                    ?::core::marker::Sized>(&self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        FreezeReason::PoolMinBalance => {

                            #[allow(clippy :: unnecessary_cast)]
                            __codec_dest_edqy.push_byte(0u8 as ::core::primitive::u8);
                        }
                        _ => (),
                    }
                }
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for FreezeReason { }
        };
    #[allow(deprecated)]
    const _: () =
        {
            #[automatically_derived]
            impl ::codec::Decode for FreezeReason {
                fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                        &mut __CodecInputEdqy)
                    -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy.read_byte().map_err(|e|
                                    e.chain("Could not decode `FreezeReason`, failed to read variant byte"))?
                        {
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 0u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(FreezeReason::PoolMinBalance)
                                            })();
                        }
                        _ => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Err(<_ as
                                                            ::core::convert::Into<_>>::into("Could not decode `FreezeReason`, variant doesn't exist"))
                                            })();
                        }
                    }
                }
            }
        };
    const _: () =
        {
            impl ::codec::MaxEncodedLen for FreezeReason {
                fn max_encoded_len() -> ::core::primitive::usize {
                    0_usize.max(0_usize).saturating_add(1)
                }
            }
        };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            impl ::scale_info::TypeInfo for FreezeReason {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("FreezeReason",
                                        "pallet_nomination_pools::pallet",
                                        &[])).type_params(::alloc::vec::Vec::new()).docs(&["A reason for freezing funds."]).variant(::scale_info::build::Variants::new().variant("PoolMinBalance",
                            |v|
                                v.index(0u8 as
                                            ::core::primitive::u8).docs(&["Pool reward account is restricted from going below Existential Deposit."])))
                }
            }
            ;
        };
    impl core::fmt::Debug for FreezeReason {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::PoolMinBalance =>
                    fmt.debug_tuple("FreezeReason::PoolMinBalance").finish(),
                _ => Ok(()),
            }
        }
    }
    impl<T: Config> Pallet<T> {
        #[doc =
        " Stake funds with a pool. The amount to bond is transferred from the member to the"]
        #[doc = " pools account and immediately increases the pools bond."]
        #[doc = ""]
        #[doc = " # Note"]
        #[doc = ""]
        #[doc = " * An account can only be a member of a single pool."]
        #[doc = " * An account cannot join the same pool multiple times."]
        #[doc =
        " * This call will *not* dust the member account, so the member must have at least"]
        #[doc = "   `existential deposit + amount` in their account."]
        #[doc = " * Only a pool with [`PoolState::Open`] can be joined"]
        pub fn join(origin: OriginFor<T>, amount: BalanceOf<T>,
            pool_id: PoolId) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        {
                            if !(amount >= MinJoinBond::<T>::get()) {
                                    { return Err(Error::<T>::MinimumBondNotMet.into()) };
                                }
                        };
                        {
                            if !!PoolMembers::<T>::contains_key(&who) {
                                    {
                                        return Err(Error::<T>::AccountBelongsToOtherPool.into())
                                    };
                                }
                        };
                        let mut bonded_pool =
                            BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
                        bonded_pool.ok_to_join()?;
                        let mut reward_pool =
                            RewardPools::<T>::get(pool_id).defensive_ok_or::<Error<T>>(DefensiveError::RewardPoolNotFound.into())?;
                        reward_pool.update_records(pool_id, bonded_pool.points,
                                bonded_pool.commission.current())?;
                        bonded_pool.try_inc_members()?;
                        let points_issued =
                            bonded_pool.try_bond_funds(&who, amount, BondType::Later)?;
                        PoolMembers::insert(who.clone(),
                            PoolMember::<T> {
                                pool_id,
                                points: points_issued,
                                last_recorded_reward_counter: reward_pool.last_recorded_reward_counter(),
                                unbonding_eras: Default::default(),
                            });
                        Self::deposit_event(Event::<T>::Bonded {
                                member: who,
                                pool_id,
                                bonded: amount,
                                joined: true,
                            });
                        bonded_pool.put();
                        RewardPools::<T>::insert(pool_id, reward_pool);
                        Ok(())
                    })
        }
        #[doc =
        " Bond `extra` more funds from `origin` into the pool to which they already belong."]
        #[doc = ""]
        #[doc =
        " Additional funds can come from either the free balance of the account, of from the"]
        #[doc = " accumulated rewards, see [`BondExtra`]."]
        #[doc = ""]
        #[doc =
        " Bonding extra funds implies an automatic payout of all pending rewards as well."]
        #[doc =
        " See `bond_extra_other` to bond pending rewards of `other` members."]
        pub fn bond_extra(origin: OriginFor<T>,
            extra: BondExtra<BalanceOf<T>>) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        Self::do_bond_extra(who.clone(), who, extra)
                    })
        }
        #[doc =
        " A bonded member can use this to claim their payout based on the rewards that the pool"]
        #[doc =
        " has accumulated since their last claimed payout (OR since joining if this is their first"]
        #[doc =
        " time claiming rewards). The payout will be transferred to the member\'s account."]
        #[doc = ""]
        #[doc =
        " The member will earn rewards pro rata based on the members stake vs the sum of the"]
        #[doc = " members in the pools stake. Rewards do not \"expire\"."]
        #[doc = ""]
        #[doc =
        " See `claim_payout_other` to caim rewards on bahalf of some `other` pool member."]
        pub fn claim_payout(origin: OriginFor<T>) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let signer = ensure_signed(origin)?;
                        Self::do_claim_payout(signer.clone(), signer)
                    })
        }
        #[doc =
        " Unbond up to `unbonding_points` of the `member_account`\'s funds from the pool. It"]
        #[doc =
        " implicitly collects the rewards one last time, since not doing so would mean some"]
        #[doc = " rewards would be forfeited."]
        #[doc = ""]
        #[doc =
        " Under certain conditions, this call can be dispatched permissionlessly (i.e. by any"]
        #[doc = " account)."]
        #[doc = ""]
        #[doc = " # Conditions for a permissionless dispatch."]
        #[doc = ""]
        #[doc =
        " * The pool is blocked and the caller is either the root or bouncer. This is refereed to"]
        #[doc = "   as a kick."]
        #[doc =
        " * The pool is destroying and the member is not the depositor."]
        #[doc =
        " * The pool is destroying, the member is the depositor and no other members are in the"]
        #[doc = "   pool."]
        #[doc = ""]
        #[doc =
        " ## Conditions for permissioned dispatch (i.e. the caller is also the"]
        #[doc = " `member_account`):"]
        #[doc = ""]
        #[doc = " * The caller is not the depositor."]
        #[doc =
        " * The caller is the depositor, the pool is destroying and no other members are in the"]
        #[doc = "   pool."]
        #[doc = ""]
        #[doc = " # Note"]
        #[doc = ""]
        #[doc =
        " If there are too many unlocking chunks to unbond with the pool account,"]
        #[doc =
        " [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks."]
        #[doc =
        " The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]"]
        #[doc =
        " to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks"]
        #[doc =
        " are available). However, it may not be possible to release the current unlocking chunks,"]
        #[doc =
        " in which case, the result of this call will likely be the `NoMoreChunks` error from the"]
        #[doc = " staking system."]
        pub fn unbond(origin: OriginFor<T>,
            member_account: AccountIdLookupOf<T>,
            unbonding_points: BalanceOf<T>) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        let member_account = T::Lookup::lookup(member_account)?;
                        let (mut member, mut bonded_pool, mut reward_pool) =
                            Self::get_member_with_pools(&member_account)?;
                        bonded_pool.ok_to_unbond_with(&who, &member_account,
                                &member, unbonding_points)?;
                        reward_pool.update_records(bonded_pool.id,
                                bonded_pool.points, bonded_pool.commission.current())?;
                        let _ =
                            Self::do_reward_payout(&who, &mut member, &mut bonded_pool,
                                    &mut reward_pool)?;
                        let current_era = T::Staking::current_era();
                        let unbond_era =
                            T::Staking::bonding_duration().saturating_add(current_era);
                        let unbonding_balance =
                            bonded_pool.dissolve(unbonding_points);
                        T::Staking::unbond(&bonded_pool.bonded_account(),
                                unbonding_balance)?;
                        let mut sub_pools =
                            SubPoolsStorage::<T>::get(member.pool_id).unwrap_or_default().maybe_merge_pools(current_era);
                        if !sub_pools.with_era.contains_key(&unbond_era) {
                                sub_pools.with_era.try_insert(unbond_era,
                                            UnbondPool::default()).defensive_map_err::<Error<T>,
                                        _>(|_|
                                            { DefensiveError::NotEnoughSpaceInUnbondPool.into() })?;
                            }
                        let points_unbonded =
                            sub_pools.with_era.get_mut(&unbond_era).defensive_ok_or::<Error<T>>(DefensiveError::PoolNotFound.into())?.issue(unbonding_balance);
                        member.try_unbond(unbonding_points, points_unbonded,
                                unbond_era)?;
                        Self::deposit_event(Event::<T>::Unbonded {
                                member: member_account.clone(),
                                pool_id: member.pool_id,
                                points: points_unbonded,
                                balance: unbonding_balance,
                                era: unbond_era,
                            });
                        SubPoolsStorage::insert(member.pool_id, sub_pools);
                        Self::put_member_with_pools(&member_account, member,
                            bonded_pool, reward_pool);
                        Ok(())
                    })
        }
        #[doc =
        " Call `withdraw_unbonded` for the pools account. This call can be made by any account."]
        #[doc = ""]
        #[doc =
        " This is useful if there are too many unlocking chunks to call `unbond`, and some"]
        #[doc =
        " can be cleared by withdrawing. In the case there are too many unlocking chunks, the user"]
        #[doc =
        " would probably see an error like `NoMoreChunks` emitted from the staking system when"]
        #[doc = " they attempt to unbond."]
        pub fn pool_withdraw_unbonded(origin: OriginFor<T>, pool_id: PoolId,
            num_slashing_spans: u32) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let _ = ensure_signed(origin)?;
                        let pool =
                            BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
                        {
                            if !(pool.state != PoolState::Destroying) {
                                    { return Err(Error::<T>::NotDestroying.into()) };
                                }
                        };
                        pool.withdraw_from_staking(num_slashing_spans)?;
                        Ok(())
                    })
        }
        #[doc =
        " Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an"]
        #[doc = " error is returned."]
        #[doc = ""]
        #[doc =
        " Under certain conditions, this call can be dispatched permissionlessly (i.e. by any"]
        #[doc = " account)."]
        #[doc = ""]
        #[doc = " # Conditions for a permissionless dispatch"]
        #[doc = ""]
        #[doc =
        " * The pool is in destroy mode and the target is not the depositor."]
        #[doc =
        " * The target is the depositor and they are the only member in the sub pools."]
        #[doc =
        " * The pool is blocked and the caller is either the root or bouncer."]
        #[doc = ""]
        #[doc = " # Conditions for permissioned dispatch"]
        #[doc = ""]
        #[doc = " * The caller is the target and they are not the depositor."]
        #[doc = ""]
        #[doc = " # Note"]
        #[doc = ""]
        #[doc =
        " If the target is the depositor, the pool will be destroyed."]
        pub fn withdraw_unbonded(origin: OriginFor<T>,
            member_account: AccountIdLookupOf<T>, num_slashing_spans: u32)
            -> DispatchResultWithPostInfo {
            frame_support::storage::with_storage_layer(||
                    {
                        let caller = ensure_signed(origin)?;
                        let member_account = T::Lookup::lookup(member_account)?;
                        let mut member =
                            PoolMembers::<T>::get(&member_account).ok_or(Error::<T>::PoolMemberNotFound)?;
                        let current_era = T::Staking::current_era();
                        let bonded_pool =
                            BondedPool::<T>::get(member.pool_id).defensive_ok_or::<Error<T>>(DefensiveError::PoolNotFound.into())?;
                        let mut sub_pools =
                            SubPoolsStorage::<T>::get(member.pool_id).ok_or(Error::<T>::SubPoolsNotFound)?;
                        bonded_pool.ok_to_withdraw_unbonded_with(&caller,
                                &member_account)?;
                        let withdrawn_points =
                            member.withdraw_unlocked(current_era);
                        {
                            if !!withdrawn_points.is_empty() {
                                    { return Err(Error::<T>::CannotWithdrawAny.into()) };
                                }
                        };
                        let stash_killed =
                            bonded_pool.withdraw_from_staking(num_slashing_spans)?;
                        {
                            if !(!stash_killed || caller == bonded_pool.roles.depositor)
                                    {
                                    {
                                        return Err(Error::<T>::Defensive(DefensiveError::BondedStashKilledPrematurely).into())
                                    };
                                }
                        };
                        let mut sum_unlocked_points: BalanceOf<T> = Zero::zero();
                        let balance_to_unbond =
                            withdrawn_points.iter().fold(BalanceOf::<T>::zero(),
                                    |accumulator, (era, unlocked_points)|
                                        {
                                            sum_unlocked_points =
                                                sum_unlocked_points.saturating_add(*unlocked_points);
                                            if let Some(era_pool) = sub_pools.with_era.get_mut(era) {
                                                    let balance_to_unbond = era_pool.dissolve(*unlocked_points);
                                                    if era_pool.points.is_zero() {
                                                            sub_pools.with_era.remove(era);
                                                        }
                                                    accumulator.saturating_add(balance_to_unbond)
                                                } else {
                                                   accumulator.saturating_add(sub_pools.no_era.dissolve(*unlocked_points))
                                               }
                                        }).min(bonded_pool.transferable_balance());
                        T::Currency::transfer(&bonded_pool.bonded_account(),
                                    &member_account, balance_to_unbond,
                                    Preservation::Expendable).defensive()?;
                        Self::deposit_event(Event::<T>::Withdrawn {
                                member: member_account.clone(),
                                pool_id: member.pool_id,
                                points: sum_unlocked_points,
                                balance: balance_to_unbond,
                            });
                        let post_info_weight =
                            if member.total_points().is_zero() {
                                    ClaimPermissions::<T>::remove(&member_account);
                                    PoolMembers::<T>::remove(&member_account);
                                    Self::deposit_event(Event::<T>::MemberRemoved {
                                            pool_id: member.pool_id,
                                            member: member_account.clone(),
                                        });
                                    if member_account == bonded_pool.roles.depositor {
                                            Pallet::<T>::dissolve_pool(bonded_pool);
                                            None
                                        } else {
                                           bonded_pool.dec_members().put();
                                           SubPoolsStorage::<T>::insert(member.pool_id, sub_pools);
                                           Some(T::WeightInfo::withdraw_unbonded_update(num_slashing_spans))
                                       }
                                } else {
                                   SubPoolsStorage::<T>::insert(member.pool_id, sub_pools);
                                   PoolMembers::<T>::insert(&member_account, member);
                                   Some(T::WeightInfo::withdraw_unbonded_update(num_slashing_spans))
                               };
                        Ok(post_info_weight.into())
                    })
        }
        #[doc = " Create a new delegation pool."]
        #[doc = ""]
        #[doc = " # Arguments"]
        #[doc = ""]
        #[doc =
        " * `amount` - The amount of funds to delegate to the pool. This also acts of a sort of"]
        #[doc =
        "   deposit since the pools creator cannot fully unbond funds until the pool is being"]
        #[doc = "   destroyed."]
        #[doc =
        " * `index` - A disambiguation index for creating the account. Likely only useful when"]
        #[doc = "   creating multiple pools in the same extrinsic."]
        #[doc = " * `root` - The account to set as [`PoolRoles::root`]."]
        #[doc =
        " * `nominator` - The account to set as the [`PoolRoles::nominator`]."]
        #[doc =
        " * `bouncer` - The account to set as the [`PoolRoles::bouncer`]."]
        #[doc = ""]
        #[doc = " # Note"]
        #[doc = ""]
        #[doc =
        " In addition to `amount`, the caller will transfer the existential deposit; so the caller"]
        #[doc =
        " needs at have at least `amount + existential_deposit` transferable."]
        pub fn create(origin: OriginFor<T>, amount: BalanceOf<T>,
            root: AccountIdLookupOf<T>, nominator: AccountIdLookupOf<T>,
            bouncer: AccountIdLookupOf<T>) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let depositor = ensure_signed(origin)?;
                        let pool_id =
                            LastPoolId::<T>::try_mutate::<_, Error<T>,
                                        _>(|id|
                                        {
                                            *id = id.checked_add(1).ok_or(Error::<T>::OverflowRisk)?;
                                            Ok(*id)
                                        })?;
                        Self::do_create(depositor, amount, root, nominator, bouncer,
                            pool_id)
                    })
        }
        #[doc =
        " Create a new delegation pool with a previously used pool id"]
        #[doc = ""]
        #[doc = " # Arguments"]
        #[doc = ""]
        #[doc = " same as `create` with the inclusion of"]
        #[doc = " * `pool_id` - `A valid PoolId."]
        pub fn create_with_pool_id(origin: OriginFor<T>, amount: BalanceOf<T>,
            root: AccountIdLookupOf<T>, nominator: AccountIdLookupOf<T>,
            bouncer: AccountIdLookupOf<T>, pool_id: PoolId)
            -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let depositor = ensure_signed(origin)?;
                        {
                            if !!BondedPools::<T>::contains_key(pool_id) {
                                    { return Err(Error::<T>::PoolIdInUse.into()) };
                                }
                        };
                        {
                            if !(pool_id < LastPoolId::<T>::get()) {
                                    { return Err(Error::<T>::InvalidPoolId.into()) };
                                }
                        };
                        Self::do_create(depositor, amount, root, nominator, bouncer,
                            pool_id)
                    })
        }
        #[doc = " Nominate on behalf of the pool."]
        #[doc = ""]
        #[doc =
        " The dispatch origin of this call must be signed by the pool nominator or the pool"]
        #[doc = " root role."]
        #[doc = ""]
        #[doc =
        " This directly forward the call to the staking pallet, on behalf of the pool bonded"]
        #[doc = " account."]
        pub fn nominate(origin: OriginFor<T>, pool_id: PoolId,
            validators: Vec<T::AccountId>) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        let bonded_pool =
                            BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
                        {
                            if !bonded_pool.can_nominate(&who) {
                                    { return Err(Error::<T>::NotNominator.into()) };
                                }
                        };
                        T::Staking::nominate(&bonded_pool.bonded_account(),
                            validators)
                    })
        }
        #[doc = " Set a new state for the pool."]
        #[doc = ""]
        #[doc =
        " If a pool is already in the `Destroying` state, then under no condition can its state"]
        #[doc = " change again."]
        #[doc = ""]
        #[doc = " The dispatch origin of this call must be either:"]
        #[doc = ""]
        #[doc = " 1. signed by the bouncer, or the root role of the pool,"]
        #[doc =
        " 2. if the pool conditions to be open are NOT met (as described by `ok_to_be_open`), and"]
        #[doc =
        "    then the state of the pool can be permissionlessly changed to `Destroying`."]
        pub fn set_state(origin: OriginFor<T>, pool_id: PoolId,
            state: PoolState) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        let mut bonded_pool =
                            BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
                        {
                            if !(bonded_pool.state != PoolState::Destroying) {
                                    { return Err(Error::<T>::CanNotChangeState.into()) };
                                }
                        };
                        if bonded_pool.can_toggle_state(&who) {
                                bonded_pool.set_state(state);
                            } else if bonded_pool.ok_to_be_open().is_err() &&
                                   state == PoolState::Destroying {
                               bonded_pool.set_state(PoolState::Destroying);
                           } else { Err(Error::<T>::CanNotChangeState)?; }
                        bonded_pool.put();
                        Ok(())
                    })
        }
        #[doc = " Set a new metadata for the pool."]
        #[doc = ""]
        #[doc =
        " The dispatch origin of this call must be signed by the bouncer, or the root role of the"]
        #[doc = " pool."]
        pub fn set_metadata(origin: OriginFor<T>, pool_id: PoolId,
            metadata: Vec<u8>) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        let metadata: BoundedVec<_, _> =
                            metadata.try_into().map_err(|_|
                                        Error::<T>::MetadataExceedsMaxLen)?;
                        {
                            if !BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?.can_set_metadata(&who)
                                    {
                                    { return Err(Error::<T>::DoesNotHavePermission.into()) };
                                }
                        };
                        Metadata::<T>::mutate(pool_id,
                            |pool_meta| *pool_meta = metadata);
                        Ok(())
                    })
        }
        #[doc =
        " Update configurations for the nomination pools. The origin for this call must be"]
        #[doc = " Root."]
        #[doc = ""]
        #[doc = " # Arguments"]
        #[doc = ""]
        #[doc = " * `min_join_bond` - Set [`MinJoinBond`]."]
        #[doc = " * `min_create_bond` - Set [`MinCreateBond`]."]
        #[doc = " * `max_pools` - Set [`MaxPools`]."]
        #[doc = " * `max_members` - Set [`MaxPoolMembers`]."]
        #[doc = " * `max_members_per_pool` - Set [`MaxPoolMembersPerPool`]."]
        #[doc = " * `global_max_commission` - Set [`GlobalMaxCommission`]."]
        pub fn set_configs(origin: OriginFor<T>,
            min_join_bond: ConfigOp<BalanceOf<T>>,
            min_create_bond: ConfigOp<BalanceOf<T>>, max_pools: ConfigOp<u32>,
            max_members: ConfigOp<u32>, max_members_per_pool: ConfigOp<u32>,
            global_max_commission: ConfigOp<Perbill>) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        ensure_root(origin)?;
                        macro_rules! config_op_exp {
                            ($storage : ty, $op : ident) =>
                            {
                                match $op
                                {
                                    ConfigOp :: Noop => (), ConfigOp :: Set(v) => < $storage >
                                    :: put(v), ConfigOp :: Remove => < $storage > :: kill(),
                                }
                            } ;
                        }
                        match min_join_bond {
                            ConfigOp::Noop => (),
                            ConfigOp::Set(v) => <MinJoinBond<T>>::put(v),
                            ConfigOp::Remove => <MinJoinBond<T>>::kill(),
                        };
                        match min_create_bond {
                            ConfigOp::Noop => (),
                            ConfigOp::Set(v) => <MinCreateBond<T>>::put(v),
                            ConfigOp::Remove => <MinCreateBond<T>>::kill(),
                        };
                        match max_pools {
                            ConfigOp::Noop => (),
                            ConfigOp::Set(v) => <MaxPools<T>>::put(v),
                            ConfigOp::Remove => <MaxPools<T>>::kill(),
                        };
                        match max_members {
                            ConfigOp::Noop => (),
                            ConfigOp::Set(v) => <MaxPoolMembers<T>>::put(v),
                            ConfigOp::Remove => <MaxPoolMembers<T>>::kill(),
                        };
                        match max_members_per_pool {
                            ConfigOp::Noop => (),
                            ConfigOp::Set(v) => <MaxPoolMembersPerPool<T>>::put(v),
                            ConfigOp::Remove => <MaxPoolMembersPerPool<T>>::kill(),
                        };
                        match global_max_commission {
                            ConfigOp::Noop => (),
                            ConfigOp::Set(v) => <GlobalMaxCommission<T>>::put(v),
                            ConfigOp::Remove => <GlobalMaxCommission<T>>::kill(),
                        };
                        Ok(())
                    })
        }
        #[doc = " Update the roles of the pool."]
        #[doc = ""]
        #[doc =
        " The root is the only entity that can change any of the roles, including itself,"]
        #[doc = " excluding the depositor, who can never change."]
        #[doc = ""]
        #[doc =
        " It emits an event, notifying UIs of the role change. This event is quite relevant to"]
        #[doc =
        " most pool members and they should be informed of changes to pool roles."]
        pub fn update_roles(origin: OriginFor<T>, pool_id: PoolId,
            new_root: ConfigOp<T::AccountId>,
            new_nominator: ConfigOp<T::AccountId>,
            new_bouncer: ConfigOp<T::AccountId>) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let mut bonded_pool =
                            match ensure_root(origin.clone()) {
                                Ok(()) =>
                                    BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?,
                                Err(frame_support::error::BadOrigin) => {
                                    let who = ensure_signed(origin)?;
                                    let bonded_pool =
                                        BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
                                    {
                                        if !bonded_pool.can_update_roles(&who) {
                                                { return Err(Error::<T>::DoesNotHavePermission.into()) };
                                            }
                                    };
                                    bonded_pool
                                }
                            };
                        match new_root {
                            ConfigOp::Noop => (),
                            ConfigOp::Remove => bonded_pool.roles.root = None,
                            ConfigOp::Set(v) => bonded_pool.roles.root = Some(v),
                        };
                        match new_nominator {
                            ConfigOp::Noop => (),
                            ConfigOp::Remove => bonded_pool.roles.nominator = None,
                            ConfigOp::Set(v) => bonded_pool.roles.nominator = Some(v),
                        };
                        match new_bouncer {
                            ConfigOp::Noop => (),
                            ConfigOp::Remove => bonded_pool.roles.bouncer = None,
                            ConfigOp::Set(v) => bonded_pool.roles.bouncer = Some(v),
                        };
                        Self::deposit_event(Event::<T>::RolesUpdated {
                                root: bonded_pool.roles.root.clone(),
                                nominator: bonded_pool.roles.nominator.clone(),
                                bouncer: bonded_pool.roles.bouncer.clone(),
                            });
                        bonded_pool.put();
                        Ok(())
                    })
        }
        #[doc = " Chill on behalf of the pool."]
        #[doc = ""]
        #[doc =
        " The dispatch origin of this call must be signed by the pool nominator or the pool"]
        #[doc = " root role, same as [`Pallet::nominate`]."]
        #[doc = ""]
        #[doc =
        " This directly forward the call to the staking pallet, on behalf of the pool bonded"]
        #[doc = " account."]
        pub fn chill(origin: OriginFor<T>, pool_id: PoolId)
            -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        let bonded_pool =
                            BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
                        {
                            if !bonded_pool.can_nominate(&who) {
                                    { return Err(Error::<T>::NotNominator.into()) };
                                }
                        };
                        T::Staking::chill(&bonded_pool.bonded_account())
                    })
        }
        #[doc =
        " `origin` bonds funds from `extra` for some pool member `member` into their respective"]
        #[doc = " pools."]
        #[doc = ""]
        #[doc =
        " `origin` can bond extra funds from free balance or pending rewards when `origin =="]
        #[doc = " other`."]
        #[doc = ""]
        #[doc =
        " In the case of `origin != other`, `origin` can only bond extra pending rewards of"]
        #[doc =
        " `other` members assuming set_claim_permission for the given member is"]
        #[doc = " `PermissionlessAll` or `PermissionlessCompound`."]
        pub fn bond_extra_other(origin: OriginFor<T>,
            member: AccountIdLookupOf<T>, extra: BondExtra<BalanceOf<T>>)
            -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        Self::do_bond_extra(who, T::Lookup::lookup(member)?, extra)
                    })
        }
        #[doc =
        " Allows a pool member to set a claim permission to allow or disallow permissionless"]
        #[doc = " bonding and withdrawing."]
        #[doc = ""]
        #[doc =
        " By default, this is `Permissioned`, which implies only the pool member themselves can"]
        #[doc =
        " claim their pending rewards. If a pool member wishes so, they can set this to"]
        #[doc =
        " `PermissionlessAll` to allow any account to claim their rewards and bond extra to the"]
        #[doc = " pool."]
        #[doc = ""]
        #[doc = " # Arguments"]
        #[doc = ""]
        #[doc = " * `origin` - Member of a pool."]
        #[doc = " * `actor` - Account to claim reward. // improve this"]
        pub fn set_claim_permission(origin: OriginFor<T>,
            permission: ClaimPermission) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        {
                            if !PoolMembers::<T>::contains_key(&who) {
                                    { return Err(Error::<T>::PoolMemberNotFound.into()) };
                                }
                        };
                        ClaimPermissions::<T>::mutate(who,
                            |source| { *source = permission; });
                        Ok(())
                    })
        }
        #[doc =
        " `origin` can claim payouts on some pool member `other`\'s behalf."]
        #[doc = ""]
        #[doc =
        " Pool member `other` must have a `PermissionlessAll` or `PermissionlessWithdraw` in order"]
        #[doc = " for this call to be successful."]
        pub fn claim_payout_other(origin: OriginFor<T>, other: T::AccountId)
            -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let signer = ensure_signed(origin)?;
                        Self::do_claim_payout(signer, other)
                    })
        }
        #[doc = " Set the commission of a pool."]
        #[doc =
        " Both a commission percentage and a commission payee must be provided in the `current`"]
        #[doc =
        " tuple. Where a `current` of `None` is provided, any current commission will be removed."]
        #[doc = ""]
        #[doc =
        " - If a `None` is supplied to `new_commission`, existing commission will be removed."]
        pub fn set_commission(origin: OriginFor<T>, pool_id: PoolId,
            new_commission: Option<(Perbill, T::AccountId)>)
            -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        let mut bonded_pool =
                            BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
                        {
                            if !bonded_pool.can_manage_commission(&who) {
                                    { return Err(Error::<T>::DoesNotHavePermission.into()) };
                                }
                        };
                        let mut reward_pool =
                            RewardPools::<T>::get(pool_id).defensive_ok_or::<Error<T>>(DefensiveError::RewardPoolNotFound.into())?;
                        reward_pool.update_records(pool_id, bonded_pool.points,
                                bonded_pool.commission.current())?;
                        RewardPools::insert(pool_id, reward_pool);
                        bonded_pool.commission.try_update_current(&new_commission)?;
                        bonded_pool.put();
                        Self::deposit_event(Event::<T>::PoolCommissionUpdated {
                                pool_id,
                                current: new_commission,
                            });
                        Ok(())
                    })
        }
        #[doc = " Set the maximum commission of a pool."]
        #[doc = ""]
        #[doc =
        " - Initial max can be set to any `Perbill`, and only smaller values thereafter."]
        #[doc =
        " - Current commission will be lowered in the event it is higher than a new max"]
        #[doc = "   commission."]
        pub fn set_commission_max(origin: OriginFor<T>, pool_id: PoolId,
            max_commission: Perbill) -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        let mut bonded_pool =
                            BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
                        {
                            if !bonded_pool.can_manage_commission(&who) {
                                    { return Err(Error::<T>::DoesNotHavePermission.into()) };
                                }
                        };
                        bonded_pool.commission.try_update_max(pool_id,
                                max_commission)?;
                        bonded_pool.put();
                        Self::deposit_event(Event::<T>::PoolMaxCommissionUpdated {
                                pool_id,
                                max_commission,
                            });
                        Ok(())
                    })
        }
        #[doc = " Set the commission change rate for a pool."]
        #[doc = ""]
        #[doc =
        " Initial change rate is not bounded, whereas subsequent updates can only be more"]
        #[doc = " restrictive than the current."]
        pub fn set_commission_change_rate(origin: OriginFor<T>,
            pool_id: PoolId,
            change_rate: CommissionChangeRate<BlockNumberFor<T>>)
            -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        let mut bonded_pool =
                            BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
                        {
                            if !bonded_pool.can_manage_commission(&who) {
                                    { return Err(Error::<T>::DoesNotHavePermission.into()) };
                                }
                        };
                        bonded_pool.commission.try_update_change_rate(change_rate)?;
                        bonded_pool.put();
                        Self::deposit_event(Event::<T>::PoolCommissionChangeRateUpdated {
                                pool_id,
                                change_rate,
                            });
                        Ok(())
                    })
        }
        #[doc = " Claim pending commission."]
        #[doc = ""]
        #[doc =
        " The dispatch origin of this call must be signed by the `root` role of the pool. Pending"]
        #[doc =
        " commission is paid out and added to total claimed commission`. Total pending commission"]
        #[doc = " is reset to zero. the current."]
        pub fn claim_commission(origin: OriginFor<T>, pool_id: PoolId)
            -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        Self::do_claim_commission(who, pool_id)
                    })
        }
        #[doc =
        " Top up the deficit or withdraw the excess ED from the pool."]
        #[doc = ""]
        #[doc =
        " When a pool is created, the pool depositor transfers ED to the reward account of the"]
        #[doc =
        " pool. ED is subject to change and over time, the deposit in the reward account may be"]
        #[doc =
        " insufficient to cover the ED deficit of the pool or vice-versa where there is excess"]
        #[doc =
        " deposit to the pool. This call allows anyone to adjust the ED deposit of the"]
        #[doc =
        " pool by either topping up the deficit or claiming the excess."]
        pub fn adjust_pool_deposit(origin: OriginFor<T>, pool_id: PoolId)
            -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        Self::do_adjust_pool_deposit(who, pool_id)
                    })
        }
        #[doc = " Set or remove a pool\'s commission claim permission."]
        #[doc = ""]
        #[doc =
        " Determines who can claim the pool\'s pending commission. Only the `Root` role of the pool"]
        #[doc = " is able to conifigure commission claim permissions."]
        pub fn set_commission_claim_permission(origin: OriginFor<T>,
            pool_id: PoolId,
            permission: Option<CommissionClaimPermission<T::AccountId>>)
            -> DispatchResult {
            frame_support::storage::with_storage_layer(||
                    {
                        let who = ensure_signed(origin)?;
                        let mut bonded_pool =
                            BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
                        {
                            if !bonded_pool.can_manage_commission(&who) {
                                    { return Err(Error::<T>::DoesNotHavePermission.into()) };
                                }
                        };
                        bonded_pool.commission.claim_permission =
                            permission.clone();
                        bonded_pool.put();
                        Self::deposit_event(Event::<T>::PoolCommissionClaimPermissionUpdated {
                                pool_id,
                                permission,
                            });
                        Ok(())
                    })
        }
    }
    impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
        fn integrity_test() {
            if !(T::MaxPointsToBalance::get() > 0) {
                    {
                        ::core::panicking::panic_fmt(format_args!("Minimum points to balance ratio must be greater than 0"));
                    }
                };
            if !(T::Staking::bonding_duration() <
                            TotalUnbondingPools::<T>::get()) {
                    {
                        ::core::panicking::panic_fmt(format_args!("There must be more unbonding pools then the bonding duration /\n\t\t\t\tso a slash can be applied to relevant unboding pools. (We assume /\n\t\t\t\tthe bonding duration > slash deffer duration."));
                    }
                };
        }
    }
    impl<T: Config> Pallet<T> {
        #[doc(hidden)]
        pub fn pallet_documentation_metadata()
            -> frame_support::__private::sp_std::vec::Vec<&'static str> {
            ::alloc::vec::Vec::new()
        }
    }
    impl<T: Config> Pallet<T> {
        #[doc(hidden)]
        pub fn pallet_constants_metadata()
            ->
                frame_support::__private::sp_std::vec::Vec<frame_support::__private::metadata_ir::PalletConstantMetadataIR> {
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([{
                                frame_support::__private::metadata_ir::PalletConstantMetadataIR {
                                    name: "PalletId",
                                    ty: frame_support::__private::scale_info::meta_type::<frame_support::PalletId>(),
                                    value: {
                                        let value =
                                            <<T as Config>::PalletId as
                                                    frame_support::traits::Get<frame_support::PalletId>>::get();
                                        frame_support::__private::codec::Encode::encode(&value)
                                    },
                                    docs: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" The nomination pool\'s pallet id."])),
                                }
                            },
                            {
                                frame_support::__private::metadata_ir::PalletConstantMetadataIR {
                                    name: "MaxPointsToBalance",
                                    ty: frame_support::__private::scale_info::meta_type::<u8>(),
                                    value: {
                                        let value =
                                            <<T as Config>::MaxPointsToBalance as
                                                    frame_support::traits::Get<u8>>::get();
                                        frame_support::__private::codec::Encode::encode(&value)
                                    },
                                    docs: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" The maximum pool points-to-balance ratio that an `open` pool can have.",
                                                    "",
                                                    " This is important in the event slashing takes place and the pool\'s points-to-balance",
                                                    " ratio becomes disproportional.", "",
                                                    " Moreover, this relates to the `RewardCounter` type as well, as the arithmetic operations",
                                                    " are a function of number of points, and by setting this value to e.g. 10, you ensure",
                                                    " that the total number of points in the system are at most 10 times the total_issuance of",
                                                    " the chain, in the absolute worse case.", "",
                                                    " For a value of 10, the threshold would be a pool points-to-balance ratio of 10:1.",
                                                    " Such a scenario would also be the equivalent of the pool being 90% slashed."])),
                                }
                            },
                            {
                                frame_support::__private::metadata_ir::PalletConstantMetadataIR {
                                    name: "MaxUnbonding",
                                    ty: frame_support::__private::scale_info::meta_type::<u32>(),
                                    value: {
                                        let value =
                                            <<T as Config>::MaxUnbonding as
                                                    frame_support::traits::Get<u32>>::get();
                                        frame_support::__private::codec::Encode::encode(&value)
                                    },
                                    docs: <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" The maximum number of simultaneous unbonding chunks that can exist per member."])),
                                }
                            }]))
        }
    }
    impl<T: Config> Pallet<T> {
        #[doc(hidden)]
        pub fn error_metadata()
            ->
                Option<frame_support::__private::metadata_ir::PalletErrorMetadataIR> {
            Some(frame_support::__private::metadata_ir::PalletErrorMetadataIR {
                    ty: frame_support::__private::scale_info::meta_type::<Error<T>>(),
                })
        }
    }
    #[doc = r" Type alias to `Pallet`, to be used by `construct_runtime`."]
    #[doc = r""]
    #[doc = r" Generated by `pallet` attribute macro."]
    #[deprecated(note = "use `Pallet` instead")]
    #[allow(dead_code)]
    pub type Module<T> = Pallet<T>;
    impl<T: Config> frame_support::traits::GetStorageVersion for Pallet<T> {
        type CurrentStorageVersion = frame_support::traits::StorageVersion;
        fn current_storage_version() -> Self::CurrentStorageVersion {
            STORAGE_VERSION
        }
        fn on_chain_storage_version()
            -> frame_support::traits::StorageVersion {
            frame_support::traits::StorageVersion::get::<Self>()
        }
    }
    impl<T: Config> frame_support::traits::OnGenesis for Pallet<T> {
        fn on_genesis() {
            let storage_version: frame_support::traits::StorageVersion =
                STORAGE_VERSION;
            storage_version.put::<Self>();
        }
    }
    impl<T: Config> frame_support::traits::PalletInfoAccess for Pallet<T> {
        fn index() -> usize {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::index::<Self>().expect("Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime")
        }
        fn name() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Self>().expect("Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime")
        }
        fn name_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Self>().expect("Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime")
        }
        fn module_name() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::module_name::<Self>().expect("Pallet is part of the runtime because pallet `Config` trait is \
						implemented by the runtime")
        }
        fn crate_version() -> frame_support::traits::CrateVersion {
            frame_support::traits::CrateVersion {
                major: 1u16,
                minor: 0u8,
                patch: 0u8,
            }
        }
    }
    impl<T: Config> frame_support::traits::PalletsInfoAccess for Pallet<T> {
        fn count() -> usize { 1 }
        fn infos()
            ->
                frame_support::__private::sp_std::vec::Vec<frame_support::traits::PalletInfoData> {
            use frame_support::traits::PalletInfoAccess;
            let item =
                frame_support::traits::PalletInfoData {
                    index: Self::index(),
                    name: Self::name(),
                    module_name: Self::module_name(),
                    crate_version: Self::crate_version(),
                };
            <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([item]))
        }
    }
    impl<T: Config> frame_support::traits::StorageInfoTrait for Pallet<T> {
        fn storage_info()
            ->
                frame_support::__private::sp_std::vec::Vec<frame_support::traits::StorageInfo> {
            #[allow(unused_mut)]
            let mut res = ::alloc::vec::Vec::new();
            {
                let mut storage_info =
                    <TotalValueLocked<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <MinJoinBond<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <MinCreateBond<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <MaxPools<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <MaxPoolMembers<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <MaxPoolMembersPerPool<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <GlobalMaxCommission<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <PoolMembers<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <BondedPools<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <RewardPools<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <SubPoolsStorage<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <Metadata<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <LastPoolId<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <ReversePoolIdLookup<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            {
                let mut storage_info =
                    <ClaimPermissions<T> as
                            frame_support::traits::StorageInfoTrait>::storage_info();
                res.append(&mut storage_info);
            }
            res
        }
    }
    use frame_support::traits::{
        StorageInfoTrait, TrackedStorageKey, WhitelistedStorageKeys,
    };
    impl<T: Config> WhitelistedStorageKeys for Pallet<T> {
        fn whitelisted_storage_keys()
            -> frame_support::__private::sp_std::vec::Vec<TrackedStorageKey> {
            use frame_support::__private::sp_std::vec;
            ::alloc::vec::Vec::new()
        }
    }
    mod warnings {}
    #[doc(hidden)]
    pub mod __substrate_call_check {
        #[macro_export]
        #[doc(hidden)]
        macro_rules! __is_call_part_defined_0 {
            ($pallet_name : ident) => {} ;
        }
        #[doc(hidden)]
        pub use __is_call_part_defined_0 as is_call_part_defined;
    }
    #[doc =
    r"Contains a variant per dispatchable extrinsic that this pallet has."]
    #[codec(encode_bound())]
    #[codec(decode_bound())]
    #[scale_info(skip_type_params(T), capture_docs = "always")]
    #[allow(non_camel_case_types)]
    pub enum Call<T: Config> {

        #[doc(hidden)]
        #[codec(skip)]
        __Ignore(frame_support::__private::sp_std::marker::PhantomData<(T,)>,
            frame_support::Never),

        #[doc = "See [`Pallet::join`]."]
        #[codec(index = 0u8)]
        join {
            #[allow(missing_docs)]
            #[codec(compact)]
            amount: BalanceOf<T>,
            #[allow(missing_docs)]
            pool_id: PoolId,
        },

        #[doc = "See [`Pallet::bond_extra`]."]
        #[codec(index = 1u8)]
        bond_extra {
            #[allow(missing_docs)]
            extra: BondExtra<BalanceOf<T>>,
        },

        #[doc = "See [`Pallet::claim_payout`]."]
        #[codec(index = 2u8)]
        claim_payout {},

        #[doc = "See [`Pallet::unbond`]."]
        #[codec(index = 3u8)]
        unbond {
            #[allow(missing_docs)]
            member_account: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            #[codec(compact)]
            unbonding_points: BalanceOf<T>,
        },

        #[doc = "See [`Pallet::pool_withdraw_unbonded`]."]
        #[codec(index = 4u8)]
        pool_withdraw_unbonded {
            #[allow(missing_docs)]
            pool_id: PoolId,
            #[allow(missing_docs)]
            num_slashing_spans: u32,
        },

        #[doc = "See [`Pallet::withdraw_unbonded`]."]
        #[codec(index = 5u8)]
        withdraw_unbonded {
            #[allow(missing_docs)]
            member_account: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            num_slashing_spans: u32,
        },

        #[doc = "See [`Pallet::create`]."]
        #[codec(index = 6u8)]
        create {
            #[allow(missing_docs)]
            #[codec(compact)]
            amount: BalanceOf<T>,
            #[allow(missing_docs)]
            root: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            nominator: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            bouncer: AccountIdLookupOf<T>,
        },

        #[doc = "See [`Pallet::create_with_pool_id`]."]
        #[codec(index = 7u8)]
        create_with_pool_id {
            #[allow(missing_docs)]
            #[codec(compact)]
            amount: BalanceOf<T>,
            #[allow(missing_docs)]
            root: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            nominator: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            bouncer: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            pool_id: PoolId,
        },

        #[doc = "See [`Pallet::nominate`]."]
        #[codec(index = 8u8)]
        nominate {
            #[allow(missing_docs)]
            pool_id: PoolId,
            #[allow(missing_docs)]
            validators: Vec<T::AccountId>,
        },

        #[doc = "See [`Pallet::set_state`]."]
        #[codec(index = 9u8)]
        set_state {
            #[allow(missing_docs)]
            pool_id: PoolId,
            #[allow(missing_docs)]
            state: PoolState,
        },

        #[doc = "See [`Pallet::set_metadata`]."]
        #[codec(index = 10u8)]
        set_metadata {
            #[allow(missing_docs)]
            pool_id: PoolId,
            #[allow(missing_docs)]
            metadata: Vec<u8>,
        },

        #[doc = "See [`Pallet::set_configs`]."]
        #[codec(index = 11u8)]
        set_configs {
            #[allow(missing_docs)]
            min_join_bond: ConfigOp<BalanceOf<T>>,
            #[allow(missing_docs)]
            min_create_bond: ConfigOp<BalanceOf<T>>,
            #[allow(missing_docs)]
            max_pools: ConfigOp<u32>,
            #[allow(missing_docs)]
            max_members: ConfigOp<u32>,
            #[allow(missing_docs)]
            max_members_per_pool: ConfigOp<u32>,
            #[allow(missing_docs)]
            global_max_commission: ConfigOp<Perbill>,
        },

        #[doc = "See [`Pallet::update_roles`]."]
        #[codec(index = 12u8)]
        update_roles {
            #[allow(missing_docs)]
            pool_id: PoolId,
            #[allow(missing_docs)]
            new_root: ConfigOp<T::AccountId>,
            #[allow(missing_docs)]
            new_nominator: ConfigOp<T::AccountId>,
            #[allow(missing_docs)]
            new_bouncer: ConfigOp<T::AccountId>,
        },

        #[doc = "See [`Pallet::chill`]."]
        #[codec(index = 13u8)]
        chill {
            #[allow(missing_docs)]
            pool_id: PoolId,
        },

        #[doc = "See [`Pallet::bond_extra_other`]."]
        #[codec(index = 14u8)]
        bond_extra_other {
            #[allow(missing_docs)]
            member: AccountIdLookupOf<T>,
            #[allow(missing_docs)]
            extra: BondExtra<BalanceOf<T>>,
        },

        #[doc = "See [`Pallet::set_claim_permission`]."]
        #[codec(index = 15u8)]
        set_claim_permission {
            #[allow(missing_docs)]
            permission: ClaimPermission,
        },

        #[doc = "See [`Pallet::claim_payout_other`]."]
        #[codec(index = 16u8)]
        claim_payout_other {
            #[allow(missing_docs)]
            other: T::AccountId,
        },

        #[doc = "See [`Pallet::set_commission`]."]
        #[codec(index = 17u8)]
        set_commission {
            #[allow(missing_docs)]
            pool_id: PoolId,
            #[allow(missing_docs)]
            new_commission: Option<(Perbill, T::AccountId)>,
        },

        #[doc = "See [`Pallet::set_commission_max`]."]
        #[codec(index = 18u8)]
        set_commission_max {
            #[allow(missing_docs)]
            pool_id: PoolId,
            #[allow(missing_docs)]
            max_commission: Perbill,
        },

        #[doc = "See [`Pallet::set_commission_change_rate`]."]
        #[codec(index = 19u8)]
        set_commission_change_rate {
            #[allow(missing_docs)]
            pool_id: PoolId,
            #[allow(missing_docs)]
            change_rate: CommissionChangeRate<BlockNumberFor<T>>,
        },

        #[doc = "See [`Pallet::claim_commission`]."]
        #[codec(index = 20u8)]
        claim_commission {
            #[allow(missing_docs)]
            pool_id: PoolId,
        },

        #[doc = "See [`Pallet::adjust_pool_deposit`]."]
        #[codec(index = 21u8)]
        adjust_pool_deposit {
            #[allow(missing_docs)]
            pool_id: PoolId,
        },

        #[doc = "See [`Pallet::set_commission_claim_permission`]."]
        #[codec(index = 22u8)]
        set_commission_claim_permission {
            #[allow(missing_docs)]
            pool_id: PoolId,
            #[allow(missing_docs)]
            permission: Option<CommissionClaimPermission<T::AccountId>>,
        },
    }
    const _: () =
        {
            #[automatically_derived]
            impl<T: Config> ::core::fmt::Debug for Call<T> {
                fn fmt(&self, fmt: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    match *self {
                        Self::__Ignore(ref _0, ref _1) => {
                            fmt.debug_tuple("Call::__Ignore").field(&_0).field(&_1).finish()
                        }
                        Self::join { ref amount, ref pool_id } => {
                            fmt.debug_struct("Call::join").field("amount",
                                        &amount).field("pool_id", &pool_id).finish()
                        }
                        Self::bond_extra { ref extra } => {
                            fmt.debug_struct("Call::bond_extra").field("extra",
                                    &extra).finish()
                        }
                        Self::claim_payout {} => {
                            fmt.debug_struct("Call::claim_payout").finish()
                        }
                        Self::unbond { ref member_account, ref unbonding_points } =>
                            {
                            fmt.debug_struct("Call::unbond").field("member_account",
                                        &member_account).field("unbonding_points",
                                    &unbonding_points).finish()
                        }
                        Self::pool_withdraw_unbonded {
                            ref pool_id, ref num_slashing_spans } => {
                            fmt.debug_struct("Call::pool_withdraw_unbonded").field("pool_id",
                                        &pool_id).field("num_slashing_spans",
                                    &num_slashing_spans).finish()
                        }
                        Self::withdraw_unbonded {
                            ref member_account, ref num_slashing_spans } => {
                            fmt.debug_struct("Call::withdraw_unbonded").field("member_account",
                                        &member_account).field("num_slashing_spans",
                                    &num_slashing_spans).finish()
                        }
                        Self::create {
                            ref amount, ref root, ref nominator, ref bouncer } => {
                            fmt.debug_struct("Call::create").field("amount",
                                                &amount).field("root",
                                            &root).field("nominator",
                                        &nominator).field("bouncer", &bouncer).finish()
                        }
                        Self::create_with_pool_id {
                            ref amount,
                            ref root,
                            ref nominator,
                            ref bouncer,
                            ref pool_id } => {
                            fmt.debug_struct("Call::create_with_pool_id").field("amount",
                                                    &amount).field("root",
                                                &root).field("nominator",
                                            &nominator).field("bouncer",
                                        &bouncer).field("pool_id", &pool_id).finish()
                        }
                        Self::nominate { ref pool_id, ref validators } => {
                            fmt.debug_struct("Call::nominate").field("pool_id",
                                        &pool_id).field("validators", &validators).finish()
                        }
                        Self::set_state { ref pool_id, ref state } => {
                            fmt.debug_struct("Call::set_state").field("pool_id",
                                        &pool_id).field("state", &state).finish()
                        }
                        Self::set_metadata { ref pool_id, ref metadata } => {
                            fmt.debug_struct("Call::set_metadata").field("pool_id",
                                        &pool_id).field("metadata", &metadata).finish()
                        }
                        Self::set_configs {
                            ref min_join_bond,
                            ref min_create_bond,
                            ref max_pools,
                            ref max_members,
                            ref max_members_per_pool,
                            ref global_max_commission } => {
                            fmt.debug_struct("Call::set_configs").field("min_join_bond",
                                                        &min_join_bond).field("min_create_bond",
                                                    &min_create_bond).field("max_pools",
                                                &max_pools).field("max_members",
                                            &max_members).field("max_members_per_pool",
                                        &max_members_per_pool).field("global_max_commission",
                                    &global_max_commission).finish()
                        }
                        Self::update_roles {
                            ref pool_id,
                            ref new_root,
                            ref new_nominator,
                            ref new_bouncer } => {
                            fmt.debug_struct("Call::update_roles").field("pool_id",
                                                &pool_id).field("new_root",
                                            &new_root).field("new_nominator",
                                        &new_nominator).field("new_bouncer", &new_bouncer).finish()
                        }
                        Self::chill { ref pool_id } => {
                            fmt.debug_struct("Call::chill").field("pool_id",
                                    &pool_id).finish()
                        }
                        Self::bond_extra_other { ref member, ref extra } => {
                            fmt.debug_struct("Call::bond_extra_other").field("member",
                                        &member).field("extra", &extra).finish()
                        }
                        Self::set_claim_permission { ref permission } => {
                            fmt.debug_struct("Call::set_claim_permission").field("permission",
                                    &permission).finish()
                        }
                        Self::claim_payout_other { ref other } => {
                            fmt.debug_struct("Call::claim_payout_other").field("other",
                                    &other).finish()
                        }
                        Self::set_commission { ref pool_id, ref new_commission } =>
                            {
                            fmt.debug_struct("Call::set_commission").field("pool_id",
                                        &pool_id).field("new_commission", &new_commission).finish()
                        }
                        Self::set_commission_max { ref pool_id, ref max_commission }
                            => {
                            fmt.debug_struct("Call::set_commission_max").field("pool_id",
                                        &pool_id).field("max_commission", &max_commission).finish()
                        }
                        Self::set_commission_change_rate {
                            ref pool_id, ref change_rate } => {
                            fmt.debug_struct("Call::set_commission_change_rate").field("pool_id",
                                        &pool_id).field("change_rate", &change_rate).finish()
                        }
                        Self::claim_commission { ref pool_id } => {
                            fmt.debug_struct("Call::claim_commission").field("pool_id",
                                    &pool_id).finish()
                        }
                        Self::adjust_pool_deposit { ref pool_id } => {
                            fmt.debug_struct("Call::adjust_pool_deposit").field("pool_id",
                                    &pool_id).finish()
                        }
                        Self::set_commission_claim_permission {
                            ref pool_id, ref permission } => {
                            fmt.debug_struct("Call::set_commission_claim_permission").field("pool_id",
                                        &pool_id).field("permission", &permission).finish()
                        }
                    }
                }
            }
        };
    const _: () =
        {
            #[automatically_derived]
            impl<T: Config> ::core::clone::Clone for Call<T> {
                fn clone(&self) -> Self {
                    match self {
                        Self::__Ignore(ref _0, ref _1) =>
                            Self::__Ignore(::core::clone::Clone::clone(_0),
                                ::core::clone::Clone::clone(_1)),
                        Self::join { ref amount, ref pool_id } =>
                            Self::join {
                                amount: ::core::clone::Clone::clone(amount),
                                pool_id: ::core::clone::Clone::clone(pool_id),
                            },
                        Self::bond_extra { ref extra } =>
                            Self::bond_extra {
                                extra: ::core::clone::Clone::clone(extra),
                            },
                        Self::claim_payout {} => Self::claim_payout {},
                        Self::unbond { ref member_account, ref unbonding_points } =>
                            Self::unbond {
                                member_account: ::core::clone::Clone::clone(member_account),
                                unbonding_points: ::core::clone::Clone::clone(unbonding_points),
                            },
                        Self::pool_withdraw_unbonded {
                            ref pool_id, ref num_slashing_spans } =>
                            Self::pool_withdraw_unbonded {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                num_slashing_spans: ::core::clone::Clone::clone(num_slashing_spans),
                            },
                        Self::withdraw_unbonded {
                            ref member_account, ref num_slashing_spans } =>
                            Self::withdraw_unbonded {
                                member_account: ::core::clone::Clone::clone(member_account),
                                num_slashing_spans: ::core::clone::Clone::clone(num_slashing_spans),
                            },
                        Self::create {
                            ref amount, ref root, ref nominator, ref bouncer } =>
                            Self::create {
                                amount: ::core::clone::Clone::clone(amount),
                                root: ::core::clone::Clone::clone(root),
                                nominator: ::core::clone::Clone::clone(nominator),
                                bouncer: ::core::clone::Clone::clone(bouncer),
                            },
                        Self::create_with_pool_id {
                            ref amount,
                            ref root,
                            ref nominator,
                            ref bouncer,
                            ref pool_id } =>
                            Self::create_with_pool_id {
                                amount: ::core::clone::Clone::clone(amount),
                                root: ::core::clone::Clone::clone(root),
                                nominator: ::core::clone::Clone::clone(nominator),
                                bouncer: ::core::clone::Clone::clone(bouncer),
                                pool_id: ::core::clone::Clone::clone(pool_id),
                            },
                        Self::nominate { ref pool_id, ref validators } =>
                            Self::nominate {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                validators: ::core::clone::Clone::clone(validators),
                            },
                        Self::set_state { ref pool_id, ref state } =>
                            Self::set_state {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                state: ::core::clone::Clone::clone(state),
                            },
                        Self::set_metadata { ref pool_id, ref metadata } =>
                            Self::set_metadata {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                metadata: ::core::clone::Clone::clone(metadata),
                            },
                        Self::set_configs {
                            ref min_join_bond,
                            ref min_create_bond,
                            ref max_pools,
                            ref max_members,
                            ref max_members_per_pool,
                            ref global_max_commission } =>
                            Self::set_configs {
                                min_join_bond: ::core::clone::Clone::clone(min_join_bond),
                                min_create_bond: ::core::clone::Clone::clone(min_create_bond),
                                max_pools: ::core::clone::Clone::clone(max_pools),
                                max_members: ::core::clone::Clone::clone(max_members),
                                max_members_per_pool: ::core::clone::Clone::clone(max_members_per_pool),
                                global_max_commission: ::core::clone::Clone::clone(global_max_commission),
                            },
                        Self::update_roles {
                            ref pool_id,
                            ref new_root,
                            ref new_nominator,
                            ref new_bouncer } =>
                            Self::update_roles {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                new_root: ::core::clone::Clone::clone(new_root),
                                new_nominator: ::core::clone::Clone::clone(new_nominator),
                                new_bouncer: ::core::clone::Clone::clone(new_bouncer),
                            },
                        Self::chill { ref pool_id } =>
                            Self::chill {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                            },
                        Self::bond_extra_other { ref member, ref extra } =>
                            Self::bond_extra_other {
                                member: ::core::clone::Clone::clone(member),
                                extra: ::core::clone::Clone::clone(extra),
                            },
                        Self::set_claim_permission { ref permission } =>
                            Self::set_claim_permission {
                                permission: ::core::clone::Clone::clone(permission),
                            },
                        Self::claim_payout_other { ref other } =>
                            Self::claim_payout_other {
                                other: ::core::clone::Clone::clone(other),
                            },
                        Self::set_commission { ref pool_id, ref new_commission } =>
                            Self::set_commission {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                new_commission: ::core::clone::Clone::clone(new_commission),
                            },
                        Self::set_commission_max { ref pool_id, ref max_commission }
                            =>
                            Self::set_commission_max {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                max_commission: ::core::clone::Clone::clone(max_commission),
                            },
                        Self::set_commission_change_rate {
                            ref pool_id, ref change_rate } =>
                            Self::set_commission_change_rate {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                change_rate: ::core::clone::Clone::clone(change_rate),
                            },
                        Self::claim_commission { ref pool_id } =>
                            Self::claim_commission {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                            },
                        Self::adjust_pool_deposit { ref pool_id } =>
                            Self::adjust_pool_deposit {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                            },
                        Self::set_commission_claim_permission {
                            ref pool_id, ref permission } =>
                            Self::set_commission_claim_permission {
                                pool_id: ::core::clone::Clone::clone(pool_id),
                                permission: ::core::clone::Clone::clone(permission),
                            },
                    }
                }
            }
        };
    const _: () =
        {
            impl<T: Config> ::core::cmp::Eq for Call<T> {}
        };
    const _: () =
        {
            #[automatically_derived]
            impl<T: Config> ::core::cmp::PartialEq for Call<T> {
                fn eq(&self, other: &Self) -> bool {
                    match (self, other) {
                        (Self::__Ignore(_0, _1), Self::__Ignore(_0_other, _1_other))
                            => true && _0 == _0_other && _1 == _1_other,
                        (Self::join { amount, pool_id }, Self::join {
                            amount: _0, pool_id: _1 }) =>
                            true && amount == _0 && pool_id == _1,
                        (Self::bond_extra { extra }, Self::bond_extra { extra: _0 })
                            => true && extra == _0,
                        (Self::claim_payout {}, Self::claim_payout {}) => true,
                        (Self::unbond { member_account, unbonding_points },
                            Self::unbond { member_account: _0, unbonding_points: _1 })
                            => true && member_account == _0 && unbonding_points == _1,
                        (Self::pool_withdraw_unbonded { pool_id, num_slashing_spans
                            }, Self::pool_withdraw_unbonded {
                            pool_id: _0, num_slashing_spans: _1 }) =>
                            true && pool_id == _0 && num_slashing_spans == _1,
                        (Self::withdraw_unbonded {
                            member_account, num_slashing_spans },
                            Self::withdraw_unbonded {
                            member_account: _0, num_slashing_spans: _1 }) =>
                            true && member_account == _0 && num_slashing_spans == _1,
                        (Self::create { amount, root, nominator, bouncer },
                            Self::create {
                            amount: _0, root: _1, nominator: _2, bouncer: _3 }) =>
                            true && amount == _0 && root == _1 && nominator == _2 &&
                                bouncer == _3,
                        (Self::create_with_pool_id {
                            amount, root, nominator, bouncer, pool_id },
                            Self::create_with_pool_id {
                            amount: _0,
                            root: _1,
                            nominator: _2,
                            bouncer: _3,
                            pool_id: _4 }) =>
                            true && amount == _0 && root == _1 && nominator == _2 &&
                                    bouncer == _3 && pool_id == _4,
                        (Self::nominate { pool_id, validators }, Self::nominate {
                            pool_id: _0, validators: _1 }) =>
                            true && pool_id == _0 && validators == _1,
                        (Self::set_state { pool_id, state }, Self::set_state {
                            pool_id: _0, state: _1 }) =>
                            true && pool_id == _0 && state == _1,
                        (Self::set_metadata { pool_id, metadata },
                            Self::set_metadata { pool_id: _0, metadata: _1 }) =>
                            true && pool_id == _0 && metadata == _1,
                        (Self::set_configs {
                            min_join_bond,
                            min_create_bond,
                            max_pools,
                            max_members,
                            max_members_per_pool,
                            global_max_commission }, Self::set_configs {
                            min_join_bond: _0,
                            min_create_bond: _1,
                            max_pools: _2,
                            max_members: _3,
                            max_members_per_pool: _4,
                            global_max_commission: _5 }) =>
                            true && min_join_bond == _0 && min_create_bond == _1 &&
                                            max_pools == _2 && max_members == _3 &&
                                    max_members_per_pool == _4 && global_max_commission == _5,
                        (Self::update_roles {
                            pool_id, new_root, new_nominator, new_bouncer },
                            Self::update_roles {
                            pool_id: _0,
                            new_root: _1,
                            new_nominator: _2,
                            new_bouncer: _3 }) =>
                            true && pool_id == _0 && new_root == _1 &&
                                    new_nominator == _2 && new_bouncer == _3,
                        (Self::chill { pool_id }, Self::chill { pool_id: _0 }) =>
                            true && pool_id == _0,
                        (Self::bond_extra_other { member, extra },
                            Self::bond_extra_other { member: _0, extra: _1 }) =>
                            true && member == _0 && extra == _1,
                        (Self::set_claim_permission { permission },
                            Self::set_claim_permission { permission: _0 }) =>
                            true && permission == _0,
                        (Self::claim_payout_other { other },
                            Self::claim_payout_other { other: _0 }) =>
                            true && other == _0,
                        (Self::set_commission { pool_id, new_commission },
                            Self::set_commission { pool_id: _0, new_commission: _1 }) =>
                            true && pool_id == _0 && new_commission == _1,
                        (Self::set_commission_max { pool_id, max_commission },
                            Self::set_commission_max { pool_id: _0, max_commission: _1
                            }) => true && pool_id == _0 && max_commission == _1,
                        (Self::set_commission_change_rate { pool_id, change_rate },
                            Self::set_commission_change_rate {
                            pool_id: _0, change_rate: _1 }) =>
                            true && pool_id == _0 && change_rate == _1,
                        (Self::claim_commission { pool_id },
                            Self::claim_commission { pool_id: _0 }) =>
                            true && pool_id == _0,
                        (Self::adjust_pool_deposit { pool_id },
                            Self::adjust_pool_deposit { pool_id: _0 }) =>
                            true && pool_id == _0,
                        (Self::set_commission_claim_permission { pool_id, permission
                            }, Self::set_commission_claim_permission {
                            pool_id: _0, permission: _1 }) =>
                            true && pool_id == _0 && permission == _1,
                        (Self::__Ignore { .. }, Self::join { .. }) => false,
                        (Self::__Ignore { .. }, Self::bond_extra { .. }) => false,
                        (Self::__Ignore { .. }, Self::claim_payout { .. }) => false,
                        (Self::__Ignore { .. }, Self::unbond { .. }) => false,
                        (Self::__Ignore { .. }, Self::pool_withdraw_unbonded { .. })
                            => false,
                        (Self::__Ignore { .. }, Self::withdraw_unbonded { .. }) =>
                            false,
                        (Self::__Ignore { .. }, Self::create { .. }) => false,
                        (Self::__Ignore { .. }, Self::create_with_pool_id { .. }) =>
                            false,
                        (Self::__Ignore { .. }, Self::nominate { .. }) => false,
                        (Self::__Ignore { .. }, Self::set_state { .. }) => false,
                        (Self::__Ignore { .. }, Self::set_metadata { .. }) => false,
                        (Self::__Ignore { .. }, Self::set_configs { .. }) => false,
                        (Self::__Ignore { .. }, Self::update_roles { .. }) => false,
                        (Self::__Ignore { .. }, Self::chill { .. }) => false,
                        (Self::__Ignore { .. }, Self::bond_extra_other { .. }) =>
                            false,
                        (Self::__Ignore { .. }, Self::set_claim_permission { .. })
                            => false,
                        (Self::__Ignore { .. }, Self::claim_payout_other { .. }) =>
                            false,
                        (Self::__Ignore { .. }, Self::set_commission { .. }) =>
                            false,
                        (Self::__Ignore { .. }, Self::set_commission_max { .. }) =>
                            false,
                        (Self::__Ignore { .. }, Self::set_commission_change_rate {
                            .. }) => false,
                        (Self::__Ignore { .. }, Self::claim_commission { .. }) =>
                            false,
                        (Self::__Ignore { .. }, Self::adjust_pool_deposit { .. }) =>
                            false,
                        (Self::__Ignore { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::join { .. }, Self::__Ignore { .. }) => false,
                        (Self::join { .. }, Self::bond_extra { .. }) => false,
                        (Self::join { .. }, Self::claim_payout { .. }) => false,
                        (Self::join { .. }, Self::unbond { .. }) => false,
                        (Self::join { .. }, Self::pool_withdraw_unbonded { .. }) =>
                            false,
                        (Self::join { .. }, Self::withdraw_unbonded { .. }) =>
                            false,
                        (Self::join { .. }, Self::create { .. }) => false,
                        (Self::join { .. }, Self::create_with_pool_id { .. }) =>
                            false,
                        (Self::join { .. }, Self::nominate { .. }) => false,
                        (Self::join { .. }, Self::set_state { .. }) => false,
                        (Self::join { .. }, Self::set_metadata { .. }) => false,
                        (Self::join { .. }, Self::set_configs { .. }) => false,
                        (Self::join { .. }, Self::update_roles { .. }) => false,
                        (Self::join { .. }, Self::chill { .. }) => false,
                        (Self::join { .. }, Self::bond_extra_other { .. }) => false,
                        (Self::join { .. }, Self::set_claim_permission { .. }) =>
                            false,
                        (Self::join { .. }, Self::claim_payout_other { .. }) =>
                            false,
                        (Self::join { .. }, Self::set_commission { .. }) => false,
                        (Self::join { .. }, Self::set_commission_max { .. }) =>
                            false,
                        (Self::join { .. }, Self::set_commission_change_rate { .. })
                            => false,
                        (Self::join { .. }, Self::claim_commission { .. }) => false,
                        (Self::join { .. }, Self::adjust_pool_deposit { .. }) =>
                            false,
                        (Self::join { .. }, Self::set_commission_claim_permission {
                            .. }) => false,
                        (Self::bond_extra { .. }, Self::__Ignore { .. }) => false,
                        (Self::bond_extra { .. }, Self::join { .. }) => false,
                        (Self::bond_extra { .. }, Self::claim_payout { .. }) =>
                            false,
                        (Self::bond_extra { .. }, Self::unbond { .. }) => false,
                        (Self::bond_extra { .. }, Self::pool_withdraw_unbonded { ..
                            }) => false,
                        (Self::bond_extra { .. }, Self::withdraw_unbonded { .. }) =>
                            false,
                        (Self::bond_extra { .. }, Self::create { .. }) => false,
                        (Self::bond_extra { .. }, Self::create_with_pool_id { .. })
                            => false,
                        (Self::bond_extra { .. }, Self::nominate { .. }) => false,
                        (Self::bond_extra { .. }, Self::set_state { .. }) => false,
                        (Self::bond_extra { .. }, Self::set_metadata { .. }) =>
                            false,
                        (Self::bond_extra { .. }, Self::set_configs { .. }) =>
                            false,
                        (Self::bond_extra { .. }, Self::update_roles { .. }) =>
                            false,
                        (Self::bond_extra { .. }, Self::chill { .. }) => false,
                        (Self::bond_extra { .. }, Self::bond_extra_other { .. }) =>
                            false,
                        (Self::bond_extra { .. }, Self::set_claim_permission { .. })
                            => false,
                        (Self::bond_extra { .. }, Self::claim_payout_other { .. })
                            => false,
                        (Self::bond_extra { .. }, Self::set_commission { .. }) =>
                            false,
                        (Self::bond_extra { .. }, Self::set_commission_max { .. })
                            => false,
                        (Self::bond_extra { .. }, Self::set_commission_change_rate {
                            .. }) => false,
                        (Self::bond_extra { .. }, Self::claim_commission { .. }) =>
                            false,
                        (Self::bond_extra { .. }, Self::adjust_pool_deposit { .. })
                            => false,
                        (Self::bond_extra { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::claim_payout { .. }, Self::__Ignore { .. }) => false,
                        (Self::claim_payout { .. }, Self::join { .. }) => false,
                        (Self::claim_payout { .. }, Self::bond_extra { .. }) =>
                            false,
                        (Self::claim_payout { .. }, Self::unbond { .. }) => false,
                        (Self::claim_payout { .. }, Self::pool_withdraw_unbonded {
                            .. }) => false,
                        (Self::claim_payout { .. }, Self::withdraw_unbonded { .. })
                            => false,
                        (Self::claim_payout { .. }, Self::create { .. }) => false,
                        (Self::claim_payout { .. }, Self::create_with_pool_id { ..
                            }) => false,
                        (Self::claim_payout { .. }, Self::nominate { .. }) => false,
                        (Self::claim_payout { .. }, Self::set_state { .. }) =>
                            false,
                        (Self::claim_payout { .. }, Self::set_metadata { .. }) =>
                            false,
                        (Self::claim_payout { .. }, Self::set_configs { .. }) =>
                            false,
                        (Self::claim_payout { .. }, Self::update_roles { .. }) =>
                            false,
                        (Self::claim_payout { .. }, Self::chill { .. }) => false,
                        (Self::claim_payout { .. }, Self::bond_extra_other { .. })
                            => false,
                        (Self::claim_payout { .. }, Self::set_claim_permission { ..
                            }) => false,
                        (Self::claim_payout { .. }, Self::claim_payout_other { .. })
                            => false,
                        (Self::claim_payout { .. }, Self::set_commission { .. }) =>
                            false,
                        (Self::claim_payout { .. }, Self::set_commission_max { .. })
                            => false,
                        (Self::claim_payout { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::claim_payout { .. }, Self::claim_commission { .. })
                            => false,
                        (Self::claim_payout { .. }, Self::adjust_pool_deposit { ..
                            }) => false,
                        (Self::claim_payout { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::unbond { .. }, Self::__Ignore { .. }) => false,
                        (Self::unbond { .. }, Self::join { .. }) => false,
                        (Self::unbond { .. }, Self::bond_extra { .. }) => false,
                        (Self::unbond { .. }, Self::claim_payout { .. }) => false,
                        (Self::unbond { .. }, Self::pool_withdraw_unbonded { .. })
                            => false,
                        (Self::unbond { .. }, Self::withdraw_unbonded { .. }) =>
                            false,
                        (Self::unbond { .. }, Self::create { .. }) => false,
                        (Self::unbond { .. }, Self::create_with_pool_id { .. }) =>
                            false,
                        (Self::unbond { .. }, Self::nominate { .. }) => false,
                        (Self::unbond { .. }, Self::set_state { .. }) => false,
                        (Self::unbond { .. }, Self::set_metadata { .. }) => false,
                        (Self::unbond { .. }, Self::set_configs { .. }) => false,
                        (Self::unbond { .. }, Self::update_roles { .. }) => false,
                        (Self::unbond { .. }, Self::chill { .. }) => false,
                        (Self::unbond { .. }, Self::bond_extra_other { .. }) =>
                            false,
                        (Self::unbond { .. }, Self::set_claim_permission { .. }) =>
                            false,
                        (Self::unbond { .. }, Self::claim_payout_other { .. }) =>
                            false,
                        (Self::unbond { .. }, Self::set_commission { .. }) => false,
                        (Self::unbond { .. }, Self::set_commission_max { .. }) =>
                            false,
                        (Self::unbond { .. }, Self::set_commission_change_rate { ..
                            }) => false,
                        (Self::unbond { .. }, Self::claim_commission { .. }) =>
                            false,
                        (Self::unbond { .. }, Self::adjust_pool_deposit { .. }) =>
                            false,
                        (Self::unbond { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::__Ignore { .. })
                            => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::join { .. }) =>
                            false,
                        (Self::pool_withdraw_unbonded { .. }, Self::bond_extra { ..
                            }) => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::claim_payout {
                            .. }) => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::unbond { .. })
                            => false,
                        (Self::pool_withdraw_unbonded { .. },
                            Self::withdraw_unbonded { .. }) => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::create { .. })
                            => false,
                        (Self::pool_withdraw_unbonded { .. },
                            Self::create_with_pool_id { .. }) => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::nominate { .. })
                            => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::set_state { ..
                            }) => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::set_metadata {
                            .. }) => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::set_configs { ..
                            }) => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::update_roles {
                            .. }) => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::chill { .. }) =>
                            false,
                        (Self::pool_withdraw_unbonded { .. },
                            Self::bond_extra_other { .. }) => false,
                        (Self::pool_withdraw_unbonded { .. },
                            Self::set_claim_permission { .. }) => false,
                        (Self::pool_withdraw_unbonded { .. },
                            Self::claim_payout_other { .. }) => false,
                        (Self::pool_withdraw_unbonded { .. }, Self::set_commission {
                            .. }) => false,
                        (Self::pool_withdraw_unbonded { .. },
                            Self::set_commission_max { .. }) => false,
                        (Self::pool_withdraw_unbonded { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::pool_withdraw_unbonded { .. },
                            Self::claim_commission { .. }) => false,
                        (Self::pool_withdraw_unbonded { .. },
                            Self::adjust_pool_deposit { .. }) => false,
                        (Self::pool_withdraw_unbonded { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::__Ignore { .. }) =>
                            false,
                        (Self::withdraw_unbonded { .. }, Self::join { .. }) =>
                            false,
                        (Self::withdraw_unbonded { .. }, Self::bond_extra { .. }) =>
                            false,
                        (Self::withdraw_unbonded { .. }, Self::claim_payout { .. })
                            => false,
                        (Self::withdraw_unbonded { .. }, Self::unbond { .. }) =>
                            false,
                        (Self::withdraw_unbonded { .. },
                            Self::pool_withdraw_unbonded { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::create { .. }) =>
                            false,
                        (Self::withdraw_unbonded { .. }, Self::create_with_pool_id {
                            .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::nominate { .. }) =>
                            false,
                        (Self::withdraw_unbonded { .. }, Self::set_state { .. }) =>
                            false,
                        (Self::withdraw_unbonded { .. }, Self::set_metadata { .. })
                            => false,
                        (Self::withdraw_unbonded { .. }, Self::set_configs { .. })
                            => false,
                        (Self::withdraw_unbonded { .. }, Self::update_roles { .. })
                            => false,
                        (Self::withdraw_unbonded { .. }, Self::chill { .. }) =>
                            false,
                        (Self::withdraw_unbonded { .. }, Self::bond_extra_other { ..
                            }) => false,
                        (Self::withdraw_unbonded { .. },
                            Self::set_claim_permission { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::claim_payout_other {
                            .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::set_commission { ..
                            }) => false,
                        (Self::withdraw_unbonded { .. }, Self::set_commission_max {
                            .. }) => false,
                        (Self::withdraw_unbonded { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::withdraw_unbonded { .. }, Self::claim_commission { ..
                            }) => false,
                        (Self::withdraw_unbonded { .. }, Self::adjust_pool_deposit {
                            .. }) => false,
                        (Self::withdraw_unbonded { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::create { .. }, Self::__Ignore { .. }) => false,
                        (Self::create { .. }, Self::join { .. }) => false,
                        (Self::create { .. }, Self::bond_extra { .. }) => false,
                        (Self::create { .. }, Self::claim_payout { .. }) => false,
                        (Self::create { .. }, Self::unbond { .. }) => false,
                        (Self::create { .. }, Self::pool_withdraw_unbonded { .. })
                            => false,
                        (Self::create { .. }, Self::withdraw_unbonded { .. }) =>
                            false,
                        (Self::create { .. }, Self::create_with_pool_id { .. }) =>
                            false,
                        (Self::create { .. }, Self::nominate { .. }) => false,
                        (Self::create { .. }, Self::set_state { .. }) => false,
                        (Self::create { .. }, Self::set_metadata { .. }) => false,
                        (Self::create { .. }, Self::set_configs { .. }) => false,
                        (Self::create { .. }, Self::update_roles { .. }) => false,
                        (Self::create { .. }, Self::chill { .. }) => false,
                        (Self::create { .. }, Self::bond_extra_other { .. }) =>
                            false,
                        (Self::create { .. }, Self::set_claim_permission { .. }) =>
                            false,
                        (Self::create { .. }, Self::claim_payout_other { .. }) =>
                            false,
                        (Self::create { .. }, Self::set_commission { .. }) => false,
                        (Self::create { .. }, Self::set_commission_max { .. }) =>
                            false,
                        (Self::create { .. }, Self::set_commission_change_rate { ..
                            }) => false,
                        (Self::create { .. }, Self::claim_commission { .. }) =>
                            false,
                        (Self::create { .. }, Self::adjust_pool_deposit { .. }) =>
                            false,
                        (Self::create { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::create_with_pool_id { .. }, Self::__Ignore { .. }) =>
                            false,
                        (Self::create_with_pool_id { .. }, Self::join { .. }) =>
                            false,
                        (Self::create_with_pool_id { .. }, Self::bond_extra { .. })
                            => false,
                        (Self::create_with_pool_id { .. }, Self::claim_payout { ..
                            }) => false,
                        (Self::create_with_pool_id { .. }, Self::unbond { .. }) =>
                            false,
                        (Self::create_with_pool_id { .. },
                            Self::pool_withdraw_unbonded { .. }) => false,
                        (Self::create_with_pool_id { .. }, Self::withdraw_unbonded {
                            .. }) => false,
                        (Self::create_with_pool_id { .. }, Self::create { .. }) =>
                            false,
                        (Self::create_with_pool_id { .. }, Self::nominate { .. }) =>
                            false,
                        (Self::create_with_pool_id { .. }, Self::set_state { .. })
                            => false,
                        (Self::create_with_pool_id { .. }, Self::set_metadata { ..
                            }) => false,
                        (Self::create_with_pool_id { .. }, Self::set_configs { .. })
                            => false,
                        (Self::create_with_pool_id { .. }, Self::update_roles { ..
                            }) => false,
                        (Self::create_with_pool_id { .. }, Self::chill { .. }) =>
                            false,
                        (Self::create_with_pool_id { .. }, Self::bond_extra_other {
                            .. }) => false,
                        (Self::create_with_pool_id { .. },
                            Self::set_claim_permission { .. }) => false,
                        (Self::create_with_pool_id { .. },
                            Self::claim_payout_other { .. }) => false,
                        (Self::create_with_pool_id { .. }, Self::set_commission { ..
                            }) => false,
                        (Self::create_with_pool_id { .. },
                            Self::set_commission_max { .. }) => false,
                        (Self::create_with_pool_id { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::create_with_pool_id { .. }, Self::claim_commission {
                            .. }) => false,
                        (Self::create_with_pool_id { .. },
                            Self::adjust_pool_deposit { .. }) => false,
                        (Self::create_with_pool_id { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::nominate { .. }, Self::__Ignore { .. }) => false,
                        (Self::nominate { .. }, Self::join { .. }) => false,
                        (Self::nominate { .. }, Self::bond_extra { .. }) => false,
                        (Self::nominate { .. }, Self::claim_payout { .. }) => false,
                        (Self::nominate { .. }, Self::unbond { .. }) => false,
                        (Self::nominate { .. }, Self::pool_withdraw_unbonded { .. })
                            => false,
                        (Self::nominate { .. }, Self::withdraw_unbonded { .. }) =>
                            false,
                        (Self::nominate { .. }, Self::create { .. }) => false,
                        (Self::nominate { .. }, Self::create_with_pool_id { .. }) =>
                            false,
                        (Self::nominate { .. }, Self::set_state { .. }) => false,
                        (Self::nominate { .. }, Self::set_metadata { .. }) => false,
                        (Self::nominate { .. }, Self::set_configs { .. }) => false,
                        (Self::nominate { .. }, Self::update_roles { .. }) => false,
                        (Self::nominate { .. }, Self::chill { .. }) => false,
                        (Self::nominate { .. }, Self::bond_extra_other { .. }) =>
                            false,
                        (Self::nominate { .. }, Self::set_claim_permission { .. })
                            => false,
                        (Self::nominate { .. }, Self::claim_payout_other { .. }) =>
                            false,
                        (Self::nominate { .. }, Self::set_commission { .. }) =>
                            false,
                        (Self::nominate { .. }, Self::set_commission_max { .. }) =>
                            false,
                        (Self::nominate { .. }, Self::set_commission_change_rate {
                            .. }) => false,
                        (Self::nominate { .. }, Self::claim_commission { .. }) =>
                            false,
                        (Self::nominate { .. }, Self::adjust_pool_deposit { .. }) =>
                            false,
                        (Self::nominate { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::set_state { .. }, Self::__Ignore { .. }) => false,
                        (Self::set_state { .. }, Self::join { .. }) => false,
                        (Self::set_state { .. }, Self::bond_extra { .. }) => false,
                        (Self::set_state { .. }, Self::claim_payout { .. }) =>
                            false,
                        (Self::set_state { .. }, Self::unbond { .. }) => false,
                        (Self::set_state { .. }, Self::pool_withdraw_unbonded { ..
                            }) => false,
                        (Self::set_state { .. }, Self::withdraw_unbonded { .. }) =>
                            false,
                        (Self::set_state { .. }, Self::create { .. }) => false,
                        (Self::set_state { .. }, Self::create_with_pool_id { .. })
                            => false,
                        (Self::set_state { .. }, Self::nominate { .. }) => false,
                        (Self::set_state { .. }, Self::set_metadata { .. }) =>
                            false,
                        (Self::set_state { .. }, Self::set_configs { .. }) => false,
                        (Self::set_state { .. }, Self::update_roles { .. }) =>
                            false,
                        (Self::set_state { .. }, Self::chill { .. }) => false,
                        (Self::set_state { .. }, Self::bond_extra_other { .. }) =>
                            false,
                        (Self::set_state { .. }, Self::set_claim_permission { .. })
                            => false,
                        (Self::set_state { .. }, Self::claim_payout_other { .. }) =>
                            false,
                        (Self::set_state { .. }, Self::set_commission { .. }) =>
                            false,
                        (Self::set_state { .. }, Self::set_commission_max { .. }) =>
                            false,
                        (Self::set_state { .. }, Self::set_commission_change_rate {
                            .. }) => false,
                        (Self::set_state { .. }, Self::claim_commission { .. }) =>
                            false,
                        (Self::set_state { .. }, Self::adjust_pool_deposit { .. })
                            => false,
                        (Self::set_state { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::set_metadata { .. }, Self::__Ignore { .. }) => false,
                        (Self::set_metadata { .. }, Self::join { .. }) => false,
                        (Self::set_metadata { .. }, Self::bond_extra { .. }) =>
                            false,
                        (Self::set_metadata { .. }, Self::claim_payout { .. }) =>
                            false,
                        (Self::set_metadata { .. }, Self::unbond { .. }) => false,
                        (Self::set_metadata { .. }, Self::pool_withdraw_unbonded {
                            .. }) => false,
                        (Self::set_metadata { .. }, Self::withdraw_unbonded { .. })
                            => false,
                        (Self::set_metadata { .. }, Self::create { .. }) => false,
                        (Self::set_metadata { .. }, Self::create_with_pool_id { ..
                            }) => false,
                        (Self::set_metadata { .. }, Self::nominate { .. }) => false,
                        (Self::set_metadata { .. }, Self::set_state { .. }) =>
                            false,
                        (Self::set_metadata { .. }, Self::set_configs { .. }) =>
                            false,
                        (Self::set_metadata { .. }, Self::update_roles { .. }) =>
                            false,
                        (Self::set_metadata { .. }, Self::chill { .. }) => false,
                        (Self::set_metadata { .. }, Self::bond_extra_other { .. })
                            => false,
                        (Self::set_metadata { .. }, Self::set_claim_permission { ..
                            }) => false,
                        (Self::set_metadata { .. }, Self::claim_payout_other { .. })
                            => false,
                        (Self::set_metadata { .. }, Self::set_commission { .. }) =>
                            false,
                        (Self::set_metadata { .. }, Self::set_commission_max { .. })
                            => false,
                        (Self::set_metadata { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::set_metadata { .. }, Self::claim_commission { .. })
                            => false,
                        (Self::set_metadata { .. }, Self::adjust_pool_deposit { ..
                            }) => false,
                        (Self::set_metadata { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::set_configs { .. }, Self::__Ignore { .. }) => false,
                        (Self::set_configs { .. }, Self::join { .. }) => false,
                        (Self::set_configs { .. }, Self::bond_extra { .. }) =>
                            false,
                        (Self::set_configs { .. }, Self::claim_payout { .. }) =>
                            false,
                        (Self::set_configs { .. }, Self::unbond { .. }) => false,
                        (Self::set_configs { .. }, Self::pool_withdraw_unbonded { ..
                            }) => false,
                        (Self::set_configs { .. }, Self::withdraw_unbonded { .. })
                            => false,
                        (Self::set_configs { .. }, Self::create { .. }) => false,
                        (Self::set_configs { .. }, Self::create_with_pool_id { .. })
                            => false,
                        (Self::set_configs { .. }, Self::nominate { .. }) => false,
                        (Self::set_configs { .. }, Self::set_state { .. }) => false,
                        (Self::set_configs { .. }, Self::set_metadata { .. }) =>
                            false,
                        (Self::set_configs { .. }, Self::update_roles { .. }) =>
                            false,
                        (Self::set_configs { .. }, Self::chill { .. }) => false,
                        (Self::set_configs { .. }, Self::bond_extra_other { .. }) =>
                            false,
                        (Self::set_configs { .. }, Self::set_claim_permission { ..
                            }) => false,
                        (Self::set_configs { .. }, Self::claim_payout_other { .. })
                            => false,
                        (Self::set_configs { .. }, Self::set_commission { .. }) =>
                            false,
                        (Self::set_configs { .. }, Self::set_commission_max { .. })
                            => false,
                        (Self::set_configs { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::set_configs { .. }, Self::claim_commission { .. }) =>
                            false,
                        (Self::set_configs { .. }, Self::adjust_pool_deposit { .. })
                            => false,
                        (Self::set_configs { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::update_roles { .. }, Self::__Ignore { .. }) => false,
                        (Self::update_roles { .. }, Self::join { .. }) => false,
                        (Self::update_roles { .. }, Self::bond_extra { .. }) =>
                            false,
                        (Self::update_roles { .. }, Self::claim_payout { .. }) =>
                            false,
                        (Self::update_roles { .. }, Self::unbond { .. }) => false,
                        (Self::update_roles { .. }, Self::pool_withdraw_unbonded {
                            .. }) => false,
                        (Self::update_roles { .. }, Self::withdraw_unbonded { .. })
                            => false,
                        (Self::update_roles { .. }, Self::create { .. }) => false,
                        (Self::update_roles { .. }, Self::create_with_pool_id { ..
                            }) => false,
                        (Self::update_roles { .. }, Self::nominate { .. }) => false,
                        (Self::update_roles { .. }, Self::set_state { .. }) =>
                            false,
                        (Self::update_roles { .. }, Self::set_metadata { .. }) =>
                            false,
                        (Self::update_roles { .. }, Self::set_configs { .. }) =>
                            false,
                        (Self::update_roles { .. }, Self::chill { .. }) => false,
                        (Self::update_roles { .. }, Self::bond_extra_other { .. })
                            => false,
                        (Self::update_roles { .. }, Self::set_claim_permission { ..
                            }) => false,
                        (Self::update_roles { .. }, Self::claim_payout_other { .. })
                            => false,
                        (Self::update_roles { .. }, Self::set_commission { .. }) =>
                            false,
                        (Self::update_roles { .. }, Self::set_commission_max { .. })
                            => false,
                        (Self::update_roles { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::update_roles { .. }, Self::claim_commission { .. })
                            => false,
                        (Self::update_roles { .. }, Self::adjust_pool_deposit { ..
                            }) => false,
                        (Self::update_roles { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::chill { .. }, Self::__Ignore { .. }) => false,
                        (Self::chill { .. }, Self::join { .. }) => false,
                        (Self::chill { .. }, Self::bond_extra { .. }) => false,
                        (Self::chill { .. }, Self::claim_payout { .. }) => false,
                        (Self::chill { .. }, Self::unbond { .. }) => false,
                        (Self::chill { .. }, Self::pool_withdraw_unbonded { .. }) =>
                            false,
                        (Self::chill { .. }, Self::withdraw_unbonded { .. }) =>
                            false,
                        (Self::chill { .. }, Self::create { .. }) => false,
                        (Self::chill { .. }, Self::create_with_pool_id { .. }) =>
                            false,
                        (Self::chill { .. }, Self::nominate { .. }) => false,
                        (Self::chill { .. }, Self::set_state { .. }) => false,
                        (Self::chill { .. }, Self::set_metadata { .. }) => false,
                        (Self::chill { .. }, Self::set_configs { .. }) => false,
                        (Self::chill { .. }, Self::update_roles { .. }) => false,
                        (Self::chill { .. }, Self::bond_extra_other { .. }) =>
                            false,
                        (Self::chill { .. }, Self::set_claim_permission { .. }) =>
                            false,
                        (Self::chill { .. }, Self::claim_payout_other { .. }) =>
                            false,
                        (Self::chill { .. }, Self::set_commission { .. }) => false,
                        (Self::chill { .. }, Self::set_commission_max { .. }) =>
                            false,
                        (Self::chill { .. }, Self::set_commission_change_rate { ..
                            }) => false,
                        (Self::chill { .. }, Self::claim_commission { .. }) =>
                            false,
                        (Self::chill { .. }, Self::adjust_pool_deposit { .. }) =>
                            false,
                        (Self::chill { .. }, Self::set_commission_claim_permission {
                            .. }) => false,
                        (Self::bond_extra_other { .. }, Self::__Ignore { .. }) =>
                            false,
                        (Self::bond_extra_other { .. }, Self::join { .. }) => false,
                        (Self::bond_extra_other { .. }, Self::bond_extra { .. }) =>
                            false,
                        (Self::bond_extra_other { .. }, Self::claim_payout { .. })
                            => false,
                        (Self::bond_extra_other { .. }, Self::unbond { .. }) =>
                            false,
                        (Self::bond_extra_other { .. },
                            Self::pool_withdraw_unbonded { .. }) => false,
                        (Self::bond_extra_other { .. }, Self::withdraw_unbonded { ..
                            }) => false,
                        (Self::bond_extra_other { .. }, Self::create { .. }) =>
                            false,
                        (Self::bond_extra_other { .. }, Self::create_with_pool_id {
                            .. }) => false,
                        (Self::bond_extra_other { .. }, Self::nominate { .. }) =>
                            false,
                        (Self::bond_extra_other { .. }, Self::set_state { .. }) =>
                            false,
                        (Self::bond_extra_other { .. }, Self::set_metadata { .. })
                            => false,
                        (Self::bond_extra_other { .. }, Self::set_configs { .. }) =>
                            false,
                        (Self::bond_extra_other { .. }, Self::update_roles { .. })
                            => false,
                        (Self::bond_extra_other { .. }, Self::chill { .. }) =>
                            false,
                        (Self::bond_extra_other { .. }, Self::set_claim_permission {
                            .. }) => false,
                        (Self::bond_extra_other { .. }, Self::claim_payout_other {
                            .. }) => false,
                        (Self::bond_extra_other { .. }, Self::set_commission { .. })
                            => false,
                        (Self::bond_extra_other { .. }, Self::set_commission_max {
                            .. }) => false,
                        (Self::bond_extra_other { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::bond_extra_other { .. }, Self::claim_commission { ..
                            }) => false,
                        (Self::bond_extra_other { .. }, Self::adjust_pool_deposit {
                            .. }) => false,
                        (Self::bond_extra_other { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::set_claim_permission { .. }, Self::__Ignore { .. })
                            => false,
                        (Self::set_claim_permission { .. }, Self::join { .. }) =>
                            false,
                        (Self::set_claim_permission { .. }, Self::bond_extra { .. })
                            => false,
                        (Self::set_claim_permission { .. }, Self::claim_payout { ..
                            }) => false,
                        (Self::set_claim_permission { .. }, Self::unbond { .. }) =>
                            false,
                        (Self::set_claim_permission { .. },
                            Self::pool_withdraw_unbonded { .. }) => false,
                        (Self::set_claim_permission { .. },
                            Self::withdraw_unbonded { .. }) => false,
                        (Self::set_claim_permission { .. }, Self::create { .. }) =>
                            false,
                        (Self::set_claim_permission { .. },
                            Self::create_with_pool_id { .. }) => false,
                        (Self::set_claim_permission { .. }, Self::nominate { .. })
                            => false,
                        (Self::set_claim_permission { .. }, Self::set_state { .. })
                            => false,
                        (Self::set_claim_permission { .. }, Self::set_metadata { ..
                            }) => false,
                        (Self::set_claim_permission { .. }, Self::set_configs { ..
                            }) => false,
                        (Self::set_claim_permission { .. }, Self::update_roles { ..
                            }) => false,
                        (Self::set_claim_permission { .. }, Self::chill { .. }) =>
                            false,
                        (Self::set_claim_permission { .. }, Self::bond_extra_other {
                            .. }) => false,
                        (Self::set_claim_permission { .. },
                            Self::claim_payout_other { .. }) => false,
                        (Self::set_claim_permission { .. }, Self::set_commission {
                            .. }) => false,
                        (Self::set_claim_permission { .. },
                            Self::set_commission_max { .. }) => false,
                        (Self::set_claim_permission { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::set_claim_permission { .. }, Self::claim_commission {
                            .. }) => false,
                        (Self::set_claim_permission { .. },
                            Self::adjust_pool_deposit { .. }) => false,
                        (Self::set_claim_permission { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::claim_payout_other { .. }, Self::__Ignore { .. }) =>
                            false,
                        (Self::claim_payout_other { .. }, Self::join { .. }) =>
                            false,
                        (Self::claim_payout_other { .. }, Self::bond_extra { .. })
                            => false,
                        (Self::claim_payout_other { .. }, Self::claim_payout { .. })
                            => false,
                        (Self::claim_payout_other { .. }, Self::unbond { .. }) =>
                            false,
                        (Self::claim_payout_other { .. },
                            Self::pool_withdraw_unbonded { .. }) => false,
                        (Self::claim_payout_other { .. }, Self::withdraw_unbonded {
                            .. }) => false,
                        (Self::claim_payout_other { .. }, Self::create { .. }) =>
                            false,
                        (Self::claim_payout_other { .. },
                            Self::create_with_pool_id { .. }) => false,
                        (Self::claim_payout_other { .. }, Self::nominate { .. }) =>
                            false,
                        (Self::claim_payout_other { .. }, Self::set_state { .. }) =>
                            false,
                        (Self::claim_payout_other { .. }, Self::set_metadata { .. })
                            => false,
                        (Self::claim_payout_other { .. }, Self::set_configs { .. })
                            => false,
                        (Self::claim_payout_other { .. }, Self::update_roles { .. })
                            => false,
                        (Self::claim_payout_other { .. }, Self::chill { .. }) =>
                            false,
                        (Self::claim_payout_other { .. }, Self::bond_extra_other {
                            .. }) => false,
                        (Self::claim_payout_other { .. },
                            Self::set_claim_permission { .. }) => false,
                        (Self::claim_payout_other { .. }, Self::set_commission { ..
                            }) => false,
                        (Self::claim_payout_other { .. }, Self::set_commission_max {
                            .. }) => false,
                        (Self::claim_payout_other { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::claim_payout_other { .. }, Self::claim_commission {
                            .. }) => false,
                        (Self::claim_payout_other { .. },
                            Self::adjust_pool_deposit { .. }) => false,
                        (Self::claim_payout_other { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::set_commission { .. }, Self::__Ignore { .. }) =>
                            false,
                        (Self::set_commission { .. }, Self::join { .. }) => false,
                        (Self::set_commission { .. }, Self::bond_extra { .. }) =>
                            false,
                        (Self::set_commission { .. }, Self::claim_payout { .. }) =>
                            false,
                        (Self::set_commission { .. }, Self::unbond { .. }) => false,
                        (Self::set_commission { .. }, Self::pool_withdraw_unbonded {
                            .. }) => false,
                        (Self::set_commission { .. }, Self::withdraw_unbonded { ..
                            }) => false,
                        (Self::set_commission { .. }, Self::create { .. }) => false,
                        (Self::set_commission { .. }, Self::create_with_pool_id { ..
                            }) => false,
                        (Self::set_commission { .. }, Self::nominate { .. }) =>
                            false,
                        (Self::set_commission { .. }, Self::set_state { .. }) =>
                            false,
                        (Self::set_commission { .. }, Self::set_metadata { .. }) =>
                            false,
                        (Self::set_commission { .. }, Self::set_configs { .. }) =>
                            false,
                        (Self::set_commission { .. }, Self::update_roles { .. }) =>
                            false,
                        (Self::set_commission { .. }, Self::chill { .. }) => false,
                        (Self::set_commission { .. }, Self::bond_extra_other { .. })
                            => false,
                        (Self::set_commission { .. }, Self::set_claim_permission {
                            .. }) => false,
                        (Self::set_commission { .. }, Self::claim_payout_other { ..
                            }) => false,
                        (Self::set_commission { .. }, Self::set_commission_max { ..
                            }) => false,
                        (Self::set_commission { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::set_commission { .. }, Self::claim_commission { .. })
                            => false,
                        (Self::set_commission { .. }, Self::adjust_pool_deposit { ..
                            }) => false,
                        (Self::set_commission { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::set_commission_max { .. }, Self::__Ignore { .. }) =>
                            false,
                        (Self::set_commission_max { .. }, Self::join { .. }) =>
                            false,
                        (Self::set_commission_max { .. }, Self::bond_extra { .. })
                            => false,
                        (Self::set_commission_max { .. }, Self::claim_payout { .. })
                            => false,
                        (Self::set_commission_max { .. }, Self::unbond { .. }) =>
                            false,
                        (Self::set_commission_max { .. },
                            Self::pool_withdraw_unbonded { .. }) => false,
                        (Self::set_commission_max { .. }, Self::withdraw_unbonded {
                            .. }) => false,
                        (Self::set_commission_max { .. }, Self::create { .. }) =>
                            false,
                        (Self::set_commission_max { .. },
                            Self::create_with_pool_id { .. }) => false,
                        (Self::set_commission_max { .. }, Self::nominate { .. }) =>
                            false,
                        (Self::set_commission_max { .. }, Self::set_state { .. }) =>
                            false,
                        (Self::set_commission_max { .. }, Self::set_metadata { .. })
                            => false,
                        (Self::set_commission_max { .. }, Self::set_configs { .. })
                            => false,
                        (Self::set_commission_max { .. }, Self::update_roles { .. })
                            => false,
                        (Self::set_commission_max { .. }, Self::chill { .. }) =>
                            false,
                        (Self::set_commission_max { .. }, Self::bond_extra_other {
                            .. }) => false,
                        (Self::set_commission_max { .. },
                            Self::set_claim_permission { .. }) => false,
                        (Self::set_commission_max { .. }, Self::claim_payout_other {
                            .. }) => false,
                        (Self::set_commission_max { .. }, Self::set_commission { ..
                            }) => false,
                        (Self::set_commission_max { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::set_commission_max { .. }, Self::claim_commission {
                            .. }) => false,
                        (Self::set_commission_max { .. },
                            Self::adjust_pool_deposit { .. }) => false,
                        (Self::set_commission_max { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::set_commission_change_rate { .. }, Self::__Ignore {
                            .. }) => false,
                        (Self::set_commission_change_rate { .. }, Self::join { .. })
                            => false,
                        (Self::set_commission_change_rate { .. }, Self::bond_extra {
                            .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::claim_payout { .. }) => false,
                        (Self::set_commission_change_rate { .. }, Self::unbond { ..
                            }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::pool_withdraw_unbonded { .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::withdraw_unbonded { .. }) => false,
                        (Self::set_commission_change_rate { .. }, Self::create { ..
                            }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::create_with_pool_id { .. }) => false,
                        (Self::set_commission_change_rate { .. }, Self::nominate {
                            .. }) => false,
                        (Self::set_commission_change_rate { .. }, Self::set_state {
                            .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::set_metadata { .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::set_configs { .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::update_roles { .. }) => false,
                        (Self::set_commission_change_rate { .. }, Self::chill { ..
                            }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::bond_extra_other { .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::set_claim_permission { .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::claim_payout_other { .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::set_commission { .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::set_commission_max { .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::claim_commission { .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::adjust_pool_deposit { .. }) => false,
                        (Self::set_commission_change_rate { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::claim_commission { .. }, Self::__Ignore { .. }) =>
                            false,
                        (Self::claim_commission { .. }, Self::join { .. }) => false,
                        (Self::claim_commission { .. }, Self::bond_extra { .. }) =>
                            false,
                        (Self::claim_commission { .. }, Self::claim_payout { .. })
                            => false,
                        (Self::claim_commission { .. }, Self::unbond { .. }) =>
                            false,
                        (Self::claim_commission { .. },
                            Self::pool_withdraw_unbonded { .. }) => false,
                        (Self::claim_commission { .. }, Self::withdraw_unbonded { ..
                            }) => false,
                        (Self::claim_commission { .. }, Self::create { .. }) =>
                            false,
                        (Self::claim_commission { .. }, Self::create_with_pool_id {
                            .. }) => false,
                        (Self::claim_commission { .. }, Self::nominate { .. }) =>
                            false,
                        (Self::claim_commission { .. }, Self::set_state { .. }) =>
                            false,
                        (Self::claim_commission { .. }, Self::set_metadata { .. })
                            => false,
                        (Self::claim_commission { .. }, Self::set_configs { .. }) =>
                            false,
                        (Self::claim_commission { .. }, Self::update_roles { .. })
                            => false,
                        (Self::claim_commission { .. }, Self::chill { .. }) =>
                            false,
                        (Self::claim_commission { .. }, Self::bond_extra_other { ..
                            }) => false,
                        (Self::claim_commission { .. }, Self::set_claim_permission {
                            .. }) => false,
                        (Self::claim_commission { .. }, Self::claim_payout_other {
                            .. }) => false,
                        (Self::claim_commission { .. }, Self::set_commission { .. })
                            => false,
                        (Self::claim_commission { .. }, Self::set_commission_max {
                            .. }) => false,
                        (Self::claim_commission { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::claim_commission { .. }, Self::adjust_pool_deposit {
                            .. }) => false,
                        (Self::claim_commission { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::adjust_pool_deposit { .. }, Self::__Ignore { .. }) =>
                            false,
                        (Self::adjust_pool_deposit { .. }, Self::join { .. }) =>
                            false,
                        (Self::adjust_pool_deposit { .. }, Self::bond_extra { .. })
                            => false,
                        (Self::adjust_pool_deposit { .. }, Self::claim_payout { ..
                            }) => false,
                        (Self::adjust_pool_deposit { .. }, Self::unbond { .. }) =>
                            false,
                        (Self::adjust_pool_deposit { .. },
                            Self::pool_withdraw_unbonded { .. }) => false,
                        (Self::adjust_pool_deposit { .. }, Self::withdraw_unbonded {
                            .. }) => false,
                        (Self::adjust_pool_deposit { .. }, Self::create { .. }) =>
                            false,
                        (Self::adjust_pool_deposit { .. },
                            Self::create_with_pool_id { .. }) => false,
                        (Self::adjust_pool_deposit { .. }, Self::nominate { .. }) =>
                            false,
                        (Self::adjust_pool_deposit { .. }, Self::set_state { .. })
                            => false,
                        (Self::adjust_pool_deposit { .. }, Self::set_metadata { ..
                            }) => false,
                        (Self::adjust_pool_deposit { .. }, Self::set_configs { .. })
                            => false,
                        (Self::adjust_pool_deposit { .. }, Self::update_roles { ..
                            }) => false,
                        (Self::adjust_pool_deposit { .. }, Self::chill { .. }) =>
                            false,
                        (Self::adjust_pool_deposit { .. }, Self::bond_extra_other {
                            .. }) => false,
                        (Self::adjust_pool_deposit { .. },
                            Self::set_claim_permission { .. }) => false,
                        (Self::adjust_pool_deposit { .. },
                            Self::claim_payout_other { .. }) => false,
                        (Self::adjust_pool_deposit { .. }, Self::set_commission { ..
                            }) => false,
                        (Self::adjust_pool_deposit { .. },
                            Self::set_commission_max { .. }) => false,
                        (Self::adjust_pool_deposit { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::adjust_pool_deposit { .. }, Self::claim_commission {
                            .. }) => false,
                        (Self::adjust_pool_deposit { .. },
                            Self::set_commission_claim_permission { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::__Ignore { .. }) => false,
                        (Self::set_commission_claim_permission { .. }, Self::join {
                            .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::bond_extra { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::claim_payout { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::unbond { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::pool_withdraw_unbonded { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::withdraw_unbonded { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::create { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::create_with_pool_id { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::nominate { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::set_state { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::set_metadata { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::set_configs { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::update_roles { .. }) => false,
                        (Self::set_commission_claim_permission { .. }, Self::chill {
                            .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::bond_extra_other { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::set_claim_permission { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::claim_payout_other { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::set_commission { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::set_commission_max { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::set_commission_change_rate { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::claim_commission { .. }) => false,
                        (Self::set_commission_claim_permission { .. },
                            Self::adjust_pool_deposit { .. }) => false,
                    }
                }
            }
        };
    #[allow(deprecated)]
    const _: () =
        {
            #[allow(non_camel_case_types)]
            #[automatically_derived]
            impl<T: Config> ::codec::Encode for Call<T> {
                fn size_hint(&self) -> usize {
                    1_usize +
                        match *self {
                            Call::join { ref amount, ref pool_id } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(&<<BalanceOf<T>
                                                        as ::codec::HasCompact>::Type as
                                                        ::codec::EncodeAsRef<'_,
                                                        BalanceOf<T>>>::RefType::from(amount))).saturating_add(::codec::Encode::size_hint(pool_id))
                            }
                            Call::bond_extra { ref extra } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(extra))
                            }
                            Call::claim_payout {} => { 0_usize }
                            Call::unbond { ref member_account, ref unbonding_points } =>
                                {
                                0_usize.saturating_add(::codec::Encode::size_hint(member_account)).saturating_add(::codec::Encode::size_hint(&<<BalanceOf<T>
                                                    as ::codec::HasCompact>::Type as
                                                    ::codec::EncodeAsRef<'_,
                                                    BalanceOf<T>>>::RefType::from(unbonding_points)))
                            }
                            Call::pool_withdraw_unbonded {
                                ref pool_id, ref num_slashing_spans } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(num_slashing_spans))
                            }
                            Call::withdraw_unbonded {
                                ref member_account, ref num_slashing_spans } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(member_account)).saturating_add(::codec::Encode::size_hint(num_slashing_spans))
                            }
                            Call::create {
                                ref amount, ref root, ref nominator, ref bouncer } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(&<<BalanceOf<T>
                                                                as ::codec::HasCompact>::Type as
                                                                ::codec::EncodeAsRef<'_,
                                                                BalanceOf<T>>>::RefType::from(amount))).saturating_add(::codec::Encode::size_hint(root)).saturating_add(::codec::Encode::size_hint(nominator)).saturating_add(::codec::Encode::size_hint(bouncer))
                            }
                            Call::create_with_pool_id {
                                ref amount,
                                ref root,
                                ref nominator,
                                ref bouncer,
                                ref pool_id } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(&<<BalanceOf<T>
                                                                    as ::codec::HasCompact>::Type as
                                                                    ::codec::EncodeAsRef<'_,
                                                                    BalanceOf<T>>>::RefType::from(amount))).saturating_add(::codec::Encode::size_hint(root)).saturating_add(::codec::Encode::size_hint(nominator)).saturating_add(::codec::Encode::size_hint(bouncer)).saturating_add(::codec::Encode::size_hint(pool_id))
                            }
                            Call::nominate { ref pool_id, ref validators } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(validators))
                            }
                            Call::set_state { ref pool_id, ref state } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(state))
                            }
                            Call::set_metadata { ref pool_id, ref metadata } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(metadata))
                            }
                            Call::set_configs {
                                ref min_join_bond,
                                ref min_create_bond,
                                ref max_pools,
                                ref max_members,
                                ref max_members_per_pool,
                                ref global_max_commission } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(min_join_bond)).saturating_add(::codec::Encode::size_hint(min_create_bond)).saturating_add(::codec::Encode::size_hint(max_pools)).saturating_add(::codec::Encode::size_hint(max_members)).saturating_add(::codec::Encode::size_hint(max_members_per_pool)).saturating_add(::codec::Encode::size_hint(global_max_commission))
                            }
                            Call::update_roles {
                                ref pool_id,
                                ref new_root,
                                ref new_nominator,
                                ref new_bouncer } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(new_root)).saturating_add(::codec::Encode::size_hint(new_nominator)).saturating_add(::codec::Encode::size_hint(new_bouncer))
                            }
                            Call::chill { ref pool_id } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id))
                            }
                            Call::bond_extra_other { ref member, ref extra } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(member)).saturating_add(::codec::Encode::size_hint(extra))
                            }
                            Call::set_claim_permission { ref permission } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(permission))
                            }
                            Call::claim_payout_other { ref other } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(other))
                            }
                            Call::set_commission { ref pool_id, ref new_commission } =>
                                {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(new_commission))
                            }
                            Call::set_commission_max { ref pool_id, ref max_commission }
                                => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(max_commission))
                            }
                            Call::set_commission_change_rate {
                                ref pool_id, ref change_rate } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(change_rate))
                            }
                            Call::claim_commission { ref pool_id } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id))
                            }
                            Call::adjust_pool_deposit { ref pool_id } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id))
                            }
                            Call::set_commission_claim_permission {
                                ref pool_id, ref permission } => {
                                0_usize.saturating_add(::codec::Encode::size_hint(pool_id)).saturating_add(::codec::Encode::size_hint(permission))
                            }
                            _ => 0_usize,
                        }
                }
                fn encode_to<__CodecOutputEdqy: ::codec::Output +
                    ?::core::marker::Sized>(&self,
                    __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        Call::join { ref amount, ref pool_id } => {
                            __codec_dest_edqy.push_byte(0u8 as ::core::primitive::u8);
                            {
                                ::codec::Encode::encode_to(&<<BalanceOf<T> as
                                                ::codec::HasCompact>::Type as
                                                ::codec::EncodeAsRef<'_,
                                                BalanceOf<T>>>::RefType::from(amount), __codec_dest_edqy);
                            }
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                        }
                        Call::bond_extra { ref extra } => {
                            __codec_dest_edqy.push_byte(1u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(extra, __codec_dest_edqy);
                        }
                        Call::claim_payout {} => {
                            __codec_dest_edqy.push_byte(2u8 as ::core::primitive::u8);
                        }
                        Call::unbond { ref member_account, ref unbonding_points } =>
                            {
                            __codec_dest_edqy.push_byte(3u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(member_account,
                                __codec_dest_edqy);
                            {
                                ::codec::Encode::encode_to(&<<BalanceOf<T> as
                                                ::codec::HasCompact>::Type as
                                                ::codec::EncodeAsRef<'_,
                                                BalanceOf<T>>>::RefType::from(unbonding_points),
                                    __codec_dest_edqy);
                            }
                        }
                        Call::pool_withdraw_unbonded {
                            ref pool_id, ref num_slashing_spans } => {
                            __codec_dest_edqy.push_byte(4u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(num_slashing_spans,
                                __codec_dest_edqy);
                        }
                        Call::withdraw_unbonded {
                            ref member_account, ref num_slashing_spans } => {
                            __codec_dest_edqy.push_byte(5u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(member_account,
                                __codec_dest_edqy);
                            ::codec::Encode::encode_to(num_slashing_spans,
                                __codec_dest_edqy);
                        }
                        Call::create {
                            ref amount, ref root, ref nominator, ref bouncer } => {
                            __codec_dest_edqy.push_byte(6u8 as ::core::primitive::u8);
                            {
                                ::codec::Encode::encode_to(&<<BalanceOf<T> as
                                                ::codec::HasCompact>::Type as
                                                ::codec::EncodeAsRef<'_,
                                                BalanceOf<T>>>::RefType::from(amount), __codec_dest_edqy);
                            }
                            ::codec::Encode::encode_to(root, __codec_dest_edqy);
                            ::codec::Encode::encode_to(nominator, __codec_dest_edqy);
                            ::codec::Encode::encode_to(bouncer, __codec_dest_edqy);
                        }
                        Call::create_with_pool_id {
                            ref amount,
                            ref root,
                            ref nominator,
                            ref bouncer,
                            ref pool_id } => {
                            __codec_dest_edqy.push_byte(7u8 as ::core::primitive::u8);
                            {
                                ::codec::Encode::encode_to(&<<BalanceOf<T> as
                                                ::codec::HasCompact>::Type as
                                                ::codec::EncodeAsRef<'_,
                                                BalanceOf<T>>>::RefType::from(amount), __codec_dest_edqy);
                            }
                            ::codec::Encode::encode_to(root, __codec_dest_edqy);
                            ::codec::Encode::encode_to(nominator, __codec_dest_edqy);
                            ::codec::Encode::encode_to(bouncer, __codec_dest_edqy);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                        }
                        Call::nominate { ref pool_id, ref validators } => {
                            __codec_dest_edqy.push_byte(8u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(validators, __codec_dest_edqy);
                        }
                        Call::set_state { ref pool_id, ref state } => {
                            __codec_dest_edqy.push_byte(9u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(state, __codec_dest_edqy);
                        }
                        Call::set_metadata { ref pool_id, ref metadata } => {
                            __codec_dest_edqy.push_byte(10u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(metadata, __codec_dest_edqy);
                        }
                        Call::set_configs {
                            ref min_join_bond,
                            ref min_create_bond,
                            ref max_pools,
                            ref max_members,
                            ref max_members_per_pool,
                            ref global_max_commission } => {
                            __codec_dest_edqy.push_byte(11u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(min_join_bond,
                                __codec_dest_edqy);
                            ::codec::Encode::encode_to(min_create_bond,
                                __codec_dest_edqy);
                            ::codec::Encode::encode_to(max_pools, __codec_dest_edqy);
                            ::codec::Encode::encode_to(max_members, __codec_dest_edqy);
                            ::codec::Encode::encode_to(max_members_per_pool,
                                __codec_dest_edqy);
                            ::codec::Encode::encode_to(global_max_commission,
                                __codec_dest_edqy);
                        }
                        Call::update_roles {
                            ref pool_id,
                            ref new_root,
                            ref new_nominator,
                            ref new_bouncer } => {
                            __codec_dest_edqy.push_byte(12u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(new_root, __codec_dest_edqy);
                            ::codec::Encode::encode_to(new_nominator,
                                __codec_dest_edqy);
                            ::codec::Encode::encode_to(new_bouncer, __codec_dest_edqy);
                        }
                        Call::chill { ref pool_id } => {
                            __codec_dest_edqy.push_byte(13u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                        }
                        Call::bond_extra_other { ref member, ref extra } => {
                            __codec_dest_edqy.push_byte(14u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(member, __codec_dest_edqy);
                            ::codec::Encode::encode_to(extra, __codec_dest_edqy);
                        }
                        Call::set_claim_permission { ref permission } => {
                            __codec_dest_edqy.push_byte(15u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(permission, __codec_dest_edqy);
                        }
                        Call::claim_payout_other { ref other } => {
                            __codec_dest_edqy.push_byte(16u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(other, __codec_dest_edqy);
                        }
                        Call::set_commission { ref pool_id, ref new_commission } =>
                            {
                            __codec_dest_edqy.push_byte(17u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(new_commission,
                                __codec_dest_edqy);
                        }
                        Call::set_commission_max { ref pool_id, ref max_commission }
                            => {
                            __codec_dest_edqy.push_byte(18u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(max_commission,
                                __codec_dest_edqy);
                        }
                        Call::set_commission_change_rate {
                            ref pool_id, ref change_rate } => {
                            __codec_dest_edqy.push_byte(19u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(change_rate, __codec_dest_edqy);
                        }
                        Call::claim_commission { ref pool_id } => {
                            __codec_dest_edqy.push_byte(20u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                        }
                        Call::adjust_pool_deposit { ref pool_id } => {
                            __codec_dest_edqy.push_byte(21u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                        }
                        Call::set_commission_claim_permission {
                            ref pool_id, ref permission } => {
                            __codec_dest_edqy.push_byte(22u8 as ::core::primitive::u8);
                            ::codec::Encode::encode_to(pool_id, __codec_dest_edqy);
                            ::codec::Encode::encode_to(permission, __codec_dest_edqy);
                        }
                        _ => (),
                    }
                }
            }
            #[automatically_derived]
            impl<T: Config> ::codec::EncodeLike for Call<T> { }
        };
    #[allow(deprecated)]
    const _: () =
        {
            #[allow(non_camel_case_types)]
            #[automatically_derived]
            impl<T: Config> ::codec::Decode for Call<T> {
                fn decode<__CodecInputEdqy: ::codec::Input>(__codec_input_edqy:
                        &mut __CodecInputEdqy)
                    -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy.read_byte().map_err(|e|
                                    e.chain("Could not decode `Call`, failed to read variant byte"))?
                        {
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 0u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::join {
                                                        amount: {
                                                            let __codec_res_edqy =
                                                                <<BalanceOf<T> as ::codec::HasCompact>::Type as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::join::amount`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy.into(),
                                                            }
                                                        },
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::join::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 1u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::bond_extra {
                                                        extra: {
                                                            let __codec_res_edqy =
                                                                <BondExtra<BalanceOf<T>> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::bond_extra::extra`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 2u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::claim_payout {})
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 3u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::unbond {
                                                        member_account: {
                                                            let __codec_res_edqy =
                                                                <AccountIdLookupOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::unbond::member_account`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        unbonding_points: {
                                                            let __codec_res_edqy =
                                                                <<BalanceOf<T> as ::codec::HasCompact>::Type as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::unbond::unbonding_points`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy.into(),
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 4u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::pool_withdraw_unbonded {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::pool_withdraw_unbonded::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        num_slashing_spans: {
                                                            let __codec_res_edqy =
                                                                <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::pool_withdraw_unbonded::num_slashing_spans`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 5u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::withdraw_unbonded {
                                                        member_account: {
                                                            let __codec_res_edqy =
                                                                <AccountIdLookupOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::withdraw_unbonded::member_account`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        num_slashing_spans: {
                                                            let __codec_res_edqy =
                                                                <u32 as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::withdraw_unbonded::num_slashing_spans`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 6u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::create {
                                                        amount: {
                                                            let __codec_res_edqy =
                                                                <<BalanceOf<T> as ::codec::HasCompact>::Type as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::create::amount`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy.into(),
                                                            }
                                                        },
                                                        root: {
                                                            let __codec_res_edqy =
                                                                <AccountIdLookupOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::create::root`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        nominator: {
                                                            let __codec_res_edqy =
                                                                <AccountIdLookupOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::create::nominator`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        bouncer: {
                                                            let __codec_res_edqy =
                                                                <AccountIdLookupOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::create::bouncer`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 7u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::create_with_pool_id {
                                                        amount: {
                                                            let __codec_res_edqy =
                                                                <<BalanceOf<T> as ::codec::HasCompact>::Type as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::create_with_pool_id::amount`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy.into(),
                                                            }
                                                        },
                                                        root: {
                                                            let __codec_res_edqy =
                                                                <AccountIdLookupOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::create_with_pool_id::root`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        nominator: {
                                                            let __codec_res_edqy =
                                                                <AccountIdLookupOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::create_with_pool_id::nominator`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        bouncer: {
                                                            let __codec_res_edqy =
                                                                <AccountIdLookupOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::create_with_pool_id::bouncer`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::create_with_pool_id::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 8u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::nominate {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::nominate::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        validators: {
                                                            let __codec_res_edqy =
                                                                <Vec<T::AccountId> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::nominate::validators`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 9u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::set_state {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_state::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        state: {
                                                            let __codec_res_edqy =
                                                                <PoolState as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_state::state`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 10u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::set_metadata {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_metadata::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        metadata: {
                                                            let __codec_res_edqy =
                                                                <Vec<u8> as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_metadata::metadata`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 11u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::set_configs {
                                                        min_join_bond: {
                                                            let __codec_res_edqy =
                                                                <ConfigOp<BalanceOf<T>> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_configs::min_join_bond`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        min_create_bond: {
                                                            let __codec_res_edqy =
                                                                <ConfigOp<BalanceOf<T>> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_configs::min_create_bond`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        max_pools: {
                                                            let __codec_res_edqy =
                                                                <ConfigOp<u32> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_configs::max_pools`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        max_members: {
                                                            let __codec_res_edqy =
                                                                <ConfigOp<u32> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_configs::max_members`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        max_members_per_pool: {
                                                            let __codec_res_edqy =
                                                                <ConfigOp<u32> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_configs::max_members_per_pool`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        global_max_commission: {
                                                            let __codec_res_edqy =
                                                                <ConfigOp<Perbill> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_configs::global_max_commission`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 12u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::update_roles {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::update_roles::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        new_root: {
                                                            let __codec_res_edqy =
                                                                <ConfigOp<T::AccountId> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::update_roles::new_root`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        new_nominator: {
                                                            let __codec_res_edqy =
                                                                <ConfigOp<T::AccountId> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::update_roles::new_nominator`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        new_bouncer: {
                                                            let __codec_res_edqy =
                                                                <ConfigOp<T::AccountId> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::update_roles::new_bouncer`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 13u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::chill {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::chill::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 14u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::bond_extra_other {
                                                        member: {
                                                            let __codec_res_edqy =
                                                                <AccountIdLookupOf<T> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::bond_extra_other::member`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        extra: {
                                                            let __codec_res_edqy =
                                                                <BondExtra<BalanceOf<T>> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::bond_extra_other::extra`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 15u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::set_claim_permission {
                                                        permission: {
                                                            let __codec_res_edqy =
                                                                <ClaimPermission as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_claim_permission::permission`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 16u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::claim_payout_other {
                                                        other: {
                                                            let __codec_res_edqy =
                                                                <T::AccountId as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::claim_payout_other::other`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 17u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::set_commission {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_commission::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        new_commission: {
                                                            let __codec_res_edqy =
                                                                <Option<(Perbill, T::AccountId)> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_commission::new_commission`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 18u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::set_commission_max {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_commission_max::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        max_commission: {
                                                            let __codec_res_edqy =
                                                                <Perbill as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_commission_max::max_commission`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 19u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::set_commission_change_rate {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_commission_change_rate::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        change_rate: {
                                                            let __codec_res_edqy =
                                                                <CommissionChangeRate<BlockNumberFor<T>> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_commission_change_rate::change_rate`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 20u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::claim_commission {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::claim_commission::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 21u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::adjust_pool_deposit {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::adjust_pool_deposit::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                            #[allow(clippy :: unnecessary_cast)]
                            __codec_x_edqy if
                            __codec_x_edqy == 22u8 as ::core::primitive::u8 => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Ok(Call::<T>::set_commission_claim_permission {
                                                        pool_id: {
                                                            let __codec_res_edqy =
                                                                <PoolId as ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_commission_claim_permission::pool_id`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                        permission: {
                                                            let __codec_res_edqy =
                                                                <Option<CommissionClaimPermission<T::AccountId>> as
                                                                        ::codec::Decode>::decode(__codec_input_edqy);
                                                            match __codec_res_edqy {
                                                                ::core::result::Result::Err(e) =>
                                                                    return ::core::result::Result::Err(e.chain("Could not decode `Call::set_commission_claim_permission::permission`")),
                                                                ::core::result::Result::Ok(__codec_res_edqy) =>
                                                                    __codec_res_edqy,
                                                            }
                                                        },
                                                    })
                                            })();
                        }
                        _ => {

                            #[allow(clippy :: redundant_closure_call)]
                            return (move ||
                                            {
                                                ::core::result::Result::Err(<_ as
                                                            ::core::convert::Into<_>>::into("Could not decode `Call`, variant doesn't exist"))
                                            })();
                        }
                    }
                }
            }
        };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            impl<T: Config> ::scale_info::TypeInfo for Call<T> where
                frame_support::__private::sp_std::marker::PhantomData<(T,)>: ::scale_info::TypeInfo +
                'static, BalanceOf<T>: ::scale_info::scale::HasCompact,
                BondExtra<BalanceOf<T>>: ::scale_info::TypeInfo + 'static,
                AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::scale::HasCompact,
                AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::scale::HasCompact,
                AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
                AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
                AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
                BalanceOf<T>: ::scale_info::scale::HasCompact,
                AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
                AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
                AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
                Vec<T::AccountId>: ::scale_info::TypeInfo + 'static,
                ConfigOp<BalanceOf<T>>: ::scale_info::TypeInfo + 'static,
                ConfigOp<BalanceOf<T>>: ::scale_info::TypeInfo + 'static,
                ConfigOp<T::AccountId>: ::scale_info::TypeInfo + 'static,
                ConfigOp<T::AccountId>: ::scale_info::TypeInfo + 'static,
                ConfigOp<T::AccountId>: ::scale_info::TypeInfo + 'static,
                AccountIdLookupOf<T>: ::scale_info::TypeInfo + 'static,
                BondExtra<BalanceOf<T>>: ::scale_info::TypeInfo + 'static,
                T::AccountId: ::scale_info::TypeInfo + 'static,
                Option<(Perbill, T::AccountId)>: ::scale_info::TypeInfo +
                'static,
                CommissionChangeRate<BlockNumberFor<T>>: ::scale_info::TypeInfo +
                'static,
                Option<CommissionClaimPermission<T::AccountId>>: ::scale_info::TypeInfo +
                'static, T: Config + 'static {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder().path(::scale_info::Path::new_with_replace("Call",
                                        "pallet_nomination_pools::pallet",
                                        &[])).type_params(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([::scale_info::TypeParameter::new("T",
                                                    ::core::option::Option::None)]))).docs_always(&["Contains a variant per dispatchable extrinsic that this pallet has."]).variant(::scale_info::build::Variants::new().variant("join",
                                                                                                                    |v|
                                                                                                                        v.index(0u8 as
                                                                                                                                        ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                                            f.compact::<BalanceOf<T>>().name("amount").type_name("BalanceOf<T>")).field(|f|
                                                                                                                                        f.ty::<PoolId>().name("pool_id").type_name("PoolId"))).docs_always(&["See [`Pallet::join`]."])).variant("bond_extra",
                                                                                                                |v|
                                                                                                                    v.index(1u8 as
                                                                                                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                                    f.ty::<BondExtra<BalanceOf<T>>>().name("extra").type_name("BondExtra<BalanceOf<T>>"))).docs_always(&["See [`Pallet::bond_extra`]."])).variant("claim_payout",
                                                                                                            |v|
                                                                                                                v.index(2u8 as
                                                                                                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named()).docs_always(&["See [`Pallet::claim_payout`]."])).variant("unbond",
                                                                                                        |v|
                                                                                                            v.index(3u8 as
                                                                                                                            ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                                f.ty::<AccountIdLookupOf<T>>().name("member_account").type_name("AccountIdLookupOf<T>")).field(|f|
                                                                                                                            f.compact::<BalanceOf<T>>().name("unbonding_points").type_name("BalanceOf<T>"))).docs_always(&["See [`Pallet::unbond`]."])).variant("pool_withdraw_unbonded",
                                                                                                    |v|
                                                                                                        v.index(4u8 as
                                                                                                                        ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                            f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                                                        f.ty::<u32>().name("num_slashing_spans").type_name("u32"))).docs_always(&["See [`Pallet::pool_withdraw_unbonded`]."])).variant("withdraw_unbonded",
                                                                                                |v|
                                                                                                    v.index(5u8 as
                                                                                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                        f.ty::<AccountIdLookupOf<T>>().name("member_account").type_name("AccountIdLookupOf<T>")).field(|f|
                                                                                                                    f.ty::<u32>().name("num_slashing_spans").type_name("u32"))).docs_always(&["See [`Pallet::withdraw_unbonded`]."])).variant("create",
                                                                                            |v|
                                                                                                v.index(6u8 as
                                                                                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                            f.compact::<BalanceOf<T>>().name("amount").type_name("BalanceOf<T>")).field(|f|
                                                                                                                        f.ty::<AccountIdLookupOf<T>>().name("root").type_name("AccountIdLookupOf<T>")).field(|f|
                                                                                                                    f.ty::<AccountIdLookupOf<T>>().name("nominator").type_name("AccountIdLookupOf<T>")).field(|f|
                                                                                                                f.ty::<AccountIdLookupOf<T>>().name("bouncer").type_name("AccountIdLookupOf<T>"))).docs_always(&["See [`Pallet::create`]."])).variant("create_with_pool_id",
                                                                                        |v|
                                                                                            v.index(7u8 as
                                                                                                            ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                            f.compact::<BalanceOf<T>>().name("amount").type_name("BalanceOf<T>")).field(|f|
                                                                                                                        f.ty::<AccountIdLookupOf<T>>().name("root").type_name("AccountIdLookupOf<T>")).field(|f|
                                                                                                                    f.ty::<AccountIdLookupOf<T>>().name("nominator").type_name("AccountIdLookupOf<T>")).field(|f|
                                                                                                                f.ty::<AccountIdLookupOf<T>>().name("bouncer").type_name("AccountIdLookupOf<T>")).field(|f|
                                                                                                            f.ty::<PoolId>().name("pool_id").type_name("PoolId"))).docs_always(&["See [`Pallet::create_with_pool_id`]."])).variant("nominate",
                                                                                    |v|
                                                                                        v.index(8u8 as
                                                                                                        ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                            f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                                        f.ty::<Vec<T::AccountId>>().name("validators").type_name("Vec<T::AccountId>"))).docs_always(&["See [`Pallet::nominate`]."])).variant("set_state",
                                                                                |v|
                                                                                    v.index(9u8 as
                                                                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                        f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                                    f.ty::<PoolState>().name("state").type_name("PoolState"))).docs_always(&["See [`Pallet::set_state`]."])).variant("set_metadata",
                                                                            |v|
                                                                                v.index(10u8 as
                                                                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                                f.ty::<Vec<u8>>().name("metadata").type_name("Vec<u8>"))).docs_always(&["See [`Pallet::set_metadata`]."])).variant("set_configs",
                                                                        |v|
                                                                            v.index(11u8 as
                                                                                            ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                                f.ty::<ConfigOp<BalanceOf<T>>>().name("min_join_bond").type_name("ConfigOp<BalanceOf<T>>")).field(|f|
                                                                                                            f.ty::<ConfigOp<BalanceOf<T>>>().name("min_create_bond").type_name("ConfigOp<BalanceOf<T>>")).field(|f|
                                                                                                        f.ty::<ConfigOp<u32>>().name("max_pools").type_name("ConfigOp<u32>")).field(|f|
                                                                                                    f.ty::<ConfigOp<u32>>().name("max_members").type_name("ConfigOp<u32>")).field(|f|
                                                                                                f.ty::<ConfigOp<u32>>().name("max_members_per_pool").type_name("ConfigOp<u32>")).field(|f|
                                                                                            f.ty::<ConfigOp<Perbill>>().name("global_max_commission").type_name("ConfigOp<Perbill>"))).docs_always(&["See [`Pallet::set_configs`]."])).variant("update_roles",
                                                                    |v|
                                                                        v.index(12u8 as
                                                                                        ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                                                f.ty::<ConfigOp<T::AccountId>>().name("new_root").type_name("ConfigOp<T::AccountId>")).field(|f|
                                                                                            f.ty::<ConfigOp<T::AccountId>>().name("new_nominator").type_name("ConfigOp<T::AccountId>")).field(|f|
                                                                                        f.ty::<ConfigOp<T::AccountId>>().name("new_bouncer").type_name("ConfigOp<T::AccountId>"))).docs_always(&["See [`Pallet::update_roles`]."])).variant("chill",
                                                                |v|
                                                                    v.index(13u8 as
                                                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId"))).docs_always(&["See [`Pallet::chill`]."])).variant("bond_extra_other",
                                                            |v|
                                                                v.index(14u8 as
                                                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                                    f.ty::<AccountIdLookupOf<T>>().name("member").type_name("AccountIdLookupOf<T>")).field(|f|
                                                                                f.ty::<BondExtra<BalanceOf<T>>>().name("extra").type_name("BondExtra<BalanceOf<T>>"))).docs_always(&["See [`Pallet::bond_extra_other`]."])).variant("set_claim_permission",
                                                        |v|
                                                            v.index(15u8 as
                                                                            ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                            f.ty::<ClaimPermission>().name("permission").type_name("ClaimPermission"))).docs_always(&["See [`Pallet::set_claim_permission`]."])).variant("claim_payout_other",
                                                    |v|
                                                        v.index(16u8 as
                                                                        ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                        f.ty::<T::AccountId>().name("other").type_name("T::AccountId"))).docs_always(&["See [`Pallet::claim_payout_other`]."])).variant("set_commission",
                                                |v|
                                                    v.index(17u8 as
                                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                        f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                    f.ty::<Option<(Perbill,
                                                                                T::AccountId)>>().name("new_commission").type_name("Option<(Perbill, T::AccountId)>"))).docs_always(&["See [`Pallet::set_commission`]."])).variant("set_commission_max",
                                            |v|
                                                v.index(18u8 as
                                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                                f.ty::<Perbill>().name("max_commission").type_name("Perbill"))).docs_always(&["See [`Pallet::set_commission_max`]."])).variant("set_commission_change_rate",
                                        |v|
                                            v.index(19u8 as
                                                            ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                                f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                            f.ty::<CommissionChangeRate<BlockNumberFor<T>>>().name("change_rate").type_name("CommissionChangeRate<BlockNumberFor<T>>"))).docs_always(&["See [`Pallet::set_commission_change_rate`]."])).variant("claim_commission",
                                    |v|
                                        v.index(20u8 as
                                                        ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                        f.ty::<PoolId>().name("pool_id").type_name("PoolId"))).docs_always(&["See [`Pallet::claim_commission`]."])).variant("adjust_pool_deposit",
                                |v|
                                    v.index(21u8 as
                                                    ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId"))).docs_always(&["See [`Pallet::adjust_pool_deposit`]."])).variant("set_commission_claim_permission",
                            |v|
                                v.index(22u8 as
                                                ::core::primitive::u8).fields(::scale_info::build::Fields::named().field(|f|
                                                    f.ty::<PoolId>().name("pool_id").type_name("PoolId")).field(|f|
                                                f.ty::<Option<CommissionClaimPermission<T::AccountId>>>().name("permission").type_name("Option<CommissionClaimPermission<T::AccountId>>"))).docs_always(&["See [`Pallet::set_commission_claim_permission`]."])))
                }
            }
            ;
        };
    impl<T: Config> Call<T> {
        #[doc = "Create a call with the variant `join`."]
        pub fn new_call_variant_join(amount: BalanceOf<T>, pool_id: PoolId)
            -> Self {
            Self::join { amount, pool_id }
        }
        #[doc = "Create a call with the variant `bond_extra`."]
        pub fn new_call_variant_bond_extra(extra: BondExtra<BalanceOf<T>>)
            -> Self {
            Self::bond_extra { extra }
        }
        #[doc = "Create a call with the variant `claim_payout`."]
        pub fn new_call_variant_claim_payout() -> Self {
            Self::claim_payout {}
        }
        #[doc = "Create a call with the variant `unbond`."]
        pub fn new_call_variant_unbond(member_account: AccountIdLookupOf<T>,
            unbonding_points: BalanceOf<T>) -> Self {
            Self::unbond { member_account, unbonding_points }
        }
        #[doc = "Create a call with the variant `pool_withdraw_unbonded`."]
        pub fn new_call_variant_pool_withdraw_unbonded(pool_id: PoolId,
            num_slashing_spans: u32) -> Self {
            Self::pool_withdraw_unbonded { pool_id, num_slashing_spans }
        }
        #[doc = "Create a call with the variant `withdraw_unbonded`."]
        pub fn new_call_variant_withdraw_unbonded(member_account:
                AccountIdLookupOf<T>, num_slashing_spans: u32) -> Self {
            Self::withdraw_unbonded { member_account, num_slashing_spans }
        }
        #[doc = "Create a call with the variant `create`."]
        pub fn new_call_variant_create(amount: BalanceOf<T>,
            root: AccountIdLookupOf<T>, nominator: AccountIdLookupOf<T>,
            bouncer: AccountIdLookupOf<T>) -> Self {
            Self::create { amount, root, nominator, bouncer }
        }
        #[doc = "Create a call with the variant `create_with_pool_id`."]
        pub fn new_call_variant_create_with_pool_id(amount: BalanceOf<T>,
            root: AccountIdLookupOf<T>, nominator: AccountIdLookupOf<T>,
            bouncer: AccountIdLookupOf<T>, pool_id: PoolId) -> Self {
            Self::create_with_pool_id {
                amount,
                root,
                nominator,
                bouncer,
                pool_id,
            }
        }
        #[doc = "Create a call with the variant `nominate`."]
        pub fn new_call_variant_nominate(pool_id: PoolId,
            validators: Vec<T::AccountId>) -> Self {
            Self::nominate { pool_id, validators }
        }
        #[doc = "Create a call with the variant `set_state`."]
        pub fn new_call_variant_set_state(pool_id: PoolId, state: PoolState)
            -> Self {
            Self::set_state { pool_id, state }
        }
        #[doc = "Create a call with the variant `set_metadata`."]
        pub fn new_call_variant_set_metadata(pool_id: PoolId,
            metadata: Vec<u8>) -> Self {
            Self::set_metadata { pool_id, metadata }
        }
        #[doc = "Create a call with the variant `set_configs`."]
        pub fn new_call_variant_set_configs(min_join_bond:
                ConfigOp<BalanceOf<T>>,
            min_create_bond: ConfigOp<BalanceOf<T>>, max_pools: ConfigOp<u32>,
            max_members: ConfigOp<u32>, max_members_per_pool: ConfigOp<u32>,
            global_max_commission: ConfigOp<Perbill>) -> Self {
            Self::set_configs {
                min_join_bond,
                min_create_bond,
                max_pools,
                max_members,
                max_members_per_pool,
                global_max_commission,
            }
        }
        #[doc = "Create a call with the variant `update_roles`."]
        pub fn new_call_variant_update_roles(pool_id: PoolId,
            new_root: ConfigOp<T::AccountId>,
            new_nominator: ConfigOp<T::AccountId>,
            new_bouncer: ConfigOp<T::AccountId>) -> Self {
            Self::update_roles {
                pool_id,
                new_root,
                new_nominator,
                new_bouncer,
            }
        }
        #[doc = "Create a call with the variant `chill`."]
        pub fn new_call_variant_chill(pool_id: PoolId) -> Self {
            Self::chill { pool_id }
        }
        #[doc = "Create a call with the variant `bond_extra_other`."]
        pub fn new_call_variant_bond_extra_other(member: AccountIdLookupOf<T>,
            extra: BondExtra<BalanceOf<T>>) -> Self {
            Self::bond_extra_other { member, extra }
        }
        #[doc = "Create a call with the variant `set_claim_permission`."]
        pub fn new_call_variant_set_claim_permission(permission:
                ClaimPermission) -> Self {
            Self::set_claim_permission { permission }
        }
        #[doc = "Create a call with the variant `claim_payout_other`."]
        pub fn new_call_variant_claim_payout_other(other: T::AccountId)
            -> Self {
            Self::claim_payout_other { other }
        }
        #[doc = "Create a call with the variant `set_commission`."]
        pub fn new_call_variant_set_commission(pool_id: PoolId,
            new_commission: Option<(Perbill, T::AccountId)>) -> Self {
            Self::set_commission { pool_id, new_commission }
        }
        #[doc = "Create a call with the variant `set_commission_max`."]
        pub fn new_call_variant_set_commission_max(pool_id: PoolId,
            max_commission: Perbill) -> Self {
            Self::set_commission_max { pool_id, max_commission }
        }
        #[doc =
        "Create a call with the variant `set_commission_change_rate`."]
        pub fn new_call_variant_set_commission_change_rate(pool_id: PoolId,
            change_rate: CommissionChangeRate<BlockNumberFor<T>>) -> Self {
            Self::set_commission_change_rate { pool_id, change_rate }
        }
        #[doc = "Create a call with the variant `claim_commission`."]
        pub fn new_call_variant_claim_commission(pool_id: PoolId) -> Self {
            Self::claim_commission { pool_id }
        }
        #[doc = "Create a call with the variant `adjust_pool_deposit`."]
        pub fn new_call_variant_adjust_pool_deposit(pool_id: PoolId) -> Self {
            Self::adjust_pool_deposit { pool_id }
        }
        #[doc =
        "Create a call with the variant `set_commission_claim_permission`."]
        pub fn new_call_variant_set_commission_claim_permission(pool_id:
                PoolId,
            permission: Option<CommissionClaimPermission<T::AccountId>>)
            -> Self {
            Self::set_commission_claim_permission { pool_id, permission }
        }
    }
    impl<T: Config> frame_support::dispatch::GetDispatchInfo for Call<T> {
        fn get_dispatch_info(&self) -> frame_support::dispatch::DispatchInfo {
            match *self {
                Self::join { ref amount, ref pool_id } => {
                    let __pallet_base_weight = T::WeightInfo::join();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&BalanceOf<T>,
                                &PoolId)>>::weigh_data(&__pallet_base_weight,
                            (amount, pool_id));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&BalanceOf<T>,
                                &PoolId)>>::classify_dispatch(&__pallet_base_weight,
                            (amount, pool_id));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&BalanceOf<T>,
                                &PoolId)>>::pays_fee(&__pallet_base_weight,
                            (amount, pool_id));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::bond_extra { ref extra } => {
                    let __pallet_base_weight =
                        T::WeightInfo::bond_extra_transfer().max(T::WeightInfo::bond_extra_other());
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&BondExtra<BalanceOf<T>>,)>>::weigh_data(&__pallet_base_weight,
                            (extra,));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&BondExtra<BalanceOf<T>>,)>>::classify_dispatch(&__pallet_base_weight,
                            (extra,));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&BondExtra<BalanceOf<T>>,)>>::pays_fee(&__pallet_base_weight,
                            (extra,));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::claim_payout {} => {
                    let __pallet_base_weight = T::WeightInfo::claim_payout();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<()>>::weigh_data(&__pallet_base_weight,
                            ());
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<()>>::classify_dispatch(&__pallet_base_weight,
                            ());
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<()>>::pays_fee(&__pallet_base_weight,
                            ());
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::unbond { ref member_account, ref unbonding_points } => {
                    let __pallet_base_weight = T::WeightInfo::unbond();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&AccountIdLookupOf<T>,
                                &BalanceOf<T>)>>::weigh_data(&__pallet_base_weight,
                            (member_account, unbonding_points));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&AccountIdLookupOf<T>,
                                &BalanceOf<T>)>>::classify_dispatch(&__pallet_base_weight,
                            (member_account, unbonding_points));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&AccountIdLookupOf<T>,
                                &BalanceOf<T>)>>::pays_fee(&__pallet_base_weight,
                            (member_account, unbonding_points));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::pool_withdraw_unbonded {
                    ref pool_id, ref num_slashing_spans } => {
                    let __pallet_base_weight =
                        T::WeightInfo::pool_withdraw_unbonded(*num_slashing_spans);
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,
                                &u32)>>::weigh_data(&__pallet_base_weight,
                            (pool_id, num_slashing_spans));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,
                                &u32)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id, num_slashing_spans));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,
                                &u32)>>::pays_fee(&__pallet_base_weight,
                            (pool_id, num_slashing_spans));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::withdraw_unbonded {
                    ref member_account, ref num_slashing_spans } => {
                    let __pallet_base_weight =
                        T::WeightInfo::withdraw_unbonded_kill(*num_slashing_spans);
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&AccountIdLookupOf<T>,
                                &u32)>>::weigh_data(&__pallet_base_weight,
                            (member_account, num_slashing_spans));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&AccountIdLookupOf<T>,
                                &u32)>>::classify_dispatch(&__pallet_base_weight,
                            (member_account, num_slashing_spans));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&AccountIdLookupOf<T>,
                                &u32)>>::pays_fee(&__pallet_base_weight,
                            (member_account, num_slashing_spans));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::create {
                    ref amount, ref root, ref nominator, ref bouncer } => {
                    let __pallet_base_weight = T::WeightInfo::create();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&BalanceOf<T>,
                                &AccountIdLookupOf<T>, &AccountIdLookupOf<T>,
                                &AccountIdLookupOf<T>)>>::weigh_data(&__pallet_base_weight,
                            (amount, root, nominator, bouncer));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&BalanceOf<T>,
                                &AccountIdLookupOf<T>, &AccountIdLookupOf<T>,
                                &AccountIdLookupOf<T>)>>::classify_dispatch(&__pallet_base_weight,
                            (amount, root, nominator, bouncer));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&BalanceOf<T>,
                                &AccountIdLookupOf<T>, &AccountIdLookupOf<T>,
                                &AccountIdLookupOf<T>)>>::pays_fee(&__pallet_base_weight,
                            (amount, root, nominator, bouncer));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::create_with_pool_id {
                    ref amount,
                    ref root,
                    ref nominator,
                    ref bouncer,
                    ref pool_id } => {
                    let __pallet_base_weight = T::WeightInfo::create();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&BalanceOf<T>,
                                &AccountIdLookupOf<T>, &AccountIdLookupOf<T>,
                                &AccountIdLookupOf<T>,
                                &PoolId)>>::weigh_data(&__pallet_base_weight,
                            (amount, root, nominator, bouncer, pool_id));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&BalanceOf<T>,
                                &AccountIdLookupOf<T>, &AccountIdLookupOf<T>,
                                &AccountIdLookupOf<T>,
                                &PoolId)>>::classify_dispatch(&__pallet_base_weight,
                            (amount, root, nominator, bouncer, pool_id));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&BalanceOf<T>,
                                &AccountIdLookupOf<T>, &AccountIdLookupOf<T>,
                                &AccountIdLookupOf<T>,
                                &PoolId)>>::pays_fee(&__pallet_base_weight,
                            (amount, root, nominator, bouncer, pool_id));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::nominate { ref pool_id, ref validators } => {
                    let __pallet_base_weight =
                        T::WeightInfo::nominate(validators.len() as u32);
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,
                                &Vec<T::AccountId>)>>::weigh_data(&__pallet_base_weight,
                            (pool_id, validators));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,
                                &Vec<T::AccountId>)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id, validators));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,
                                &Vec<T::AccountId>)>>::pays_fee(&__pallet_base_weight,
                            (pool_id, validators));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_state { ref pool_id, ref state } => {
                    let __pallet_base_weight = T::WeightInfo::set_state();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,
                                &PoolState)>>::weigh_data(&__pallet_base_weight,
                            (pool_id, state));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,
                                &PoolState)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id, state));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,
                                &PoolState)>>::pays_fee(&__pallet_base_weight,
                            (pool_id, state));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_metadata { ref pool_id, ref metadata } => {
                    let __pallet_base_weight =
                        T::WeightInfo::set_metadata(metadata.len() as u32);
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,
                                &Vec<u8>)>>::weigh_data(&__pallet_base_weight,
                            (pool_id, metadata));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,
                                &Vec<u8>)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id, metadata));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,
                                &Vec<u8>)>>::pays_fee(&__pallet_base_weight,
                            (pool_id, metadata));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_configs {
                    ref min_join_bond,
                    ref min_create_bond,
                    ref max_pools,
                    ref max_members,
                    ref max_members_per_pool,
                    ref global_max_commission } => {
                    let __pallet_base_weight = T::WeightInfo::set_configs();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&ConfigOp<BalanceOf<T>>,
                                &ConfigOp<BalanceOf<T>>, &ConfigOp<u32>, &ConfigOp<u32>,
                                &ConfigOp<u32>,
                                &ConfigOp<Perbill>)>>::weigh_data(&__pallet_base_weight,
                            (min_join_bond, min_create_bond, max_pools, max_members,
                                max_members_per_pool, global_max_commission));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&ConfigOp<BalanceOf<T>>,
                                &ConfigOp<BalanceOf<T>>, &ConfigOp<u32>, &ConfigOp<u32>,
                                &ConfigOp<u32>,
                                &ConfigOp<Perbill>)>>::classify_dispatch(&__pallet_base_weight,
                            (min_join_bond, min_create_bond, max_pools, max_members,
                                max_members_per_pool, global_max_commission));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&ConfigOp<BalanceOf<T>>,
                                &ConfigOp<BalanceOf<T>>, &ConfigOp<u32>, &ConfigOp<u32>,
                                &ConfigOp<u32>,
                                &ConfigOp<Perbill>)>>::pays_fee(&__pallet_base_weight,
                            (min_join_bond, min_create_bond, max_pools, max_members,
                                max_members_per_pool, global_max_commission));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::update_roles {
                    ref pool_id,
                    ref new_root,
                    ref new_nominator,
                    ref new_bouncer } => {
                    let __pallet_base_weight = T::WeightInfo::update_roles();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,
                                &ConfigOp<T::AccountId>, &ConfigOp<T::AccountId>,
                                &ConfigOp<T::AccountId>)>>::weigh_data(&__pallet_base_weight,
                            (pool_id, new_root, new_nominator, new_bouncer));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,
                                &ConfigOp<T::AccountId>, &ConfigOp<T::AccountId>,
                                &ConfigOp<T::AccountId>)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id, new_root, new_nominator, new_bouncer));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,
                                &ConfigOp<T::AccountId>, &ConfigOp<T::AccountId>,
                                &ConfigOp<T::AccountId>)>>::pays_fee(&__pallet_base_weight,
                            (pool_id, new_root, new_nominator, new_bouncer));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::chill { ref pool_id } => {
                    let __pallet_base_weight = T::WeightInfo::chill();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,)>>::weigh_data(&__pallet_base_weight,
                            (pool_id,));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id,));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,)>>::pays_fee(&__pallet_base_weight,
                            (pool_id,));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::bond_extra_other { ref member, ref extra } => {
                    let __pallet_base_weight =
                        T::WeightInfo::bond_extra_transfer().max(T::WeightInfo::bond_extra_other());
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&AccountIdLookupOf<T>,
                                &BondExtra<BalanceOf<T>>)>>::weigh_data(&__pallet_base_weight,
                            (member, extra));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&AccountIdLookupOf<T>,
                                &BondExtra<BalanceOf<T>>)>>::classify_dispatch(&__pallet_base_weight,
                            (member, extra));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&AccountIdLookupOf<T>,
                                &BondExtra<BalanceOf<T>>)>>::pays_fee(&__pallet_base_weight,
                            (member, extra));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_claim_permission { ref permission } => {
                    let __pallet_base_weight =
                        T::DbWeight::get().reads_writes(1, 1);
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&ClaimPermission,)>>::weigh_data(&__pallet_base_weight,
                            (permission,));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&ClaimPermission,)>>::classify_dispatch(&__pallet_base_weight,
                            (permission,));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&ClaimPermission,)>>::pays_fee(&__pallet_base_weight,
                            (permission,));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::claim_payout_other { ref other } => {
                    let __pallet_base_weight = T::WeightInfo::claim_payout();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&T::AccountId,)>>::weigh_data(&__pallet_base_weight,
                            (other,));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&T::AccountId,)>>::classify_dispatch(&__pallet_base_weight,
                            (other,));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&T::AccountId,)>>::pays_fee(&__pallet_base_weight,
                            (other,));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_commission { ref pool_id, ref new_commission } => {
                    let __pallet_base_weight = T::WeightInfo::set_commission();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,
                                &Option<(Perbill,
                                T::AccountId)>)>>::weigh_data(&__pallet_base_weight,
                            (pool_id, new_commission));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,
                                &Option<(Perbill,
                                T::AccountId)>)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id, new_commission));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,
                                &Option<(Perbill,
                                T::AccountId)>)>>::pays_fee(&__pallet_base_weight,
                            (pool_id, new_commission));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_commission_max { ref pool_id, ref max_commission }
                    => {
                    let __pallet_base_weight =
                        T::WeightInfo::set_commission_max();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,
                                &Perbill)>>::weigh_data(&__pallet_base_weight,
                            (pool_id, max_commission));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,
                                &Perbill)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id, max_commission));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,
                                &Perbill)>>::pays_fee(&__pallet_base_weight,
                            (pool_id, max_commission));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_commission_change_rate {
                    ref pool_id, ref change_rate } => {
                    let __pallet_base_weight =
                        T::WeightInfo::set_commission_change_rate();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,
                                &CommissionChangeRate<BlockNumberFor<T>>)>>::weigh_data(&__pallet_base_weight,
                            (pool_id, change_rate));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,
                                &CommissionChangeRate<BlockNumberFor<T>>)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id, change_rate));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,
                                &CommissionChangeRate<BlockNumberFor<T>>)>>::pays_fee(&__pallet_base_weight,
                            (pool_id, change_rate));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::claim_commission { ref pool_id } => {
                    let __pallet_base_weight =
                        T::WeightInfo::claim_commission();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,)>>::weigh_data(&__pallet_base_weight,
                            (pool_id,));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id,));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,)>>::pays_fee(&__pallet_base_weight,
                            (pool_id,));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::adjust_pool_deposit { ref pool_id } => {
                    let __pallet_base_weight =
                        T::WeightInfo::adjust_pool_deposit();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,)>>::weigh_data(&__pallet_base_weight,
                            (pool_id,));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id,));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,)>>::pays_fee(&__pallet_base_weight,
                            (pool_id,));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::set_commission_claim_permission {
                    ref pool_id, ref permission } => {
                    let __pallet_base_weight =
                        T::WeightInfo::set_commission_claim_permission();
                    let __pallet_weight =
                        <dyn frame_support::dispatch::WeighData<(&PoolId,
                                &Option<CommissionClaimPermission<T::AccountId>>)>>::weigh_data(&__pallet_base_weight,
                            (pool_id, permission));
                    let __pallet_class =
                        <dyn frame_support::dispatch::ClassifyDispatch<(&PoolId,
                                &Option<CommissionClaimPermission<T::AccountId>>)>>::classify_dispatch(&__pallet_base_weight,
                            (pool_id, permission));
                    let __pallet_pays_fee =
                        <dyn frame_support::dispatch::PaysFee<(&PoolId,
                                &Option<CommissionClaimPermission<T::AccountId>>)>>::pays_fee(&__pallet_base_weight,
                            (pool_id, permission));
                    frame_support::dispatch::DispatchInfo {
                        weight: __pallet_weight,
                        class: __pallet_class,
                        pays_fee: __pallet_pays_fee,
                    }
                }
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                            format_args!("__Ignore cannot be used")));
                }
            }
        }
    }
    impl<T: Config> frame_support::dispatch::CheckIfFeeless for Call<T> {
        type Origin = frame_system::pallet_prelude::OriginFor<T>;
        #[allow(unused_variables)]
        fn is_feeless(&self, origin: &Self::Origin) -> bool {
            match *self {
                Self::join { ref amount, ref pool_id } => { false }
                Self::bond_extra { ref extra } => { false }
                Self::claim_payout {} => { false }
                Self::unbond { ref member_account, ref unbonding_points } => {
                    false
                }
                Self::pool_withdraw_unbonded {
                    ref pool_id, ref num_slashing_spans } => {
                    false
                }
                Self::withdraw_unbonded {
                    ref member_account, ref num_slashing_spans } => {
                    false
                }
                Self::create {
                    ref amount, ref root, ref nominator, ref bouncer } => {
                    false
                }
                Self::create_with_pool_id {
                    ref amount,
                    ref root,
                    ref nominator,
                    ref bouncer,
                    ref pool_id } => {
                    false
                }
                Self::nominate { ref pool_id, ref validators } => { false }
                Self::set_state { ref pool_id, ref state } => { false }
                Self::set_metadata { ref pool_id, ref metadata } => { false }
                Self::set_configs {
                    ref min_join_bond,
                    ref min_create_bond,
                    ref max_pools,
                    ref max_members,
                    ref max_members_per_pool,
                    ref global_max_commission } => {
                    false
                }
                Self::update_roles {
                    ref pool_id,
                    ref new_root,
                    ref new_nominator,
                    ref new_bouncer } => {
                    false
                }
                Self::chill { ref pool_id } => { false }
                Self::bond_extra_other { ref member, ref extra } => { false }
                Self::set_claim_permission { ref permission } => { false }
                Self::claim_payout_other { ref other } => { false }
                Self::set_commission { ref pool_id, ref new_commission } => {
                    false
                }
                Self::set_commission_max { ref pool_id, ref max_commission }
                    => {
                    false
                }
                Self::set_commission_change_rate {
                    ref pool_id, ref change_rate } => {
                    false
                }
                Self::claim_commission { ref pool_id } => { false }
                Self::adjust_pool_deposit { ref pool_id } => { false }
                Self::set_commission_claim_permission {
                    ref pool_id, ref permission } => {
                    false
                }
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                            format_args!("__Ignore cannot be used")));
                }
            }
        }
    }
    impl<T: Config> frame_support::traits::GetCallName for Call<T> {
        fn get_call_name(&self) -> &'static str {
            match *self {
                Self::join { .. } => "join",
                Self::bond_extra { .. } => "bond_extra",
                Self::claim_payout { .. } => "claim_payout",
                Self::unbond { .. } => "unbond",
                Self::pool_withdraw_unbonded { .. } =>
                    "pool_withdraw_unbonded",
                Self::withdraw_unbonded { .. } => "withdraw_unbonded",
                Self::create { .. } => "create",
                Self::create_with_pool_id { .. } => "create_with_pool_id",
                Self::nominate { .. } => "nominate",
                Self::set_state { .. } => "set_state",
                Self::set_metadata { .. } => "set_metadata",
                Self::set_configs { .. } => "set_configs",
                Self::update_roles { .. } => "update_roles",
                Self::chill { .. } => "chill",
                Self::bond_extra_other { .. } => "bond_extra_other",
                Self::set_claim_permission { .. } => "set_claim_permission",
                Self::claim_payout_other { .. } => "claim_payout_other",
                Self::set_commission { .. } => "set_commission",
                Self::set_commission_max { .. } => "set_commission_max",
                Self::set_commission_change_rate { .. } =>
                    "set_commission_change_rate",
                Self::claim_commission { .. } => "claim_commission",
                Self::adjust_pool_deposit { .. } => "adjust_pool_deposit",
                Self::set_commission_claim_permission { .. } =>
                    "set_commission_claim_permission",
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                            format_args!("__PhantomItem cannot be used.")));
                }
            }
        }
        fn get_call_names() -> &'static [&'static str] {
            &["join", "bond_extra", "claim_payout", "unbond",
                        "pool_withdraw_unbonded", "withdraw_unbonded", "create",
                        "create_with_pool_id", "nominate", "set_state",
                        "set_metadata", "set_configs", "update_roles", "chill",
                        "bond_extra_other", "set_claim_permission",
                        "claim_payout_other", "set_commission",
                        "set_commission_max", "set_commission_change_rate",
                        "claim_commission", "adjust_pool_deposit",
                        "set_commission_claim_permission"]
        }
    }
    impl<T: Config> frame_support::traits::GetCallIndex for Call<T> {
        fn get_call_index(&self) -> u8 {
            match *self {
                Self::join { .. } => 0u8,
                Self::bond_extra { .. } => 1u8,
                Self::claim_payout { .. } => 2u8,
                Self::unbond { .. } => 3u8,
                Self::pool_withdraw_unbonded { .. } => 4u8,
                Self::withdraw_unbonded { .. } => 5u8,
                Self::create { .. } => 6u8,
                Self::create_with_pool_id { .. } => 7u8,
                Self::nominate { .. } => 8u8,
                Self::set_state { .. } => 9u8,
                Self::set_metadata { .. } => 10u8,
                Self::set_configs { .. } => 11u8,
                Self::update_roles { .. } => 12u8,
                Self::chill { .. } => 13u8,
                Self::bond_extra_other { .. } => 14u8,
                Self::set_claim_permission { .. } => 15u8,
                Self::claim_payout_other { .. } => 16u8,
                Self::set_commission { .. } => 17u8,
                Self::set_commission_max { .. } => 18u8,
                Self::set_commission_change_rate { .. } => 19u8,
                Self::claim_commission { .. } => 20u8,
                Self::adjust_pool_deposit { .. } => 21u8,
                Self::set_commission_claim_permission { .. } => 22u8,
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                            format_args!("__PhantomItem cannot be used.")));
                }
            }
        }
        fn get_call_indices() -> &'static [u8] {
            &[0u8, 1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8,
                        12u8, 13u8, 14u8, 15u8, 16u8, 17u8, 18u8, 19u8, 20u8, 21u8,
                        22u8]
        }
    }
    impl<T: Config> frame_support::traits::UnfilteredDispatchable for Call<T>
        {
        type RuntimeOrigin = frame_system::pallet_prelude::OriginFor<T>;
        fn dispatch_bypass_filter(self, origin: Self::RuntimeOrigin)
            -> frame_support::dispatch::DispatchResultWithPostInfo {
            frame_support::dispatch_context::run_in_context(||
                    {
                        match self {
                            Self::join { amount, pool_id } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("join",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::join(origin, amount,
                                            pool_id).map(Into::into).map_err(Into::into)
                            }
                            Self::bond_extra { extra } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("bond_extra",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::bond_extra(origin,
                                            extra).map(Into::into).map_err(Into::into)
                            }
                            Self::claim_payout {} => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("claim_payout",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::claim_payout(origin).map(Into::into).map_err(Into::into)
                            }
                            Self::unbond { member_account, unbonding_points } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("unbond",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::unbond(origin, member_account,
                                            unbonding_points).map(Into::into).map_err(Into::into)
                            }
                            Self::pool_withdraw_unbonded { pool_id, num_slashing_spans }
                                => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("pool_withdraw_unbonded",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::pool_withdraw_unbonded(origin, pool_id,
                                            num_slashing_spans).map(Into::into).map_err(Into::into)
                            }
                            Self::withdraw_unbonded { member_account, num_slashing_spans
                                } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("withdraw_unbonded",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::withdraw_unbonded(origin, member_account,
                                            num_slashing_spans).map(Into::into).map_err(Into::into)
                            }
                            Self::create { amount, root, nominator, bouncer } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("create",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::create(origin, amount, root, nominator,
                                            bouncer).map(Into::into).map_err(Into::into)
                            }
                            Self::create_with_pool_id {
                                amount, root, nominator, bouncer, pool_id } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("create_with_pool_id",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::create_with_pool_id(origin, amount, root,
                                            nominator, bouncer,
                                            pool_id).map(Into::into).map_err(Into::into)
                            }
                            Self::nominate { pool_id, validators } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("nominate",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::nominate(origin, pool_id,
                                            validators).map(Into::into).map_err(Into::into)
                            }
                            Self::set_state { pool_id, state } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("set_state",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::set_state(origin, pool_id,
                                            state).map(Into::into).map_err(Into::into)
                            }
                            Self::set_metadata { pool_id, metadata } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("set_metadata",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::set_metadata(origin, pool_id,
                                            metadata).map(Into::into).map_err(Into::into)
                            }
                            Self::set_configs {
                                min_join_bond,
                                min_create_bond,
                                max_pools,
                                max_members,
                                max_members_per_pool,
                                global_max_commission } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("set_configs",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::set_configs(origin, min_join_bond,
                                            min_create_bond, max_pools, max_members,
                                            max_members_per_pool,
                                            global_max_commission).map(Into::into).map_err(Into::into)
                            }
                            Self::update_roles {
                                pool_id, new_root, new_nominator, new_bouncer } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("update_roles",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::update_roles(origin, pool_id, new_root,
                                            new_nominator,
                                            new_bouncer).map(Into::into).map_err(Into::into)
                            }
                            Self::chill { pool_id } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("chill",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::chill(origin,
                                            pool_id).map(Into::into).map_err(Into::into)
                            }
                            Self::bond_extra_other { member, extra } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("bond_extra_other",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::bond_extra_other(origin, member,
                                            extra).map(Into::into).map_err(Into::into)
                            }
                            Self::set_claim_permission { permission } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("set_claim_permission",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::set_claim_permission(origin,
                                            permission).map(Into::into).map_err(Into::into)
                            }
                            Self::claim_payout_other { other } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("claim_payout_other",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::claim_payout_other(origin,
                                            other).map(Into::into).map_err(Into::into)
                            }
                            Self::set_commission { pool_id, new_commission } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("set_commission",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::set_commission(origin, pool_id,
                                            new_commission).map(Into::into).map_err(Into::into)
                            }
                            Self::set_commission_max { pool_id, max_commission } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("set_commission_max",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::set_commission_max(origin, pool_id,
                                            max_commission).map(Into::into).map_err(Into::into)
                            }
                            Self::set_commission_change_rate { pool_id, change_rate } =>
                                {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("set_commission_change_rate",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::set_commission_change_rate(origin, pool_id,
                                            change_rate).map(Into::into).map_err(Into::into)
                            }
                            Self::claim_commission { pool_id } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("claim_commission",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::claim_commission(origin,
                                            pool_id).map(Into::into).map_err(Into::into)
                            }
                            Self::adjust_pool_deposit { pool_id } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("adjust_pool_deposit",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::adjust_pool_deposit(origin,
                                            pool_id).map(Into::into).map_err(Into::into)
                            }
                            Self::set_commission_claim_permission { pool_id, permission
                                } => {
                                let __within_span__ =
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static CALLSITE: ::tracing::callsite::DefaultCallsite =
                                            {
                                                static META: ::tracing::Metadata<'static> =
                                                    {
                                                        ::tracing_core::metadata::Metadata::new("set_commission_claim_permission",
                                                            "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                                            ::core::option::Option::Some(1588u32),
                                                            ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                                            ::tracing_core::field::FieldSet::new(&[],
                                                                ::tracing_core::callsite::Identifier(&CALLSITE)),
                                                            ::tracing::metadata::Kind::SPAN)
                                                    };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                        let mut interest = ::tracing::subscriber::Interest::never();
                                        if ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                                            ::tracing::Level::TRACE <=
                                                                ::tracing::level_filters::LevelFilter::current() &&
                                                        { interest = CALLSITE.interest(); !interest.is_never() } &&
                                                    ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                                        interest) {
                                                let meta = CALLSITE.metadata();
                                                ::tracing::Span::new(meta,
                                                    &{ meta.fields().value_set(&[]) })
                                            } else {
                                               let span =
                                                   ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                                               {};
                                               span
                                           }
                                    };
                                let __tracing_guard__ = __within_span__.enter();
                                <Pallet<T>>::set_commission_claim_permission(origin,
                                            pool_id, permission).map(Into::into).map_err(Into::into)
                            }
                            Self::__Ignore(_, _) => {
                                let _ = origin;
                                {
                                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                                            format_args!("__PhantomItem cannot be used.")));
                                };
                            }
                        }
                    })
        }
    }
    impl<T: Config> frame_support::dispatch::Callable<T> for Pallet<T> {
        type RuntimeCall = Call<T>;
    }
    impl<T: Config> Pallet<T> {
        #[doc(hidden)]
        pub fn call_functions()
            -> frame_support::__private::metadata_ir::PalletCallMetadataIR {
            frame_support::__private::scale_info::meta_type::<Call<T>>().into()
        }
    }
    impl<T: Config> frame_support::__private::sp_std::fmt::Debug for Error<T>
        {
        fn fmt(&self,
            f: &mut frame_support::__private::sp_std::fmt::Formatter<'_>)
            -> frame_support::__private::sp_std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl<T: Config> Error<T> {
        #[doc(hidden)]
        pub fn as_str(&self) -> &'static str {
            match &self {
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(format_args!("internal error: entered unreachable code: {0}",
                            format_args!("`__Ignore` can never be constructed")));
                }
                Self::PoolNotFound => "PoolNotFound",
                Self::PoolMemberNotFound => "PoolMemberNotFound",
                Self::RewardPoolNotFound => "RewardPoolNotFound",
                Self::SubPoolsNotFound => "SubPoolsNotFound",
                Self::AccountBelongsToOtherPool =>
                    "AccountBelongsToOtherPool",
                Self::FullyUnbonding => "FullyUnbonding",
                Self::MaxUnbondingLimit => "MaxUnbondingLimit",
                Self::CannotWithdrawAny => "CannotWithdrawAny",
                Self::MinimumBondNotMet => "MinimumBondNotMet",
                Self::OverflowRisk => "OverflowRisk",
                Self::NotDestroying => "NotDestroying",
                Self::NotNominator => "NotNominator",
                Self::NotKickerOrDestroying => "NotKickerOrDestroying",
                Self::NotOpen => "NotOpen",
                Self::MaxPools => "MaxPools",
                Self::MaxPoolMembers => "MaxPoolMembers",
                Self::CanNotChangeState => "CanNotChangeState",
                Self::DoesNotHavePermission => "DoesNotHavePermission",
                Self::MetadataExceedsMaxLen => "MetadataExceedsMaxLen",
                Self::Defensive(..) => "Defensive",
                Self::PartialUnbondNotAllowedPermissionlessly =>
                    "PartialUnbondNotAllowedPermissionlessly",
                Self::MaxCommissionRestricted => "MaxCommissionRestricted",
                Self::CommissionExceedsMaximum => "CommissionExceedsMaximum",
                Self::CommissionExceedsGlobalMaximum =>
                    "CommissionExceedsGlobalMaximum",
                Self::CommissionChangeThrottled =>
                    "CommissionChangeThrottled",
                Self::CommissionChangeRateNotAllowed =>
                    "CommissionChangeRateNotAllowed",
                Self::NoPendingCommission => "NoPendingCommission",
                Self::NoCommissionCurrentSet => "NoCommissionCurrentSet",
                Self::PoolIdInUse => "PoolIdInUse",
                Self::InvalidPoolId => "InvalidPoolId",
                Self::BondExtraRestricted => "BondExtraRestricted",
                Self::NothingToAdjust => "NothingToAdjust",
            }
        }
    }
    impl<T: Config> From<Error<T>> for &'static str {
        fn from(err: Error<T>) -> &'static str { err.as_str() }
    }
    impl<T: Config> From<Error<T>> for
        frame_support::sp_runtime::DispatchError {
        fn from(err: Error<T>) -> Self {
            use frame_support::__private::codec::Encode;
            let index =
                <<T as frame_system::Config>::PalletInfo as
                                frame_support::traits::PalletInfo>::index::<Pallet<T>>().expect("Every active module has an index in the runtime; qed")
                    as u8;
            let mut encoded = err.encode();
            encoded.resize(frame_support::MAX_MODULE_ERROR_ENCODED_SIZE, 0);
            frame_support::sp_runtime::DispatchError::Module(frame_support::sp_runtime::ModuleError {
                    index,
                    error: TryInto::try_into(encoded).expect("encoded error is resized to be equal to the maximum encoded error size; qed"),
                    message: Some(err.as_str()),
                })
        }
    }
    #[macro_export]
    #[doc(hidden)]
    macro_rules! __tt_error_token_1 {
        { $caller : tt your_tt_return = [{ $my_tt_return : path }] } =>
        { $my_tt_return! { $caller error = [{ Error }] } } ;
    }
    pub use __tt_error_token_1 as tt_error_token;
    #[doc(hidden)]
    pub mod __substrate_event_check {
        #[macro_export]
        #[doc(hidden)]
        macro_rules! __is_event_part_defined_2 {
            ($pallet_name : ident) => {} ;
        }
        #[doc(hidden)]
        pub use __is_event_part_defined_2 as is_event_part_defined;
    }
    impl<T: Config> Pallet<T> {
        pub(crate) fn deposit_event(event: Event<T>) {
            let event =
                <<T as Config>::RuntimeEvent as From<Event<T>>>::from(event);
            let event =
                <<T as Config>::RuntimeEvent as
                        Into<<T as
                        frame_system::Config>::RuntimeEvent>>::into(event);
            <frame_system::Pallet<T>>::deposit_event(event)
        }
    }
    impl<T: Config> From<Event<T>> for () {
        fn from(_: Event<T>) {}
    }
    impl<T: Config> Pallet<T> {
        #[doc(hidden)]
        pub fn storage_metadata()
            ->
                frame_support::__private::metadata_ir::PalletStorageMetadataIR {
            frame_support::__private::metadata_ir::PalletStorageMetadataIR {
                prefix: <<T as frame_system::Config>::PalletInfo as
                            frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`."),
                entries: {
                    #[allow(unused_mut)]
                    let mut entries = ::alloc::vec::Vec::new();
                    {
                        <TotalValueLocked<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" The sum of funds across all pools.",
                                            "",
                                            " This might be lower but never higher than the sum of `total_balance` of all [`PoolMembers`]",
                                            " because calling `pool_withdraw_unbonded` might decrease the total stake of the pool\'s",
                                            " `bonded_account` without adjusting the pallet-internal `UnbondingPool`\'s."])),
                            &mut entries);
                    }
                    {
                        <MinJoinBond<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Minimum amount to bond to join a pool."])),
                            &mut entries);
                    }
                    {
                        <MinCreateBond<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Minimum bond required to create a pool.",
                                            "",
                                            " This is the amount that the depositor must put as their initial stake in the pool, as an",
                                            " indication of \"skin in the game\".", "",
                                            " This is the value that will always exist in the staking ledger of the pool bonded account",
                                            " while all other accounts leave."])), &mut entries);
                    }
                    {
                        <MaxPools<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Maximum number of nomination pools that can exist. If `None`, then an unbounded number of",
                                            " pools can exist."])), &mut entries);
                    }
                    {
                        <MaxPoolMembers<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Maximum number of members that can exist in the system. If `None`, then the count",
                                            " members are not bound on a system wide basis."])),
                            &mut entries);
                    }
                    {
                        <MaxPoolMembersPerPool<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Maximum number of members that may belong to pool. If `None`, then the count of",
                                            " members is not bound on a per pool basis."])),
                            &mut entries);
                    }
                    {
                        <GlobalMaxCommission<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" The maximum commission that can be charged by a pool. Used on commission payouts to bound",
                                            " pool commissions that are > `GlobalMaxCommission`, necessary if a future",
                                            " `GlobalMaxCommission` is lower than some current pool commissions."])),
                            &mut entries);
                    }
                    {
                        <PoolMembers<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Active members.",
                                            "",
                                            " TWOX-NOTE: SAFE since `AccountId` is a secure hash."])),
                            &mut entries);
                    }
                    {
                        <BondedPools<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Storage for bonded pools."])),
                            &mut entries);
                    }
                    {
                        <RewardPools<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Reward pools. This is where there rewards for each pool accumulate. When a members payout is",
                                            " claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account."])),
                            &mut entries);
                    }
                    {
                        <SubPoolsStorage<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Groups of unbonding pools. Each group of unbonding pools belongs to a",
                                            " bonded pool, hence the name sub-pools. Keyed by the bonded pools account."])),
                            &mut entries);
                    }
                    {
                        <Metadata<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Metadata for the pool."])),
                            &mut entries);
                    }
                    {
                        <LastPoolId<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Ever increasing number of all pools created so far."])),
                            &mut entries);
                    }
                    {
                        <ReversePoolIdLookup<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" A reverse lookup from the pool\'s account id to its id.",
                                            "",
                                            " This is only used for slashing. In all other instances, the pool id is used, and the",
                                            " accounts are deterministically derived from it."])),
                            &mut entries);
                    }
                    {
                        <ClaimPermissions<T> as
                                frame_support::storage::StorageEntryMetadataBuilder>::build_metadata(<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([" Map from a pool member account to their opted claim permission."])),
                            &mut entries);
                    }
                    entries
                },
            }
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageTotalValueLocked<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageTotalValueLocked<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "TotalValueLocked";
        fn storage_prefix_hash() -> [u8; 16] {
            [163u8, 197u8, 108u8, 137u8, 37u8, 141u8, 145u8, 72u8, 42u8, 32u8,
                    13u8, 217u8, 205u8, 54u8, 53u8, 24u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageMinJoinBond<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageMinJoinBond<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "MinJoinBond";
        fn storage_prefix_hash() -> [u8; 16] {
            [43u8, 233u8, 164u8, 232u8, 131u8, 104u8, 162u8, 24u8, 141u8,
                    43u8, 145u8, 0u8, 169u8, 243u8, 205u8, 67u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageMinCreateBond<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageMinCreateBond<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "MinCreateBond";
        fn storage_prefix_hash() -> [u8; 16] {
            [73u8, 214u8, 121u8, 151u8, 222u8, 51u8, 129u8, 42u8, 28u8, 195u8,
                    115u8, 16u8, 247u8, 101u8, 184u8, 46u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageMaxPools<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageMaxPools<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "MaxPools";
        fn storage_prefix_hash() -> [u8; 16] {
            [186u8, 147u8, 48u8, 47u8, 59u8, 134u8, 140u8, 80u8, 120u8, 94u8,
                    106u8, 222u8, 69u8, 198u8, 161u8, 216u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageMaxPoolMembers<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageMaxPoolMembers<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "MaxPoolMembers";
        fn storage_prefix_hash() -> [u8; 16] {
            [48u8, 37u8, 110u8, 162u8, 197u8, 69u8, 163u8, 229u8, 227u8,
                    116u8, 70u8, 101u8, 255u8, 178u8, 237u8, 40u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageMaxPoolMembersPerPool<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageMaxPoolMembersPerPool<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "MaxPoolMembersPerPool";
        fn storage_prefix_hash() -> [u8; 16] {
            [63u8, 13u8, 100u8, 225u8, 144u8, 115u8, 97u8, 198u8, 137u8,
                    131u8, 74u8, 156u8, 28u8, 176u8, 251u8, 224u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageGlobalMaxCommission<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageGlobalMaxCommission<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "GlobalMaxCommission";
        fn storage_prefix_hash() -> [u8; 16] {
            [111u8, 16u8, 3u8, 29u8, 248u8, 90u8, 178u8, 231u8, 136u8, 218u8,
                    221u8, 251u8, 92u8, 100u8, 175u8, 124u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedCounterPrefixForStoragePoolMembers<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedCounterPrefixForStoragePoolMembers<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "CounterForPoolMembers";
        fn storage_prefix_hash() -> [u8; 16] {
            [148u8, 187u8, 188u8, 133u8, 17u8, 25u8, 98u8, 98u8, 121u8, 236u8,
                    12u8, 223u8, 111u8, 203u8, 207u8, 18u8]
        }
    }
    impl<T: Config> frame_support::storage::types::CountedStorageMapInstance
        for _GeneratedPrefixForStoragePoolMembers<T> {
        type CounterPrefix = _GeneratedCounterPrefixForStoragePoolMembers<T>;
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStoragePoolMembers<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStoragePoolMembers<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "PoolMembers";
        fn storage_prefix_hash() -> [u8; 16] {
            [60u8, 95u8, 105u8, 226u8, 112u8, 213u8, 183u8, 160u8, 127u8,
                    153u8, 150u8, 254u8, 158u8, 78u8, 4u8, 136u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedCounterPrefixForStorageBondedPools<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedCounterPrefixForStorageBondedPools<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "CounterForBondedPools";
        fn storage_prefix_hash() -> [u8; 16] {
            [96u8, 155u8, 96u8, 70u8, 200u8, 200u8, 13u8, 17u8, 196u8, 115u8,
                    43u8, 187u8, 232u8, 110u8, 242u8, 224u8]
        }
    }
    impl<T: Config> frame_support::storage::types::CountedStorageMapInstance
        for _GeneratedPrefixForStorageBondedPools<T> {
        type CounterPrefix = _GeneratedCounterPrefixForStorageBondedPools<T>;
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageBondedPools<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageBondedPools<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "BondedPools";
        fn storage_prefix_hash() -> [u8; 16] {
            [31u8, 124u8, 78u8, 87u8, 220u8, 73u8, 228u8, 214u8, 208u8, 3u8,
                    183u8, 48u8, 167u8, 137u8, 79u8, 50u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedCounterPrefixForStorageRewardPools<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedCounterPrefixForStorageRewardPools<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "CounterForRewardPools";
        fn storage_prefix_hash() -> [u8; 16] {
            [55u8, 78u8, 115u8, 123u8, 180u8, 135u8, 154u8, 197u8, 102u8,
                    144u8, 27u8, 40u8, 231u8, 147u8, 132u8, 47u8]
        }
    }
    impl<T: Config> frame_support::storage::types::CountedStorageMapInstance
        for _GeneratedPrefixForStorageRewardPools<T> {
        type CounterPrefix = _GeneratedCounterPrefixForStorageRewardPools<T>;
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageRewardPools<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageRewardPools<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "RewardPools";
        fn storage_prefix_hash() -> [u8; 16] {
            [250u8, 8u8, 131u8, 249u8, 106u8, 210u8, 82u8, 85u8, 88u8, 27u8,
                    239u8, 91u8, 167u8, 43u8, 135u8, 80u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedCounterPrefixForStorageSubPoolsStorage<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedCounterPrefixForStorageSubPoolsStorage<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "CounterForSubPoolsStorage";
        fn storage_prefix_hash() -> [u8; 16] {
            [50u8, 84u8, 115u8, 237u8, 140u8, 42u8, 85u8, 19u8, 70u8, 220u8,
                    12u8, 105u8, 51u8, 133u8, 203u8, 15u8]
        }
    }
    impl<T: Config> frame_support::storage::types::CountedStorageMapInstance
        for _GeneratedPrefixForStorageSubPoolsStorage<T> {
        type CounterPrefix =
            _GeneratedCounterPrefixForStorageSubPoolsStorage<T>;
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageSubPoolsStorage<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageSubPoolsStorage<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "SubPoolsStorage";
        fn storage_prefix_hash() -> [u8; 16] {
            [160u8, 154u8, 68u8, 221u8, 166u8, 229u8, 13u8, 160u8, 228u8,
                    36u8, 9u8, 232u8, 78u8, 163u8, 218u8, 164u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedCounterPrefixForStorageMetadata<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedCounterPrefixForStorageMetadata<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "CounterForMetadata";
        fn storage_prefix_hash() -> [u8; 16] {
            [88u8, 45u8, 234u8, 137u8, 147u8, 108u8, 239u8, 88u8, 142u8,
                    195u8, 27u8, 221u8, 5u8, 215u8, 0u8, 252u8]
        }
    }
    impl<T: Config> frame_support::storage::types::CountedStorageMapInstance
        for _GeneratedPrefixForStorageMetadata<T> {
        type CounterPrefix = _GeneratedCounterPrefixForStorageMetadata<T>;
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageMetadata<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageMetadata<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "Metadata";
        fn storage_prefix_hash() -> [u8; 16] {
            [181u8, 243u8, 130u8, 46u8, 53u8, 202u8, 47u8, 49u8, 206u8, 53u8,
                    38u8, 234u8, 177u8, 54u8, 63u8, 210u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageLastPoolId<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageLastPoolId<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "LastPoolId";
        fn storage_prefix_hash() -> [u8; 16] {
            [212u8, 59u8, 125u8, 38u8, 179u8, 141u8, 229u8, 69u8, 50u8, 154u8,
                    99u8, 40u8, 205u8, 82u8, 243u8, 113u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedCounterPrefixForStorageReversePoolIdLookup<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedCounterPrefixForStorageReversePoolIdLookup<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "CounterForReversePoolIdLookup";
        fn storage_prefix_hash() -> [u8; 16] {
            [114u8, 150u8, 246u8, 46u8, 218u8, 125u8, 219u8, 51u8, 216u8,
                    53u8, 147u8, 228u8, 255u8, 202u8, 191u8, 193u8]
        }
    }
    impl<T: Config> frame_support::storage::types::CountedStorageMapInstance
        for _GeneratedPrefixForStorageReversePoolIdLookup<T> {
        type CounterPrefix =
            _GeneratedCounterPrefixForStorageReversePoolIdLookup<T>;
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageReversePoolIdLookup<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageReversePoolIdLookup<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "ReversePoolIdLookup";
        fn storage_prefix_hash() -> [u8; 16] {
            [163u8, 137u8, 70u8, 101u8, 201u8, 23u8, 229u8, 230u8, 132u8,
                    143u8, 117u8, 140u8, 184u8, 186u8, 187u8, 227u8]
        }
    }
    #[doc(hidden)]
    pub struct _GeneratedPrefixForStorageClaimPermissions<T>(core::marker::PhantomData<(T,)>);
    impl<T: Config> frame_support::traits::StorageInstance for
        _GeneratedPrefixForStorageClaimPermissions<T> {
        fn pallet_prefix() -> &'static str {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name::<Pallet<T>>().expect("No name found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        fn pallet_prefix_hash() -> [u8; 16] {
            <<T as frame_system::Config>::PalletInfo as
                        frame_support::traits::PalletInfo>::name_hash::<Pallet<T>>().expect("No name_hash found for the pallet in the runtime! This usually means that the pallet wasn't added to `construct_runtime!`.")
        }
        const STORAGE_PREFIX: &'static str = "ClaimPermissions";
        fn storage_prefix_hash() -> [u8; 16] {
            [110u8, 188u8, 87u8, 40u8, 66u8, 188u8, 16u8, 224u8, 211u8, 138u8,
                    178u8, 231u8, 203u8, 145u8, 68u8, 54u8]
        }
    }
    #[doc(hidden)]
    pub mod __substrate_inherent_check {
        #[macro_export]
        #[doc(hidden)]
        macro_rules! __is_inherent_part_defined_3 {
            ($pallet_name : ident) =>
            {
                compile_error!
                (concat!
                ("`", stringify! ($pallet_name),
                "` does not have #[pallet::inherent] defined, perhaps you should \
				remove `Inherent` from construct_runtime?",))
                ;
            }
        }
        #[doc(hidden)]
        pub use __is_inherent_part_defined_3 as is_inherent_part_defined;
    }
    #[doc =
    r" Hidden instance generated to be internally used when module is used without"]
    #[doc = r" instance."]
    #[doc(hidden)]
    pub type __InherentHiddenInstance = ();
    impl<T: Config>
        frame_support::traits::OnFinalize<frame_system::pallet_prelude::BlockNumberFor<T>>
        for Pallet<T> {
        fn on_finalize(n: frame_system::pallet_prelude::BlockNumberFor<T>) {
            let __within_span__ =
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite =
                        {
                            static META: ::tracing::Metadata<'static> =
                                {
                                    ::tracing_core::metadata::Metadata::new("on_finalize",
                                        "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                        ::core::option::Option::Some(1588u32),
                                        ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                        ::tracing_core::field::FieldSet::new(&[],
                                            ::tracing_core::callsite::Identifier(&CALLSITE)),
                                        ::tracing::metadata::Kind::SPAN)
                                };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if ::tracing::Level::TRACE <=
                                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                        ::tracing::Level::TRACE <=
                                            ::tracing::level_filters::LevelFilter::current() &&
                                    { interest = CALLSITE.interest(); !interest.is_never() } &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest) {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta,
                                &{ meta.fields().value_set(&[]) })
                        } else {
                           let span =
                               ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                           {};
                           span
                       }
                };
            let __tracing_guard__ = __within_span__.enter();
            <Self as
                    frame_support::traits::Hooks<frame_system::pallet_prelude::BlockNumberFor<T>>>::on_finalize(n)
        }
    }
    impl<T: Config>
        frame_support::traits::OnIdle<frame_system::pallet_prelude::BlockNumberFor<T>>
        for Pallet<T> {
        fn on_idle(n: frame_system::pallet_prelude::BlockNumberFor<T>,
            remaining_weight: frame_support::weights::Weight)
            -> frame_support::weights::Weight {
            <Self as
                    frame_support::traits::Hooks<frame_system::pallet_prelude::BlockNumberFor<T>>>::on_idle(n,
                remaining_weight)
        }
    }
    impl<T: Config>
        frame_support::traits::OnInitialize<frame_system::pallet_prelude::BlockNumberFor<T>>
        for Pallet<T> {
        fn on_initialize(n: frame_system::pallet_prelude::BlockNumberFor<T>)
            -> frame_support::weights::Weight {
            let __within_span__ =
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite =
                        {
                            static META: ::tracing::Metadata<'static> =
                                {
                                    ::tracing_core::metadata::Metadata::new("on_initialize",
                                        "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                        ::core::option::Option::Some(1588u32),
                                        ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                        ::tracing_core::field::FieldSet::new(&[],
                                            ::tracing_core::callsite::Identifier(&CALLSITE)),
                                        ::tracing::metadata::Kind::SPAN)
                                };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if ::tracing::Level::TRACE <=
                                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                        ::tracing::Level::TRACE <=
                                            ::tracing::level_filters::LevelFilter::current() &&
                                    { interest = CALLSITE.interest(); !interest.is_never() } &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest) {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta,
                                &{ meta.fields().value_set(&[]) })
                        } else {
                           let span =
                               ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                           {};
                           span
                       }
                };
            let __tracing_guard__ = __within_span__.enter();
            <Self as
                    frame_support::traits::Hooks<frame_system::pallet_prelude::BlockNumberFor<T>>>::on_initialize(n)
        }
    }
    impl<T: Config> frame_support::traits::BeforeAllRuntimeMigrations for
        Pallet<T> {
        fn before_all_runtime_migrations() -> frame_support::weights::Weight {
            use frame_support::traits::{Get, PalletInfoAccess};
            use frame_support::__private::hashing::twox_128;
            use frame_support::storage::unhashed::contains_prefixed_key;
            let __within_span__ =
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite =
                        {
                            static META: ::tracing::Metadata<'static> =
                                {
                                    ::tracing_core::metadata::Metadata::new("before_all",
                                        "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                        ::core::option::Option::Some(1588u32),
                                        ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                        ::tracing_core::field::FieldSet::new(&[],
                                            ::tracing_core::callsite::Identifier(&CALLSITE)),
                                        ::tracing::metadata::Kind::SPAN)
                                };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if ::tracing::Level::TRACE <=
                                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                        ::tracing::Level::TRACE <=
                                            ::tracing::level_filters::LevelFilter::current() &&
                                    { interest = CALLSITE.interest(); !interest.is_never() } &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest) {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta,
                                &{ meta.fields().value_set(&[]) })
                        } else {
                           let span =
                               ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                           {};
                           span
                       }
                };
            let __tracing_guard__ = __within_span__.enter();
            let pallet_hashed_prefix =
                <Self as PalletInfoAccess>::name_hash();
            let exists = contains_prefixed_key(&pallet_hashed_prefix);
            if !exists {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL &&
                                    lvl <= ::log::max_level() {
                                ::log::__private_api::log(format_args!("üê• New pallet {0:?} detected in the runtime. Initializing the on-chain storage version to match the storage version defined in the pallet: {1:?}",
                                        <<T as frame_system::Config>::PalletInfo as
                                                    frame_support::traits::PalletInfo>::name::<Self>().unwrap_or("<unknown pallet name>"),
                                        STORAGE_VERSION), lvl,
                                    &(frame_support::LOG_TARGET,
                                            "pallet_nomination_pools::pallet",
                                            "substrate/frame/nomination-pools/src/lib.rs"), 1588u32,
                                    ::log::__private_api::Option::None);
                            }
                    };
                    STORAGE_VERSION.put::<Self>();
                    <T as
                                frame_system::Config>::DbWeight::get().reads_writes(1, 1)
                } else {
                   <T as frame_system::Config>::DbWeight::get().reads(1)
               }
        }
    }
    impl<T: Config> frame_support::traits::OnRuntimeUpgrade for Pallet<T> {
        fn on_runtime_upgrade() -> frame_support::weights::Weight {
            let __within_span__ =
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::callsite::DefaultCallsite =
                        {
                            static META: ::tracing::Metadata<'static> =
                                {
                                    ::tracing_core::metadata::Metadata::new("on_runtime_update",
                                        "pallet_nomination_pools::pallet", ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("substrate/frame/nomination-pools/src/lib.rs"),
                                        ::core::option::Option::Some(1588u32),
                                        ::core::option::Option::Some("pallet_nomination_pools::pallet"),
                                        ::tracing_core::field::FieldSet::new(&[],
                                            ::tracing_core::callsite::Identifier(&CALLSITE)),
                                        ::tracing::metadata::Kind::SPAN)
                                };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if ::tracing::Level::TRACE <=
                                            ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                        ::tracing::Level::TRACE <=
                                            ::tracing::level_filters::LevelFilter::current() &&
                                    { interest = CALLSITE.interest(); !interest.is_never() } &&
                                ::tracing::__macro_support::__is_enabled(CALLSITE.metadata(),
                                    interest) {
                            let meta = CALLSITE.metadata();
                            ::tracing::Span::new(meta,
                                &{ meta.fields().value_set(&[]) })
                        } else {
                           let span =
                               ::tracing::__macro_support::__disabled_span(CALLSITE.metadata());
                           {};
                           span
                       }
                };
            let __tracing_guard__ = __within_span__.enter();
            {
                let lvl = ::log::Level::Debug;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level()
                        {
                        ::log::__private_api::log(format_args!("‚úÖ no migration for {0}",
                                <<T as frame_system::Config>::PalletInfo as
                                            frame_support::traits::PalletInfo>::name::<Self>().unwrap_or("<unknown pallet name>")),
                            lvl,
                            &(frame_support::LOG_TARGET,
                                    "pallet_nomination_pools::pallet",
                                    "substrate/frame/nomination-pools/src/lib.rs"), 1588u32,
                            ::log::__private_api::Option::None);
                    }
            };
            <Self as
                    frame_support::traits::Hooks<frame_system::pallet_prelude::BlockNumberFor<T>>>::on_runtime_upgrade()
        }
    }
    impl<T: Config>
        frame_support::traits::OffchainWorker<frame_system::pallet_prelude::BlockNumberFor<T>>
        for Pallet<T> {
        fn offchain_worker(n:
                frame_system::pallet_prelude::BlockNumberFor<T>) {
            <Self as
                    frame_support::traits::Hooks<frame_system::pallet_prelude::BlockNumberFor<T>>>::offchain_worker(n)
        }
    }
    impl<T: Config> frame_support::traits::IntegrityTest for Pallet<T> {
        fn integrity_test() {
            frame_support::__private::sp_io::TestExternalities::default().execute_with(||
                    {
                        <Self as
                                frame_support::traits::Hooks<frame_system::pallet_prelude::BlockNumberFor<T>>>::integrity_test()
                    });
        }
    }
    #[cfg(feature = "std")]
    impl<T: Config> frame_support::sp_runtime::BuildStorage for
        GenesisConfig<T> {
        fn assimilate_storage(&self,
            storage: &mut frame_support::sp_runtime::Storage)
            -> std::result::Result<(), std::string::String> {
            frame_support::__private::BasicExternalities::execute_with_storage(storage,
                || { self.build(); Ok(()) })
        }
    }
    #[doc(hidden)]
    pub mod __substrate_genesis_config_check {
        #[macro_export]
        #[doc(hidden)]
        macro_rules! __is_genesis_config_defined_4 {
            ($pallet_name : ident) => {} ;
        }
        #[cfg(feature = "std")]
        #[macro_export]
        #[doc(hidden)]
        macro_rules! __is_std_macro_defined_for_genesis_4 {
            ($pallet_name : ident, $pallet_path : expr) => {} ;
        }
        #[doc(hidden)]
        pub use __is_genesis_config_defined_4 as is_genesis_config_defined;
        #[doc(hidden)]
        pub use __is_std_macro_defined_for_genesis_4 as is_std_enabled_for_genesis;
    }
    #[doc(hidden)]
    pub mod __substrate_origin_check {
        #[macro_export]
        #[doc(hidden)]
        macro_rules! __is_origin_part_defined_5 {
            ($pallet_name : ident) =>
            {
                compile_error!
                (concat!
                ("`", stringify! ($pallet_name),
                "` does not have #[pallet::origin] defined, perhaps you should \
				remove `Origin` from construct_runtime?",))
                ;
            }
        }
        #[doc(hidden)]
        pub use __is_origin_part_defined_5 as is_origin_part_defined;
    }
    #[doc(hidden)]
    pub mod __substrate_validate_unsigned_check {
        #[macro_export]
        #[doc(hidden)]
        macro_rules! __is_validate_unsigned_part_defined_6 {
            ($pallet_name : ident) =>
            {
                compile_error!
                (concat!
                ("`", stringify! ($pallet_name),
                "` does not have #[pallet::validate_unsigned] defined, perhaps you should \
				remove `ValidateUnsigned` from construct_runtime?",))
                ;
            }
        }
        #[doc(hidden)]
        pub use __is_validate_unsigned_part_defined_6 as is_validate_unsigned_part_defined;
    }
    #[macro_export]
    #[doc(hidden)]
    macro_rules! __tt_default_parts_7 {
        { $caller : tt your_tt_return = [{ $my_tt_return : path }] } =>
        {
            $my_tt_return!
            {
                $caller tokens =
                [{
                    expanded ::
                    {
                        Pallet, Call, Storage, Event < T >, Error < T >, Config < T
                        >, FreezeReason,
                    }
                }]
            }
        } ;
    }
    pub use __tt_default_parts_7 as tt_default_parts;
    #[macro_export]
    #[doc(hidden)]
    macro_rules! __tt_extra_parts_7 {
        { $caller : tt your_tt_return = [{ $my_tt_return : path }] } =>
        {
            $my_tt_return!
            { $caller tokens = [{ expanded :: { Error < T >, } }] }
        } ;
    }
    pub use __tt_extra_parts_7 as tt_extra_parts;
}
impl<T: Config> Pallet<T> {
    /// The amount of bond that MUST REMAIN IN BONDED in ALL POOLS.
    ///
    /// It is the responsibility of the depositor to put these funds into the pool initially. Upon
    /// unbond, they can never unbond to a value below this amount.
    ///
    /// It is essentially `max { MinNominatorBond, MinCreateBond, MinJoinBond }`, where the former
    /// is coming from the staking pallet and the latter two are configured in this pallet.
    pub fn depositor_min_bond() -> BalanceOf<T> {
        T::Staking::minimum_nominator_bond().max(MinCreateBond::<T>::get()).max(MinJoinBond::<T>::get()).max(T::Currency::minimum_balance())
    }
    /// Remove everything related to the given bonded pool.
    ///
    /// Metadata and all of the sub-pools are also deleted. All accounts are dusted and the leftover
    /// of the reward account is returned to the depositor.
    pub fn dissolve_pool(bonded_pool: BondedPool<T>) {
        let reward_account = bonded_pool.reward_account();
        let bonded_account = bonded_pool.bonded_account();
        ReversePoolIdLookup::<T>::remove(&bonded_account);
        RewardPools::<T>::remove(bonded_pool.id);
        SubPoolsStorage::<T>::remove(bonded_pool.id);
        let _ =
            Self::unfreeze_pool_deposit(&bonded_pool.reward_account()).defensive();
        if !(frame_system::Pallet::<T>::consumers(&reward_account) == 0) {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("{0}: {1:?}: {2:?}",
                                    ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                    "frame_system::Pallet::<T>::consumers(&reward_account) == 0",
                                    "reward account of dissolving pool should have no consumers"),
                                lvl,
                                &("runtime::defensive", "pallet_nomination_pools",
                                        "substrate/frame/nomination-pools/src/lib.rs"), 2857u32,
                                ::log::__private_api::Option::None);
                        }
                };
                if true {
                        if !false {
                                {
                                    ::core::panicking::panic_fmt(format_args!("{0}: {1:?}: {2:?}",
                                            ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                            "frame_system::Pallet::<T>::consumers(&reward_account) == 0",
                                            "reward account of dissolving pool should have no consumers"));
                                }
                            };
                    };
                ;
            };
        if !(frame_system::Pallet::<T>::consumers(&bonded_account) == 0) {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("{0}: {1:?}: {2:?}",
                                    ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                    "frame_system::Pallet::<T>::consumers(&bonded_account) == 0",
                                    "bonded account of dissolving pool should have no consumers"),
                                lvl,
                                &("runtime::defensive", "pallet_nomination_pools",
                                        "substrate/frame/nomination-pools/src/lib.rs"), 2861u32,
                                ::log::__private_api::Option::None);
                        }
                };
                if true {
                        if !false {
                                {
                                    ::core::panicking::panic_fmt(format_args!("{0}: {1:?}: {2:?}",
                                            ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                            "frame_system::Pallet::<T>::consumers(&bonded_account) == 0",
                                            "bonded account of dissolving pool should have no consumers"));
                                }
                            };
                    };
                ;
            };
        if !(T::Staking::total_stake(&bonded_account).unwrap_or_default() ==
                            Zero::zero()) {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("{0}: {1:?}: {2:?}",
                                    ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                    "T::Staking::total_stake(&bonded_account).unwrap_or_default() == Zero::zero()",
                                    "dissolving pool should not have any stake in the staking pallet"),
                                lvl,
                                &("runtime::defensive", "pallet_nomination_pools",
                                        "substrate/frame/nomination-pools/src/lib.rs"), 2865u32,
                                ::log::__private_api::Option::None);
                        }
                };
                if true {
                        if !false {
                                {
                                    ::core::panicking::panic_fmt(format_args!("{0}: {1:?}: {2:?}",
                                            ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                            "T::Staking::total_stake(&bonded_account).unwrap_or_default() == Zero::zero()",
                                            "dissolving pool should not have any stake in the staking pallet"));
                                }
                            };
                    };
                ;
            };
        let reward_pool_remaining =
            T::Currency::reducible_balance(&reward_account,
                Preservation::Expendable, Fortitude::Polite);
        let _ =
            T::Currency::transfer(&reward_account,
                &bonded_pool.roles.depositor, reward_pool_remaining,
                Preservation::Expendable);
        if !(T::Currency::total_balance(&reward_account) == Zero::zero()) {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("{0}: {1:?}: {2:?}",
                                    ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                    "T::Currency::total_balance(&reward_account) == Zero::zero()",
                                    "could not transfer all amount to depositor while dissolving pool"),
                                lvl,
                                &("runtime::defensive", "pallet_nomination_pools",
                                        "substrate/frame/nomination-pools/src/lib.rs"), 2884u32,
                                ::log::__private_api::Option::None);
                        }
                };
                if true {
                        if !false {
                                {
                                    ::core::panicking::panic_fmt(format_args!("{0}: {1:?}: {2:?}",
                                            ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                            "T::Currency::total_balance(&reward_account) == Zero::zero()",
                                            "could not transfer all amount to depositor while dissolving pool"));
                                }
                            };
                    };
                ;
            };
        if !(T::Currency::total_balance(&bonded_pool.bonded_account()) ==
                            Zero::zero()) {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                lvl <= ::log::max_level() {
                            ::log::__private_api::log(format_args!("{0}: {1:?}: {2:?}",
                                    ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                    "T::Currency::total_balance(&bonded_pool.bonded_account()) == Zero::zero()",
                                    "dissolving pool should not have any balance"), lvl,
                                &("runtime::defensive", "pallet_nomination_pools",
                                        "substrate/frame/nomination-pools/src/lib.rs"), 2888u32,
                                ::log::__private_api::Option::None);
                        }
                };
                if true {
                        if !false {
                                {
                                    ::core::panicking::panic_fmt(format_args!("{0}: {1:?}: {2:?}",
                                            ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                            "T::Currency::total_balance(&bonded_pool.bonded_account()) == Zero::zero()",
                                            "dissolving pool should not have any balance"));
                                }
                            };
                    };
                ;
            };
        T::Currency::set_balance(&reward_account, Zero::zero());
        T::Currency::set_balance(&bonded_pool.bonded_account(), Zero::zero());
        Self::deposit_event(Event::<T>::Destroyed {
                pool_id: bonded_pool.id,
            });
        Metadata::<T>::remove(bonded_pool.id);
        bonded_pool.remove();
    }
    /// Create the main, bonded account of a pool with the given id.
    pub fn create_bonded_account(id: PoolId) -> T::AccountId {
        T::PalletId::get().into_sub_account_truncating((AccountType::Bonded,
                id))
    }
    /// Create the reward account of a pool with the given id.
    pub fn create_reward_account(id: PoolId) -> T::AccountId {
        T::PalletId::get().into_sub_account_truncating((AccountType::Reward,
                id))
    }
    /// Get the member with their associated bonded and reward pool.
    fn get_member_with_pools(who: &T::AccountId)
        -> Result<(PoolMember<T>, BondedPool<T>, RewardPool<T>), Error<T>> {
        let member =
            PoolMembers::<T>::get(who).ok_or(Error::<T>::PoolMemberNotFound)?;
        let bonded_pool =
            BondedPool::<T>::get(member.pool_id).defensive_ok_or(DefensiveError::PoolNotFound)?;
        let reward_pool =
            RewardPools::<T>::get(member.pool_id).defensive_ok_or(DefensiveError::PoolNotFound)?;
        Ok((member, bonded_pool, reward_pool))
    }
    /// Persist the member with their associated bonded and reward pool into storage, consuming
    /// all of them.
    fn put_member_with_pools(member_account: &T::AccountId,
        member: PoolMember<T>, bonded_pool: BondedPool<T>,
        reward_pool: RewardPool<T>) {
        bonded_pool.put();
        RewardPools::insert(member.pool_id, reward_pool);
        PoolMembers::<T>::insert(member_account, member);
    }
    /// Calculate the equivalent point of `new_funds` in a pool with `current_balance` and
    /// `current_points`.
    fn balance_to_point(current_balance: BalanceOf<T>,
        current_points: BalanceOf<T>, new_funds: BalanceOf<T>)
        -> BalanceOf<T> {
        let u256 = T::BalanceToU256::convert;
        let balance = T::U256ToBalance::convert;
        match (current_balance.is_zero(), current_points.is_zero()) {
            (_, true) =>
                new_funds.saturating_mul(POINTS_TO_BALANCE_INIT_RATIO.into()),
            (true, false) => { new_funds.saturating_mul(current_points) }
            (false, false) => {
                balance(u256(current_points).saturating_mul(u256(new_funds)).div(u256(current_balance)))
            }
        }
    }
    /// Calculate the equivalent balance of `points` in a pool with `current_balance` and
    /// `current_points`.
    fn point_to_balance(current_balance: BalanceOf<T>,
        current_points: BalanceOf<T>, points: BalanceOf<T>) -> BalanceOf<T> {
        let u256 = T::BalanceToU256::convert;
        let balance = T::U256ToBalance::convert;
        if current_balance.is_zero() || current_points.is_zero() ||
                    points.is_zero() {
                return Zero::zero()
            }
        balance(u256(current_balance).saturating_mul(u256(points)).div(u256(current_points)))
    }
    /// If the member has some rewards, transfer a payout from the reward pool to the member.
    fn do_reward_payout(member_account: &T::AccountId,
        member: &mut PoolMember<T>, bonded_pool: &mut BondedPool<T>,
        reward_pool: &mut RewardPool<T>)
        -> Result<BalanceOf<T>, DispatchError> {
        if true {
                match (&member.pool_id, &bonded_pool.id) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(kind, &*left_val,
                                    &*right_val, ::core::option::Option::None);
                            }
                    }
                };
            };
        {
            if !!member.active_points().is_zero() {
                    { return Err(Error::<T>::FullyUnbonding.into()) };
                }
        };
        let (current_reward_counter, _) =
            reward_pool.current_reward_counter(bonded_pool.id,
                    bonded_pool.points, bonded_pool.commission.current())?;
        let pending_rewards = member.pending_rewards(current_reward_counter)?;
        if pending_rewards.is_zero() { return Ok(pending_rewards) }
        member.last_recorded_reward_counter = current_reward_counter;
        reward_pool.register_claimed_reward(pending_rewards);
        T::Currency::transfer(&bonded_pool.reward_account(), member_account,
                pending_rewards, Preservation::Preserve)?;
        Self::deposit_event(Event::<T>::PaidOut {
                member: member_account.clone(),
                pool_id: member.pool_id,
                payout: pending_rewards,
            });
        Ok(pending_rewards)
    }
    fn do_create(who: T::AccountId, amount: BalanceOf<T>,
        root: AccountIdLookupOf<T>, nominator: AccountIdLookupOf<T>,
        bouncer: AccountIdLookupOf<T>, pool_id: PoolId) -> DispatchResult {
        let root = T::Lookup::lookup(root)?;
        let nominator = T::Lookup::lookup(nominator)?;
        let bouncer = T::Lookup::lookup(bouncer)?;
        {
            if !(amount >= Pallet::<T>::depositor_min_bond()) {
                    { return Err(Error::<T>::MinimumBondNotMet.into()) };
                }
        };
        {
            if !MaxPools::<T>::get().map_or(true,
                            |max_pools| BondedPools::<T>::count() < max_pools) {
                    { return Err(Error::<T>::MaxPools.into()) };
                }
        };
        {
            if !!PoolMembers::<T>::contains_key(&who) {
                    {
                        return Err(Error::<T>::AccountBelongsToOtherPool.into())
                    };
                }
        };
        let mut bonded_pool =
            BondedPool::<T>::new(pool_id,
                PoolRoles {
                    root: Some(root),
                    nominator: Some(nominator),
                    bouncer: Some(bouncer),
                    depositor: who.clone(),
                });
        bonded_pool.try_inc_members()?;
        let points =
            bonded_pool.try_bond_funds(&who, amount, BondType::Create)?;
        T::Currency::transfer(&who, &bonded_pool.reward_account(),
                T::Currency::minimum_balance(), Preservation::Expendable)?;
        Self::freeze_pool_deposit(&bonded_pool.reward_account())?;
        PoolMembers::<T>::insert(who.clone(),
            PoolMember::<T> {
                pool_id,
                points,
                last_recorded_reward_counter: Zero::zero(),
                unbonding_eras: Default::default(),
            });
        RewardPools::<T>::insert(pool_id,
            RewardPool::<T> {
                last_recorded_reward_counter: Zero::zero(),
                last_recorded_total_payouts: Zero::zero(),
                total_rewards_claimed: Zero::zero(),
                total_commission_pending: Zero::zero(),
                total_commission_claimed: Zero::zero(),
            });
        ReversePoolIdLookup::<T>::insert(bonded_pool.bonded_account(),
            pool_id);
        Self::deposit_event(Event::<T>::Created {
                depositor: who.clone(),
                pool_id,
            });
        Self::deposit_event(Event::<T>::Bonded {
                member: who,
                pool_id,
                bonded: amount,
                joined: true,
            });
        bonded_pool.put();
        Ok(())
    }
    fn do_bond_extra(signer: T::AccountId, who: T::AccountId,
        extra: BondExtra<BalanceOf<T>>) -> DispatchResult {
        if signer != who {
                {
                    if !ClaimPermissions::<T>::get(&who).can_bond_extra() {
                            { return Err(Error::<T>::DoesNotHavePermission.into()) };
                        }
                };
                {
                    if !(extra == BondExtra::Rewards) {
                            { return Err(Error::<T>::BondExtraRestricted.into()) };
                        }
                };
            }
        let (mut member, mut bonded_pool, mut reward_pool) =
            Self::get_member_with_pools(&who)?;
        reward_pool.update_records(bonded_pool.id, bonded_pool.points,
                bonded_pool.commission.current())?;
        let claimed =
            Self::do_reward_payout(&who, &mut member, &mut bonded_pool,
                    &mut reward_pool)?;
        let (points_issued, bonded) =
            match extra {
                BondExtra::FreeBalance(amount) =>
                    (bonded_pool.try_bond_funds(&who, amount, BondType::Later)?,
                        amount),
                BondExtra::Rewards =>
                    (bonded_pool.try_bond_funds(&who, claimed,
                                BondType::Later)?, claimed),
            };
        bonded_pool.ok_to_be_open()?;
        member.points =
            member.points.checked_add(&points_issued).ok_or(Error::<T>::OverflowRisk)?;
        Self::deposit_event(Event::<T>::Bonded {
                member: who.clone(),
                pool_id: member.pool_id,
                bonded,
                joined: false,
            });
        Self::put_member_with_pools(&who, member, bonded_pool, reward_pool);
        Ok(())
    }
    fn do_claim_commission(who: T::AccountId, pool_id: PoolId)
        -> DispatchResult {
        let bonded_pool =
            BondedPool::<T>::get(pool_id).ok_or(Error::<T>::PoolNotFound)?;
        {
            if !bonded_pool.can_claim_commission(&who) {
                    { return Err(Error::<T>::DoesNotHavePermission.into()) };
                }
        };
        let mut reward_pool =
            RewardPools::<T>::get(pool_id).defensive_ok_or::<Error<T>>(DefensiveError::RewardPoolNotFound.into())?;
        reward_pool.update_records(pool_id, bonded_pool.points,
                bonded_pool.commission.current())?;
        let commission = reward_pool.total_commission_pending;
        {
            if !!commission.is_zero() {
                    { return Err(Error::<T>::NoPendingCommission.into()) };
                }
        };
        let payee =
            bonded_pool.commission.current.as_ref().map(|(_, p)|
                            p.clone()).ok_or(Error::<T>::NoCommissionCurrentSet)?;
        T::Currency::transfer(&bonded_pool.reward_account(), &payee,
                commission, Preservation::Preserve)?;
        reward_pool.total_commission_claimed =
            reward_pool.total_commission_claimed.saturating_add(commission);
        reward_pool.total_commission_pending = Zero::zero();
        RewardPools::<T>::insert(pool_id, reward_pool);
        Self::deposit_event(Event::<T>::PoolCommissionClaimed {
                pool_id,
                commission,
            });
        Ok(())
    }
    fn do_claim_payout(signer: T::AccountId, who: T::AccountId)
        -> DispatchResult {
        if signer != who {
                {
                    if !ClaimPermissions::<T>::get(&who).can_claim_payout() {
                            { return Err(Error::<T>::DoesNotHavePermission.into()) };
                        }
                };
            }
        let (mut member, mut bonded_pool, mut reward_pool) =
            Self::get_member_with_pools(&who)?;
        let _ =
            Self::do_reward_payout(&who, &mut member, &mut bonded_pool,
                    &mut reward_pool)?;
        Self::put_member_with_pools(&who, member, bonded_pool, reward_pool);
        Ok(())
    }
    fn do_adjust_pool_deposit(who: T::AccountId, pool: PoolId)
        -> DispatchResult {
        let bonded_pool =
            BondedPool::<T>::get(pool).ok_or(Error::<T>::PoolNotFound)?;
        let reward_acc = &bonded_pool.reward_account();
        let pre_frozen_balance =
            T::Currency::balance_frozen(&FreezeReason::PoolMinBalance.into(),
                reward_acc);
        let min_balance = T::Currency::minimum_balance();
        if pre_frozen_balance == min_balance {
                return Err(Error::<T>::NothingToAdjust.into())
            }
        Self::freeze_pool_deposit(reward_acc)?;
        if pre_frozen_balance > min_balance {
                let excess = pre_frozen_balance.saturating_sub(min_balance);
                T::Currency::transfer(reward_acc, &who, excess,
                        Preservation::Preserve)?;
                Self::deposit_event(Event::<T>::MinBalanceExcessAdjusted {
                        pool_id: pool,
                        amount: excess,
                    });
            } else {
               let deficit = min_balance.saturating_sub(pre_frozen_balance);
               T::Currency::transfer(&who, reward_acc, deficit,
                       Preservation::Expendable)?;
               Self::deposit_event(Event::<T>::MinBalanceDeficitAdjusted {
                       pool_id: pool,
                       amount: deficit,
                   });
           }
        Ok(())
    }
    /// Apply freeze on reward account to restrict it from going below ED.
    pub(crate) fn freeze_pool_deposit(reward_acc: &T::AccountId)
        -> DispatchResult {
        T::Currency::set_freeze(&FreezeReason::PoolMinBalance.into(),
            reward_acc, T::Currency::minimum_balance())
    }
    /// Removes the ED freeze on the reward account of `pool_id`.
    pub fn unfreeze_pool_deposit(reward_acc: &T::AccountId)
        -> DispatchResult {
        T::Currency::thaw(&FreezeReason::PoolMinBalance.into(), reward_acc)
    }
    /// Ensure the correctness of the state of this pallet.
    ///
    /// This should be valid before or after each state transition of this pallet.
    ///
    /// ## Invariants:
    ///
    /// First, let's consider pools:
    ///
    /// * `BondedPools` and `RewardPools` must all have the EXACT SAME key-set.
    /// * `SubPoolsStorage` must be a subset of the above superset.
    /// * `Metadata` keys must be a subset of the above superset.
    /// * the count of the above set must be less than `MaxPools`.
    ///
    /// Then, considering members as well:
    ///
    /// * each `BondedPool.member_counter` must be:
    ///   - correct (compared to actual count of member who have `.pool_id` this pool)
    ///   - less than `MaxPoolMembersPerPool`.
    /// * each `member.pool_id` must correspond to an existing `BondedPool.id` (which implies the
    ///   existence of the reward pool as well).
    /// * count of all members must be less than `MaxPoolMembers`.
    ///
    /// Then, considering unbonding members:
    ///
    /// for each pool:
    ///   * sum of the balance that's tracked in all unbonding pools must be the same as the
    ///     unbonded balance of the main account, as reported by the staking interface.
    ///   * sum of the balance that's tracked in all unbonding pools, plus the bonded balance of the
    ///     main account should be less than or qual to the total balance of the main account.
    ///
    /// ## Sanity check level
    ///
    /// To cater for tests that want to escape parts of these checks, this function is split into
    /// multiple `level`s, where the higher the level, the more checks we performs. So,
    /// `try_state(255)` is the strongest sanity check, and `0` performs no checks.
    #[cfg(any(feature = "try-runtime", feature = "fuzzing", test,
    debug_assertions))]
    pub fn do_try_state(level: u8) -> Result<(), TryRuntimeError> {
        if level.is_zero() { return Ok(()) }
        let bonded_pools = BondedPools::<T>::iter_keys().collect::<Vec<_>>();
        let reward_pools = RewardPools::<T>::iter_keys().collect::<Vec<_>>();
        {
            if !(bonded_pools == reward_pools) {
                    {
                        return Err("`BondedPools` and `RewardPools` must all have the EXACT SAME key-set.".into())
                    };
                }
        };
        {
            if !SubPoolsStorage::<T>::iter_keys().all(|k|
                                bonded_pools.contains(&k)) {
                    {
                        return Err("`SubPoolsStorage` must be a subset of the above superset.".into())
                    };
                }
        };
        {
            if !Metadata::<T>::iter_keys().all(|k| bonded_pools.contains(&k))
                    {
                    {
                        return Err("`Metadata` keys must be a subset of the above superset.".into())
                    };
                }
        };
        {
            if !MaxPools::<T>::get().map_or(true,
                            |max| bonded_pools.len() <= (max as usize)) {
                    { return Err(Error::<T>::MaxPools.into()) };
                }
        };
        for id in reward_pools {
            let account = Self::create_reward_account(id);
            if T::Currency::reducible_balance(&account,
                            Preservation::Expendable, Fortitude::Polite) <
                        T::Currency::minimum_balance() {
                    {
                        let lvl = ::log::Level::Warn;
                        if lvl <= ::log::STATIC_MAX_LEVEL &&
                                    lvl <= ::log::max_level() {
                                ::log::__private_api::log(format_args!("[{0:?}] üèä\u{{200d}}‚ôÇÔ∏è reward pool of {1:?}: {2:?} (ed = {3:?}), should only happen because ED has changed recently. Pool operators should be notified to top up the reward account",
                                        <frame_system::Pallet<T>>::block_number(), id,
                                        T::Currency::reducible_balance(&account,
                                            Preservation::Expendable, Fortitude::Polite),
                                        T::Currency::minimum_balance()), lvl,
                                    &(crate::LOG_TARGET, "pallet_nomination_pools",
                                            "substrate/frame/nomination-pools/src/lib.rs"), 3338u32,
                                    ::log::__private_api::Option::None);
                            }
                    }
                }
        }
        let mut pools_members = BTreeMap::<PoolId, u32>::new();
        let mut pools_members_pending_rewards =
            BTreeMap::<PoolId, BalanceOf<T>>::new();
        let mut all_members = 0u32;
        let mut total_balance_members = Default::default();
        PoolMembers::<T>::iter().try_for_each(|(_, d)|
                    -> Result<(), TryRuntimeError>
                    {
                        let bonded_pool = BondedPools::<T>::get(d.pool_id).unwrap();
                        {
                            if !!d.total_points().is_zero() {
                                    { return Err("No member should have zero points".into()) };
                                }
                        };
                        *pools_members.entry(d.pool_id).or_default() += 1;
                        all_members += 1;
                        let reward_pool = RewardPools::<T>::get(d.pool_id).unwrap();
                        if !bonded_pool.points.is_zero() {
                                let commission = bonded_pool.commission.current();
                                let (current_rc, _) =
                                    reward_pool.current_reward_counter(d.pool_id,
                                            bonded_pool.points, commission).unwrap();
                                let pending_rewards =
                                    d.pending_rewards(current_rc).unwrap();
                                *pools_members_pending_rewards.entry(d.pool_id).or_default()
                                    += pending_rewards;
                            }
                        total_balance_members += d.total_balance();
                        Ok(())
                    })?;
        RewardPools::<T>::iter_keys().try_for_each(|id|
                    -> Result<(), TryRuntimeError>
                    {
                        let pending_rewards_lt_leftover_bal =
                            RewardPool::<T>::current_balance(id) >=
                                pools_members_pending_rewards.get(&id).copied().unwrap_or_default();
                        if !pending_rewards_lt_leftover_bal {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL &&
                                                lvl <= ::log::max_level() {
                                            ::log::__private_api::log(format_args!("pool {0:?}, sum pending rewards = {1:?}, remaining balance = {2:?}",
                                                    id, pools_members_pending_rewards.get(&id),
                                                    RewardPool::<T>::current_balance(id)), lvl,
                                                &("pallet_nomination_pools", "pallet_nomination_pools",
                                                        "substrate/frame/nomination-pools/src/lib.rs"), 3387u32,
                                                ::log::__private_api::Option::None);
                                        }
                                };
                            }
                        Ok(())
                    })?;
        let mut expected_tvl: BalanceOf<T> = Default::default();
        BondedPools::<T>::iter().try_for_each(|(id, inner)|
                    -> Result<(), TryRuntimeError>
                    {
                        let bonded_pool = BondedPool { id, inner };
                        {
                            if !(pools_members.get(&id).copied().unwrap_or_default() ==
                                            bonded_pool.member_counter) {
                                    {
                                        return Err("Each `BondedPool.member_counter` must be equal to the actual count of members of this pool".into())
                                    };
                                }
                        };
                        {
                            if !MaxPoolMembersPerPool::<T>::get().map_or(true,
                                            |max| bonded_pool.member_counter <= max) {
                                    { return Err(Error::<T>::MaxPoolMembers.into()) };
                                }
                        };
                        let depositor =
                            PoolMembers::<T>::get(&bonded_pool.roles.depositor).unwrap();
                        {
                            if !(bonded_pool.is_destroying_and_only_depositor(depositor.active_points())
                                            || depositor.active_points() >= MinCreateBond::<T>::get()) {
                                    {
                                        return Err("depositor must always have MinCreateBond stake in the pool, except for when the \
				pool is being destroyed and the depositor is the last member".into())
                                    };
                                }
                        };
                        expected_tvl +=
                            T::Staking::total_stake(&bonded_pool.bonded_account()).unwrap_or_default();
                        Ok(())
                    })?;
        {
            if !MaxPoolMembers::<T>::get().map_or(true,
                            |max| all_members <= max) {
                    { return Err(Error::<T>::MaxPoolMembers.into()) };
                }
        };
        {
            if !(TotalValueLocked::<T>::get() == expected_tvl) {
                    {
                        return Err("TVL deviates from the actual sum of funds of all Pools.".into())
                    };
                }
        };
        {
            if !(TotalValueLocked::<T>::get() <= total_balance_members) {
                    {
                        return Err("TVL must be equal to or less than the total balance of all PoolMembers.".into())
                    };
                }
        };
        if level <= 1 { return Ok(()) }
        for (pool_id, _pool) in BondedPools::<T>::iter() {
            let pool_account = Pallet::<T>::create_bonded_account(pool_id);
            let subs = SubPoolsStorage::<T>::get(pool_id).unwrap_or_default();
            let sum_unbonding_balance = subs.sum_unbonding_balance();
            let bonded_balance =
                T::Staking::active_stake(&pool_account).unwrap_or_default();
            let total_balance = T::Currency::total_balance(&pool_account);
            if !(total_balance >= bonded_balance + sum_unbonding_balance) {
                    {
                        ::core::panicking::panic_fmt(format_args!("faulty pool: {0:?} / {1:?}, total_balance {2:?} >= bonded_balance {3:?} + sum_unbonding_balance {4:?}",
                                pool_id, _pool, total_balance, bonded_balance,
                                sum_unbonding_balance));
                    }
                };
        }
        let _ = Self::check_ed_imbalance()?;
        Ok(())
    }
    /// Check if any pool have an incorrect amount of ED frozen.
    ///
    /// This can happen if the ED has changed since the pool was created.
    #[cfg(any(feature = "try-runtime", feature = "runtime-benchmarks", feature
    = "fuzzing", test, debug_assertions))]
    pub fn check_ed_imbalance() -> Result<(), DispatchError> {
        let mut failed: u32 = 0;
        BondedPools::<T>::iter_keys().for_each(|id|
                {
                    let reward_acc = Self::create_reward_account(id);
                    let frozen_balance =
                        T::Currency::balance_frozen(&FreezeReason::PoolMinBalance.into(),
                            &reward_acc);
                    let expected_frozen_balance =
                        T::Currency::minimum_balance();
                    if frozen_balance != expected_frozen_balance {
                            failed += 1;
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL &&
                                            lvl <= ::log::max_level() {
                                        ::log::__private_api::log(format_args!("pool {0:?} has incorrect ED frozen that can result from change in ED. Expected  = {1:?},  Actual = {2:?}",
                                                id, expected_frozen_balance, frozen_balance), lvl,
                                            &("pallet_nomination_pools", "pallet_nomination_pools",
                                                    "substrate/frame/nomination-pools/src/lib.rs"), 3490u32,
                                            ::log::__private_api::Option::None);
                                    }
                            };
                        }
                });
        {
            if !(failed == 0) {
                    {
                        return Err("Some pools do not have correct ED frozen".into())
                    };
                }
        };
        Ok(())
    }
}
impl<T: Config> Pallet<T> {
    /// Returns the pending rewards for the specified `who` account.
    ///
    /// In the case of error, `None` is returned. Used by runtime API.
    pub fn api_pending_rewards(who: T::AccountId) -> Option<BalanceOf<T>> {
        if let Some(pool_member) = PoolMembers::<T>::get(who) {
                if let Some((reward_pool, bonded_pool)) =
                            RewardPools::<T>::get(pool_member.pool_id).zip(BondedPools::<T>::get(pool_member.pool_id))
                        {
                        let commission = bonded_pool.commission.current();
                        let (current_reward_counter, _) =
                            reward_pool.current_reward_counter(pool_member.pool_id,
                                        bonded_pool.points, commission).ok()?;
                        return pool_member.pending_rewards(current_reward_counter).ok()
                    }
            }
        None
    }
    /// Returns the points to balance conversion for a specified pool.
    ///
    /// If the pool ID does not exist, it returns 0 ratio points to balance. Used by runtime API.
    pub fn api_points_to_balance(pool_id: PoolId, points: BalanceOf<T>)
        -> BalanceOf<T> {
        if let Some(pool) = BondedPool::<T>::get(pool_id) {
                pool.points_to_balance(points)
            } else { Zero::zero() }
    }
    /// Returns the equivalent `new_funds` balance to point conversion for a specified pool.
    ///
    /// If the pool ID does not exist, returns 0 ratio balance to points. Used by runtime API.
    pub fn api_balance_to_points(pool_id: PoolId, new_funds: BalanceOf<T>)
        -> BalanceOf<T> {
        if let Some(pool) = BondedPool::<T>::get(pool_id) {
                let bonded_balance =
                    T::Staking::active_stake(&pool.bonded_account()).unwrap_or(Zero::zero());
                Pallet::<T>::balance_to_point(bonded_balance, pool.points,
                    new_funds)
            } else { Zero::zero() }
    }
}
impl<T: Config> sp_staking::OnStakingUpdate<T::AccountId, BalanceOf<T>> for
    Pallet<T> {
    /// Reduces the balances of the [`SubPools`], that belong to the pool involved in the
    /// slash, to the amount that is defined in the `slashed_unlocking` field of
    /// [`sp_staking::OnStakingUpdate::on_slash`]
    ///
    /// Emits the `PoolsSlashed` event.
    fn on_slash(pool_account: &T::AccountId, slashed_bonded: BalanceOf<T>,
        slashed_unlocking: &BTreeMap<EraIndex, BalanceOf<T>>,
        total_slashed: BalanceOf<T>) {
        let Some(pool_id) =
            ReversePoolIdLookup::<T>::get(pool_account) else { return };
        TotalValueLocked::<T>::mutate(|tvl|
                { tvl.defensive_saturating_reduce(total_slashed); });
        if let Some(mut sub_pools) = SubPoolsStorage::<T>::get(pool_id) {
                slashed_unlocking.iter().for_each(|(era, slashed_balance)|
                        {
                            if let Some(pool) =
                                        sub_pools.with_era.get_mut(era).defensive() {
                                    pool.balance = *slashed_balance;
                                    Self::deposit_event(Event::<T>::UnbondingPoolSlashed {
                                            era: *era,
                                            pool_id,
                                            balance: *slashed_balance,
                                        });
                                }
                        });
                SubPoolsStorage::<T>::insert(pool_id, sub_pools);
            } else if !slashed_unlocking.is_empty() {
               {
                   let lvl = ::log::Level::Error;
                   if lvl <= ::log::STATIC_MAX_LEVEL &&
                               lvl <= ::log::max_level() {
                           ::log::__private_api::log(format_args!("{0}: {1:?}",
                                   ::frame_support::traits::DEFENSIVE_OP_PUBLIC_ERROR,
                                   "Expected SubPools were not found"), lvl,
                               &("runtime::defensive", "pallet_nomination_pools",
                                       "substrate/frame/nomination-pools/src/lib.rs"), 3597u32,
                               ::log::__private_api::Option::None);
                       }
               };
               if true {
                       if !false {
                               {
                                   ::core::panicking::panic_fmt(format_args!("{0}: {1:?}",
                                           ::frame_support::traits::DEFENSIVE_OP_INTERNAL_ERROR,
                                           "Expected SubPools were not found"));
                               }
                           };
                   };
               ;
           }
        Self::deposit_event(Event::<T>::PoolSlashed {
                pool_id,
                balance: slashed_bonded,
            });
    }
}
