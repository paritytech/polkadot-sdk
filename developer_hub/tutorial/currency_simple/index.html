<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The first tutorial of the Polkadot SDK. Write a simple currency pallet, in which you will learn the basics of FRAME."><title>developer_hub::tutorial::currency_simple - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="developer_hub" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../developer_hub/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../developer_hub/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module currency_simple</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">developer_hub</a>::<wbr><a href="../index.html">tutorial</a>::<wbr><a class="mod" href="#">currency_simple</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/developer_hub/tutorial/currency_simple/mod.rs.html#1-735">source</a> ¬∑ <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The first tutorial of the Polkadot SDK. Write a simple currency pallet, in which you will learn
the basics of FRAME.</p>
<h2 id="currency-pallet"><a href="#currency-pallet">Currency Pallet</a></h2>
<p>By the end of this tutorial, you will write a small FRAME pallet (see
<a href="../../polkadot_sdk/frame_runtime/index.html" title="mod developer_hub::polkadot_sdk::frame_runtime"><code>crate::polkadot_sdk::frame_runtime</code></a>) that is capable of handling a simple crypto-currency.
This pallet will:</p>
<ol>
<li>Allow a anyone to mint new tokens into accounts (which is obviously not a great idea for a
real system).</li>
<li>Allow any user that owns tokens to transfer them to others.</li>
<li>Tracks of the total issuance of all tokens at all times.</li>
</ol>
<blockquote>
<p>This tutorial will build a currency pallet from scratch using only the lowest primitives of
FRAME, and is mainly intended for education, not <em>applicability</em>. For example, almost all
FRAME-based runtimes use various techniques to re-use a currency pallet instead of writing
one. Further advance FRAME related topics are discussed in <a href="../../reference_docs/index.html" title="mod developer_hub::reference_docs"><code>crate::reference_docs</code></a>.</p>
</blockquote>
<h3 id="topics-covered"><a href="#topics-covered">Topics Covered</a></h3>
<p>The following FRAME topics are covered in this tutorial. See the rust-doc of the associated
items to know more.</p>
<ul>
<li><a href="frame::pallet_macros::storage%60">Storage</a></li>
<li><a href="frame::pallet_macros::call">Call</a></li>
<li><a href="frame::pallet_macros::event">Event</a></li>
<li><a href="frame::pallet_macros::error">Error</a></li>
<li>Basics of testing a pallet.</li>
<li><a href="frame::runtime::prelude::construct_runtime">Constructing a runtime</a></li>
</ul>
<h3 id="writing-your-first-pallet"><a href="#writing-your-first-pallet">Writing Your First Pallet</a></h3>
<p>You should have studied the following modules as a prelude to this tutorial:</p>
<ul>
<li><a href="../../reference_docs/blockchain_state_machines/index.html" title="mod developer_hub::reference_docs::blockchain_state_machines"><code>crate::reference_docs::blockchain_state_machines</code></a></li>
<li><a href="../../reference_docs/trait_based_programming/index.html" title="mod developer_hub::reference_docs::trait_based_programming"><code>crate::reference_docs::trait_based_programming</code></a></li>
<li><a href="../../polkadot_sdk/frame_runtime/index.html" title="mod developer_hub::polkadot_sdk::frame_runtime"><code>crate::polkadot_sdk::frame_runtime</code></a></li>
</ul>
<h4 id="shell-pallet"><a href="#shell-pallet">Shell Pallet</a></h4>
<p>Consider the following as a ‚Äúshell pallet‚Äù. We continue building the rest of this pallet based
on this template.</p>
<p><a href="frame::pallet_macros::config"><code>pallet::config</code></a> and
<a href="frame::pallet_macros::pallet"><code>pallet::pallet</code></a> are both mandatory parts of any pallet. Refer
to the documentation of each to get an overview of what they do.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[frame::pallet(dev_mode)]
</span><span class="kw">pub mod </span>shell_pallet {
	<span class="kw">use </span>frame::prelude::<span class="kw-2">*</span>;

	<span class="attr">#[pallet::config]
	</span><span class="kw">pub trait </span>Config: frame_system::Config {}

	<span class="attr">#[pallet::pallet]
	</span><span class="kw">pub struct </span>Pallet&lt;T&gt;(<span class="kw">_</span>);
}</code></pre></div>
<h4 id="storage"><a href="#storage">Storage</a></h4>
<p>First, we will need to create two onchain storage declarations.</p>
<p>One should be a mapping from account-ids to a balance type, and one value that is the total
issuance.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">pub type </span>Balance = u128;</code></pre></div>
<p>The definition of these two storage items, based on [<code>frame::pallet_macros::storage</code>] details,
is as follows:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::storage]
</span><span class="kw">pub type </span>TotalIssuance&lt;T: Config&gt; = StorageValue&lt;<span class="kw">_</span>, Balance&gt;;</code></pre></div>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::storage]
</span><span class="kw">pub type </span>Balances&lt;T: Config&gt; = StorageMap&lt;<span class="kw">_</span>, <span class="kw">_</span>, T::AccountId, Balance&gt;;</code></pre></div>
<h4 id="dispatchables"><a href="#dispatchables">Dispatchables</a></h4>
<p>Next, we will define the dispatchable functions. As per [<code>frame::pallet_macros::call</code>], these
will be defined as normal <code>fn</code>s attached to <code>struct Pallet</code>.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::call]
</span><span class="kw">impl</span>&lt;T: Config&gt; Pallet&lt;T&gt; {
	<span class="doccomment">/// An unsafe mint that can be called by anyone. Not a great idea.
	</span><span class="kw">pub fn </span>mint_unsafe(
		origin: T::RuntimeOrigin,
		dest: T::AccountId,
		amount: Balance,
	) -&gt; DispatchResult {
		<span class="comment">// ensure that this is a signed account, but we don&#39;t really check `_anyone`.
		</span><span class="kw">let </span>_anyone = ensure_signed(origin)<span class="question-mark">?</span>;

		<span class="comment">// update the balances map. Notice how all `&lt;T: Config&gt;` remains as `&lt;T&gt;`.
		</span>Balances::&lt;T&gt;::mutate(dest, |b| <span class="kw-2">*</span>b = <span class="prelude-val">Some</span>(b.unwrap_or(<span class="number">0</span>) + amount));
		<span class="comment">// update total issuance.
		</span>TotalIssuance::&lt;T&gt;::mutate(|t| <span class="kw-2">*</span>t = <span class="prelude-val">Some</span>(t.unwrap_or(<span class="number">0</span>) + amount));

		<span class="prelude-val">Ok</span>(())
	}

	<span class="doccomment">/// Transfer `amount` from `origin` to `dest`.
	</span><span class="kw">pub fn </span>transfer(
		origin: T::RuntimeOrigin,
		dest: T::AccountId,
		amount: Balance,
	) -&gt; DispatchResult {
		<span class="kw">let </span>sender = ensure_signed(origin)<span class="question-mark">?</span>;

		<span class="comment">// ensure sender has enough balance, and if so, calculate what is left after `amount`.
		</span><span class="kw">let </span>sender_balance = Balances::&lt;T&gt;::get(<span class="kw-2">&amp;</span>sender).ok_or(<span class="string">&quot;NonExistentAccount&quot;</span>)<span class="question-mark">?</span>;
		<span class="kw">if </span>sender_balance &lt; amount {
			<span class="kw">return </span><span class="prelude-val">Err</span>(<span class="string">&quot;InsufficientBalance&quot;</span>.into())
		}
		<span class="kw">let </span>reminder = sender_balance - amount;

		<span class="comment">// update sender and dest balances.
		</span>Balances::&lt;T&gt;::mutate(dest, |b| <span class="kw-2">*</span>b = <span class="prelude-val">Some</span>(b.unwrap_or(<span class="number">0</span>) + amount));
		Balances::&lt;T&gt;::insert(<span class="kw-2">&amp;</span>sender, reminder);

		<span class="prelude-val">Ok</span>(())
	}
}</code></pre></div>
<p>The logic of the functions is self-explanatory. Instead, we will focus on the FRAME-related
details:</p>
<ul>
<li>Where do <code>T::AccountId</code> and <code>T::RuntimeOrigin</code> come from? These are both defined in
[<code>frame::prelude::frame_system::Config</code>], therefore we can access them in <code>T</code>.</li>
<li>What is <code>ensure_signed</code>, and what does it do with the aforementioned <code>T::RuntimeOrigin</code>? this
is outside the scope of this tutorial, and you can learn more about it in the origin reference
document (<a href="../../reference_docs/origin_account_abstraction/index.html" title="mod developer_hub::reference_docs::origin_account_abstraction"><code>crate::reference_docs::origin_account_abstraction</code></a>). For now, you should only
know the signature of the function: it takes a generic <code>T::RuntimeOrigin</code> and returns a
<code>Result&lt;T::AccountId, _&gt;</code>. So by the end of this function call, we know that this dispatchable
was signed by <code>who</code>.</li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">pub fn </span>ensure_signed&lt;OuterOrigin, AccountId&gt;(o: OuterOrigin) -&gt; <span class="prelude-ty">Result</span>&lt;AccountId, BadOrigin&gt;
<span class="kw">where
	</span>OuterOrigin: Into&lt;<span class="prelude-ty">Result</span>&lt;RawOrigin&lt;AccountId&gt;, OuterOrigin&gt;&gt;,
{
	<span class="kw">match </span>o.into() {
		<span class="prelude-val">Ok</span>(RawOrigin::Signed(t)) =&gt; <span class="prelude-val">Ok</span>(t),
		<span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(BadOrigin),
	}
}</code></pre></div>
<ul>
<li>
<p>Where does <code>mutate</code>, <code>get</code> and <code>insert</code> and other storage APIs come from? all of them are
explained in the corresponding <code>type</code>, for example, for <code>Balances::&lt;T&gt;::insert</code>, you can look
into <a href="../../../frame_support/storage/types/map/struct.StorageMap.html#method.insert" title="associated function frame_support::storage::types::map::StorageMap::insert"><code>frame::prelude::StorageMap::insert</code></a>.</p>
</li>
<li>
<p>The return type of all dispatchable functions is <a href="../../../frame_support/dispatch/type.DispatchResult.html" title="type frame_support::dispatch::DispatchResult"><code>frame::prelude::DispatchResult</code></a>:</p>
</li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">pub type </span>DispatchResult = <span class="prelude-ty">Result</span>&lt;(), sp_runtime::DispatchError&gt;;</code></pre></div>
<p>Which is more or less a normal Rust <code>Result</code>, with a custom <a href="../../../sp_runtime/enum.DispatchError.html" title="enum sp_runtime::DispatchError"><code>frame::prelude::DispatchError</code></a> as
the <code>Err</code> variant. We won‚Äôt cover this error in detail here, but importantly you should know
that there is an <code>impl From&lt;&amp;'static string&gt; for DispatchError</code> provided (see
<a href="../../../sp_runtime/enum.DispatchError.html#impl-From%3C%26&#x27;static+str%3E-for-DispatchError" title="enum sp_runtime::DispatchError">here</a>). Therefore,
we can use basic string literals as our error type and <code>.into()</code> them into <code>DispatchError</code>.</p>
<ul>
<li>Why are all <code>get</code> and <code>mutate</code> functions returning an <code>Option</code>? This is the default behavior
of FRAME storage APIs. You can learn more about how to override this by looking into
[<code>frame::pallet_macros::storage</code>], and
<a href="../../../frame_support/storage/types/struct.ValueQuery.html" title="struct frame_support::storage::types::ValueQuery"><code>frame::prelude::ValueQuery</code></a>/<a href="../../../frame_support/storage/types/struct.OptionQuery.html" title="struct frame_support::storage::types::OptionQuery"><code>frame::prelude::OptionQuery</code></a></li>
</ul>
<h4 id="improving-errors"><a href="#improving-errors">Improving Errors</a></h4>
<p>How we handle error in the above snippets is fairly rudimentary. Let‚Äôs look at how this can be
improved. First, we can use <a href="../../../frame_support/macro.ensure.html" title="macro frame_support::ensure"><code>frame::prelude::ensure</code></a> to express the error slightly better.
This macro will call <code>.into()</code> under the hood.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">pub fn </span>transfer_better(
	origin: T::RuntimeOrigin,
	dest: T::AccountId,
	amount: Balance,
) -&gt; DispatchResult {
	<span class="kw">let </span>sender = ensure_signed(origin)<span class="question-mark">?</span>;

	<span class="kw">let </span>sender_balance = Balances::&lt;T&gt;::get(<span class="kw-2">&amp;</span>sender).ok_or(<span class="string">&quot;NonExistentAccount&quot;</span>)<span class="question-mark">?</span>;
	<span class="macro">ensure!</span>(sender_balance &gt;= amount, <span class="string">&quot;InsufficientBalance&quot;</span>);
	<span class="kw">let </span>reminder = sender_balance - amount;

	<span class="comment">// .. snip
	</span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Moreover, you will learn elsewhere (<a href="../../reference_docs/safe_defensive_programming/index.html" title="mod developer_hub::reference_docs::safe_defensive_programming"><code>crate::reference_docs::safe_defensive_programming</code></a>) that
it is always recommended to use safe arithmetic operations in your runtime. By using
<a href="https://docs.rs/num-traits/0.2/num_traits/ops/checked/trait.CheckedSub.html" title="trait num_traits::ops::checked::CheckedSub"><code>frame::traits::CheckedSub</code></a>, we can not only take a step in that direction, but also improve
the error handing and make it slightly more ergonomic.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">pub fn </span>transfer_better_checked(
	origin: T::RuntimeOrigin,
	dest: T::AccountId,
	amount: Balance,
) -&gt; DispatchResult {
	<span class="kw">let </span>sender = ensure_signed(origin)<span class="question-mark">?</span>;

	<span class="kw">let </span>sender_balance = Balances::&lt;T&gt;::get(<span class="kw-2">&amp;</span>sender).ok_or(<span class="string">&quot;NonExistentAccount&quot;</span>)<span class="question-mark">?</span>;
	<span class="kw">let </span>reminder = sender_balance.checked_sub(amount).ok_or(<span class="string">&quot;InsufficientBalance&quot;</span>)<span class="question-mark">?</span>;

	<span class="comment">// .. snip
	</span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>This is more or less all the logic that there is this basic currency pallet!</p>
<h4 id="your-first-test-runtime"><a href="#your-first-test-runtime">Your First (Test) Runtime</a></h4>
<p>Next, we create a ‚Äútest runtime‚Äù in order to test our pallet. Recall from
<a href="../../polkadot_sdk/frame_runtime/index.html" title="mod developer_hub::polkadot_sdk::frame_runtime"><code>crate::polkadot_sdk::frame_runtime</code></a> that a runtime is a collection of pallets, expressed
through [<code>frame::runtime::prelude::construct_runtime</code>]. All runtimes also have to include
[<code>frame::prelude::frame_system</code>]. So we expect to see a runtime with two pallet, <code>frame_system</code>
and the one we just wrote.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>runtime {
	<span class="kw">use super</span>::<span class="kw-2">*</span>;
	<span class="comment">// we need to reference our `mod pallet` as an identifier to pass to
	// `construct_runtime`.
	</span><span class="kw">use </span><span class="kw">crate</span>::tutorial::currency_simple::pallet <span class="kw">as </span>pallet_currency;

	<span class="macro">construct_runtime!</span>(
		<span class="kw">pub struct </span>Runtime {
			<span class="comment">// ---^^^^^^ This is where `struct Runtime` is defined.
			</span>System: frame_system,
			Currency: pallet_currency,
		}
	);

	<span class="attr">#[derive_impl(frame_system::config_preludes::TestDefaultConfig <span class="kw">as </span>frame_system::DefaultConfig)]
	</span><span class="kw">impl </span>frame_system::Config <span class="kw">for </span>Runtime {
		<span class="kw">type </span>Block = MockBlock&lt;Runtime&gt;;
		<span class="comment">// within pallet we just said `&lt;T as frame_system::Config&gt;::AccountId`, now we
		// finally specified it.
		</span><span class="kw">type </span>AccountId = u64;
	}

	<span class="comment">// our simple pallet has nothing to be configured.
	</span><span class="kw">impl </span>pallet_currency::Config <span class="kw">for </span>Runtime {}
}</code></pre></div>
<blockquote>
<p>[<code>frame::pallet_macros::derive_impl</code>] is a FRAME feature that enables developers to have
defaults for associated types.</p>
</blockquote>
<p>Recall that within out pallet, (almost) all blocks of code are generic over <code>&lt;T: Config&gt;</code>. And,
because <code>trait Config: frame_system::Config</code>, we can get access to all items in <code>Config</code> (or
<code>frame_system::Config</code>) using <code>T::NameOfItem</code>. This is all within the boundaries of how Rust
traits and generics work. In unfamiliar with this pattern, read
<a href="../../reference_docs/trait_based_programming/index.html" title="mod developer_hub::reference_docs::trait_based_programming"><code>crate::reference_docs::trait_based_programming</code></a> before going further.</p>
<p>Crucially, a typical FRAME runtime contains a <code>struct Runtime</code>. The main role of this <code>struct</code>
is to implement the <code>trait Config</code> of all pallets. That is, anywhere within your pallet code
where you see <code>&lt;T: Config&gt;</code> (read: <em>‚Äúsome type <code>T</code> that implements <code>Config</code>‚Äù</em>), in the runtime,
it can be replaced with <code>&lt;Runtime&gt;</code>, because <code>Runtime</code> implements <code>Config</code> of all pallets, as we
see above.</p>
<p>Another way to think about this is that within a pallet, a lot of types are ‚Äúunknown‚Äù and, we
only know that they will be provided at some later point. For example, when you write
<code>T::AccountId</code> (which is short for <code>&lt;T as frame_system::Config&gt;</code>) in your pallet, you are in
fact saying ‚Äú<em>Some type <code>AccountId</code> that will be known later</em>‚Äù. That ‚Äúlater‚Äù is in fact when you
specify these types when you implement all <code>Config</code> traits for <code>Runtime</code>.</p>
<p>As you see above, <code>frame_system::Config</code> is setting the <code>AccountId</code> to <code>u64</code>. Of course, a real
runtime will not use this type, and instead reside to a proper type like a 32-byte standard
public key. This is a HUGE benefit that FRAME developers can tap into: through the framework
being so generic, different types can always be customized to simple things when needed.</p>
<blockquote>
<p>Imagine how hard it would have been if all tests had to use a real 32-byte account id, as
opposed to just a u64 number üôà.</p>
</blockquote>
<h4 id="your-first-test"><a href="#your-first-test">Your First Test</a></h4>
<p>The above is all you need to execute the dispatchables of your pallet. The last thing you need
to learn is that all of your pallet testing code should be wrapped in
<a href="../../../sp_io/type.TestExternalities.html" title="type sp_io::TestExternalities"><code>frame::testing_prelude::TestState</code></a>. This is a type that provides access to an in-memory state
to be used in our tests.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>first_test() {
	TestState::new_empty().execute_with(|| {
		<span class="comment">// We expect account 1 to have no funds.
		</span><span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">None</span>);
		<span class="macro">assert_eq!</span>(TotalIssuance::&lt;Runtime&gt;::get(), <span class="prelude-val">None</span>);

		<span class="comment">// mint some funds into 1
		</span><span class="macro">assert_ok!</span>(Pallet::&lt;Runtime&gt;::mint_unsafe(RuntimeOrigin::signed(<span class="number">1</span>), <span class="number">1</span>, <span class="number">100</span>));

		<span class="comment">// re-check the above
		</span><span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="number">100</span>));
		<span class="macro">assert_eq!</span>(TotalIssuance::&lt;Runtime&gt;::get(), <span class="prelude-val">Some</span>(<span class="number">100</span>));
	})
}</code></pre></div>
<p>In the first test, we simply assert that there is no total issuance, and no balance associated
with account <code>1</code>. Then, we mint some balance into <code>1</code>, and re-check.</p>
<p>As noted above, the <code>T::AccountId</code> is now <code>u64</code>. Moreover, <code>Runtime</code> is replacing <code>&lt;T: Config&gt;</code>.
This is why for example you see <code>Balances::&lt;Runtime&gt;::get(..)</code>. Finally, notice that the
dispatchables are simply functions that can be called on top of the <code>Pallet</code> struct.</p>
<p>TODO: hard to explain exactly <code>RuntimeOrigin::signed(1)</code> at this point.</p>
<p>Congratulations! You have written your first pallet and tested it! Next, we learn a few optional
steps to improve our pallet.</p>
<h3 id="improving-the-currency-pallet"><a href="#improving-the-currency-pallet">Improving the Currency Pallet</a></h3><h4 id="better-test-setup"><a href="#better-test-setup">Better Test Setup</a></h4>
<p>Idiomatic FRAME pallets often use Builder pattern to define their initial state.</p>
<blockquote>
<p>The Polkadot Blockchain Academy‚Äôs Rust entrance exam has a
<a href="https://github.com/Polkadot-Blockchain-Academy/pba-qualifier-exam/blob/main/src/m_builder.rs">section</a>
on this that you can use to learn the Builder Pattern.</p>
</blockquote>
<p>Let‚Äôs see how we can implement a better test setup using this pattern. First, we define a
<code>struct StateBuilder</code>.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct </span>StateBuilder {
	balances: Vec&lt;(&lt;Runtime <span class="kw">as </span>frame_system::Config&gt;::AccountId, Balance)&gt;,
}</code></pre></div>
<p>This struct is meant to contain the same list of accounts and balances that we want to have at
the beginning of each block. We hardcoded this to <code>let accounts = vec![(1, 100), (2, 100)];</code> so
far. Then, if desired, we attach a default value for this struct.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>Default <span class="kw">for </span>StateBuilder {
	<span class="kw">fn </span>default() -&gt; <span class="self">Self </span>{
		<span class="self">Self </span>{ balances: <span class="macro">vec!</span>[(<span class="number">1</span>, <span class="number">100</span>), (<span class="number">2</span>, <span class="number">100</span>)] }
	}
}</code></pre></div>
<p>Like any other builder pattern, we attach functions to the type to mutate its internal
properties.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>StateBuilder {
	<span class="kw">fn </span>add_balance(
		<span class="kw-2">mut </span><span class="self">self</span>,
		who: &lt;Runtime <span class="kw">as </span>frame_system::Config&gt;::AccountId,
		amount: Balance,
	) -&gt; <span class="self">Self </span>{
		<span class="self">self</span>.balances.push((who, amount));
		<span class="self">self
	</span>}
}</code></pre></div>
<p>Finally ‚Äìthe useful part‚Äì we write our own custom <code>build_and_execute</code> function on
this type. This function will do multiple things:</p>
<ol>
<li>It would consume <code>self</code> to produce our <code>TestState</code> based on the properties that we attached
to <code>self</code>.</li>
<li>It would execute any test function that we pass in as closure.</li>
<li>A nifty trick, this allows our test setup to have some code that is executed both before and
after each test. For example, in this test, we do some additional checking about the
correctness of the <code>TotalIssuance</code>. We leave it up to you as an exercise to learn why the
assertion should always hold, and how it is checked.</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>StateBuilder {
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>build_and_execute(<span class="self">self</span>, test: <span class="kw">impl </span>FnOnce() -&gt; ()) {
		<span class="kw">let </span><span class="kw-2">mut </span>ext = TestState::new_empty();
		ext.execute_with(|| {
			<span class="kw">for </span>(who, amount) <span class="kw">in </span><span class="kw-2">&amp;</span><span class="self">self</span>.balances {
				Balances::&lt;Runtime&gt;::insert(who, amount);
				TotalIssuance::&lt;Runtime&gt;::mutate(|b| <span class="kw-2">*</span>b = <span class="prelude-val">Some</span>(b.unwrap_or(<span class="number">0</span>) + amount));
			}
		});

		ext.execute_with(test);

		<span class="comment">// assertions that must always hold
		</span>ext.execute_with(|| {
			<span class="macro">assert_eq!</span>(
				Balances::&lt;Runtime&gt;::iter().map(|(<span class="kw">_</span>, x)| x).sum::&lt;u128&gt;(),
				TotalIssuance::&lt;Runtime&gt;::get().unwrap_or_default()
			);
		})
	}
}</code></pre></div>
<p>We can write tests that specifically check the initial state, and making sure our <code>StateBuilder</code>
is working exactly as intended.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>state_builder_works() {
	StateBuilder::default().build_and_execute(|| {
		<span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="number">100</span>));
		<span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="number">100</span>));
		<span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">3</span>), <span class="prelude-val">None</span>);
		<span class="macro">assert_eq!</span>(TotalIssuance::&lt;Runtime&gt;::get(), <span class="prelude-val">Some</span>(<span class="number">200</span>));
	});
}</code></pre></div>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>state_builder_add_balance() {
	StateBuilder::default().add_balance(<span class="number">3</span>, <span class="number">42</span>).build_and_execute(|| {
		<span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">3</span>), <span class="prelude-val">Some</span>(<span class="number">42</span>));
		<span class="macro">assert_eq!</span>(TotalIssuance::&lt;Runtime&gt;::get(), <span class="prelude-val">Some</span>(<span class="number">242</span>));
	})
}</code></pre></div>
<h4 id="more-tests"><a href="#more-tests">More Tests</a></h4>
<p>Now that we have a more ergonomic test setup, let‚Äôs see how a well written test for transfer and
mint would look like.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>transfer_works() {
	StateBuilder::default().build_and_execute(|| {
		<span class="comment">// given the the initial state, when:
		</span><span class="macro">assert_ok!</span>(Pallet::&lt;Runtime&gt;::transfer(RuntimeOrigin::signed(<span class="number">1</span>), <span class="number">2</span>, <span class="number">50</span>));

		<span class="comment">// then:
		</span><span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="number">50</span>));
		<span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="number">150</span>));
		<span class="macro">assert_eq!</span>(TotalIssuance::&lt;Runtime&gt;::get(), <span class="prelude-val">Some</span>(<span class="number">200</span>));

		<span class="comment">// when:
		</span><span class="macro">assert_ok!</span>(Pallet::&lt;Runtime&gt;::transfer(RuntimeOrigin::signed(<span class="number">2</span>), <span class="number">1</span>, <span class="number">50</span>));

		<span class="comment">// then:
		</span><span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="number">100</span>));
		<span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="number">100</span>));
		<span class="macro">assert_eq!</span>(TotalIssuance::&lt;Runtime&gt;::get(), <span class="prelude-val">Some</span>(<span class="number">200</span>));
	});
}</code></pre></div>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>mint_works() {
	StateBuilder::default().build_and_execute(|| {
		<span class="comment">// given the initial state, when:
		</span><span class="macro">assert_ok!</span>(Pallet::&lt;Runtime&gt;::mint_unsafe(RuntimeOrigin::signed(<span class="number">1</span>), <span class="number">2</span>, <span class="number">100</span>));

		<span class="comment">// then:
		</span><span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="number">200</span>));
		<span class="macro">assert_eq!</span>(TotalIssuance::&lt;Runtime&gt;::get(), <span class="prelude-val">Some</span>(<span class="number">300</span>));

		<span class="comment">// given:
		</span><span class="macro">assert_ok!</span>(Pallet::&lt;Runtime&gt;::mint_unsafe(RuntimeOrigin::signed(<span class="number">1</span>), <span class="number">3</span>, <span class="number">100</span>));

		<span class="comment">// then:
		</span><span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">3</span>), <span class="prelude-val">Some</span>(<span class="number">100</span>));
		<span class="macro">assert_eq!</span>(TotalIssuance::&lt;Runtime&gt;::get(), <span class="prelude-val">Some</span>(<span class="number">400</span>));
	});
}</code></pre></div>
<p>It is always a good idea to build a mental model where you write <em>at least</em> one test for each
‚Äúsuccess path‚Äù of a dispatchable, and one test for each ‚Äúfailure path‚Äù, such as:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>transfer_from_non_existent_fails() {
	StateBuilder::default().build_and_execute(|| {
		<span class="comment">// given the the initial state, when:
		</span><span class="macro">assert_err!</span>(
			Pallet::&lt;Runtime&gt;::transfer(RuntimeOrigin::signed(<span class="number">3</span>), <span class="number">1</span>, <span class="number">10</span>),
			<span class="string">&quot;NonExistentAccount&quot;
		</span>);

		<span class="comment">// then nothing has changed.
		</span><span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="number">100</span>));
		<span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="number">100</span>));
		<span class="macro">assert_eq!</span>(Balances::&lt;Runtime&gt;::get(<span class="kw-2">&amp;</span><span class="number">3</span>), <span class="prelude-val">None</span>);
		<span class="macro">assert_eq!</span>(TotalIssuance::&lt;Runtime&gt;::get(), <span class="prelude-val">Some</span>(<span class="number">200</span>));
	});
}</code></pre></div>
<p>We leave it up to you to write a test that triggers to <code>InsufficientBalance</code> error.</p>
<h4 id="event-and-error"><a href="#event-and-error">Event and Error</a></h4>
<p>Our pallet is mainly missing two parts that are common in most FRAME pallets: Events, and
Errors. First, let‚Äôs understand what each are.</p>
<ul>
<li>
<p><strong>Error</strong>: The static string-based error scheme we used so far is good for readability, but it
has a few drawbacks. These string literals will bloat the final wasm blob, and are relatively
heavy to transmit and encode/decode. Moreover, it is easy to mistype then by one character.
FRAME errors are exactly a solution to maintain readability, whilst fixing the drawbacks
mentioned. In short, we use an enum to represent different variants of our error. These
variants are then mapped in an efficient way (using inly <code>u8</code> indices) to
<a href="../../../sp_runtime/enum.DispatchError.html#variant.Module" title="variant sp_runtime::DispatchError::Module"><code>sp_runtime::DispatchError::Module</code></a> Read more about this in [<code>frame::pallet_macros::error</code>].</p>
</li>
<li>
<p><strong>Event</strong>: Events are akin to the return type of dispatch-ables. They should represent what
happened at the end of a dispatch operation. Therefore, the convention is to use passive tense
for event names (eg. <code>SomethingHappened</code>). This allows other sub-systems or external parties
(eg. a light-client, A DApp) to listen to particular events happening, without needing to
re-execute the whole state transition function.</p>
</li>
</ul>
<p>TODO: both need to be improved a lot at the pallet-macro rust-doc level. Also my explanation
of event is probably not the best.</p>
<p>With the explanation out of the way, let‚Äôs see how these components can be added. Both follow a
fairly familiar syntax: normal Rust enums, with an extra <code>#[frame::event/error]</code> attribute
attached.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::event]
#[pallet::generate_deposit(<span class="kw">pub</span>(<span class="kw">super</span>) <span class="kw">fn </span>deposit_event)]
</span><span class="kw">pub enum </span>Event&lt;T: Config&gt; {
	<span class="doccomment">/// A transfer succeeded.
	</span>Transferred { from: T::AccountId, to: T::AccountId, amount: Balance },
}</code></pre></div>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::error]
</span><span class="kw">pub enum </span>Error&lt;T&gt; {
	<span class="doccomment">/// Account does not exist.
	</span>NonExistentAccount,
	<span class="doccomment">/// Account does not have enough balance.
	</span>InsufficientBalance,
}</code></pre></div>
<p>One slightly custom part of this is the <code>#[pallet::generate_deposit(pub(super) fn deposit_event)]</code> part. Without going into too much detail, in order for a pallet to emit events
to the rest of the system, it needs to do two things:</p>
<p>1.Declare a type in its <code>Config</code> that refers to the over-arching event type of the runtime. In
short, by doing this, the pallet is expressing an important bound: <code>type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt;</code>. Read: There exists a <code>RuntimeEvent</code>, and it can be created from the local
<code>enum Event</code> of this pallet. This enables the pallet to convert its <code>Event</code> into <code>RuntimeEvent</code>,
and store it where needed.</p>
<ol start="2">
<li>But, doing this conversion and storing is too much to expect each pallet to define. FRAME
provides a default way of storing events, in this is what <code>pallet::generate_deposit</code> is doing.</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="attr">#[pallet::config]
</span><span class="kw">pub trait </span>Config: frame_system::Config {
	<span class="doccomment">/// The overarching event type of the runtime.
	</span><span class="kw">type </span>RuntimeEvent: From&lt;Event&lt;<span class="self">Self</span>&gt;&gt;
		+ IsType&lt;&lt;<span class="self">Self </span><span class="kw">as </span>frame_system::Config&gt;::RuntimeEvent&gt;
		+ TryInto&lt;Event&lt;<span class="self">Self</span>&gt;&gt;;
}</code></pre></div>
<blockquote>
<p>These <code>Runtime*</code> types are better explained in
<a href="../../reference_docs/frame_composite_enums/index.html" title="mod developer_hub::reference_docs::frame_composite_enums"><code>crate::reference_docs::frame_composite_enums</code></a>.</p>
</blockquote>
<p>Then, we can rewrite the <code>transfer</code> dispatchable as such:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">pub fn </span>transfer(
	origin: T::RuntimeOrigin,
	dest: T::AccountId,
	amount: Balance,
) -&gt; DispatchResult {
	<span class="kw">let </span>sender = ensure_signed(origin)<span class="question-mark">?</span>;

	<span class="comment">// ensure sender has enough balance, and if so, calculate what is left after `amount`.
	</span><span class="kw">let </span>sender_balance =
		Balances::&lt;T&gt;::get(<span class="kw-2">&amp;</span>sender).ok_or(Error::&lt;T&gt;::NonExistentAccount)<span class="question-mark">?</span>;
	<span class="kw">let </span>reminder =
		sender_balance.checked_sub(amount).ok_or(Error::&lt;T&gt;::InsufficientBalance)<span class="question-mark">?</span>;

	Balances::&lt;T&gt;::mutate(<span class="kw-2">&amp;</span>dest, |b| <span class="kw-2">*</span>b = <span class="prelude-val">Some</span>(b.unwrap_or(<span class="number">0</span>) + amount));
	Balances::&lt;T&gt;::insert(<span class="kw-2">&amp;</span>sender, reminder);

	<span class="self">Self</span>::deposit_event(Event::&lt;T&gt;::Transferred { from: sender, to: dest, amount });

	<span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Then, notice how now we would need to provide this <code>type RuntimeEvent</code> in our test runtime
setup.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">‚ìò</a><pre class="rust rust-example-rendered"><code><span class="kw">pub mod </span>runtime_v2 {
	<span class="kw">use super</span>::<span class="kw-2">*</span>;
	<span class="kw">use </span><span class="kw">crate</span>::tutorial::currency_simple::pallet_v2 <span class="kw">as </span>pallet_currency;

	<span class="macro">construct_runtime!</span>(
		<span class="kw">pub struct </span>Runtime {
			System: frame_system,
			Currency: pallet_currency,
		}
	);

	<span class="attr">#[derive_impl(frame_system::config_preludes::TestDefaultConfig <span class="kw">as </span>frame_system::DefaultConfig)]
	</span><span class="kw">impl </span>frame_system::Config <span class="kw">for </span>Runtime {
		<span class="kw">type </span>Block = MockBlock&lt;Runtime&gt;;
		<span class="kw">type </span>AccountId = u64;
	}

	<span class="kw">impl </span>pallet_currency::Config <span class="kw">for </span>Runtime {
		<span class="kw">type </span>RuntimeEvent = RuntimeEvent;
	}
}</code></pre></div>
<p>In this snippet, the actual <code>RuntimeEvent</code> type (right hand side of <code>type RuntimeEvent = RuntimeEvent</code>) is generated by <code>construct_runtime</code>. An interesting way to inspect this type is
to see its definition in rust-docs:
<a href="pallet_v2/tests/runtime_v2/enum.RuntimeEvent.html" title="enum developer_hub::tutorial::currency_simple::pallet_v2::tests::runtime_v2::RuntimeEvent"><code>crate::tutorial::currency_simple::pallet_v2::tests::runtime_v2::RuntimeEvent</code></a>.</p>
<h3 id="what-next"><a href="#what-next">What Next?</a></h3>
<p>The following topics where used in this tutorial, but not covered in depth. It is suggested to
study them subsequently:</p>
<ul>
<li><a href="../../reference_docs/safe_defensive_programming/index.html" title="mod developer_hub::reference_docs::safe_defensive_programming"><code>crate::reference_docs::safe_defensive_programming</code></a>.</li>
<li><a href="../../reference_docs/origin_account_abstraction/index.html" title="mod developer_hub::reference_docs::origin_account_abstraction"><code>crate::reference_docs::origin_account_abstraction</code></a>.</li>
<li><a href="../../reference_docs/frame_composite_enums/index.html" title="mod developer_hub::reference_docs::frame_composite_enums"><code>crate::reference_docs::frame_composite_enums</code></a>.</li>
<li>The pallet we wrote in this tutorial was using <code>dev_mode</code>, learn more in
[<code>frame::pallet_macros::config</code>].</li>
<li>Learn more about the individual pallet items/macros, such as event and errors and call, in
<a href="../../../frame/pallet_macros/index.html" title="mod frame::pallet_macros"><code>frame::pallet_macros</code></a>.</li>
</ul>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="pallet/index.html" title="mod developer_hub::tutorial::currency_simple::pallet">pallet</a></div><div class="desc docblock-short">The <code>pallet</code> module in each FRAME pallet hosts the most important items needed
to construct this pallet.</div></li><li><div class="item-name"><a class="mod" href="pallet_v2/index.html" title="mod developer_hub::tutorial::currency_simple::pallet_v2">pallet_v2</a></div><div class="desc docblock-short">The <code>pallet</code> module in each FRAME pallet hosts the most important items needed
to construct this pallet.</div></li><li><div class="item-name"><a class="mod" href="shell_pallet/index.html" title="mod developer_hub::tutorial::currency_simple::shell_pallet">shell_pallet</a></div><div class="desc docblock-short">The <code>pallet</code> module in each FRAME pallet hosts the most important items needed
to construct this pallet.</div></li></ul></section></div></main></body></html>