// Copyright 2019-2023 Parity Technologies (UK) Ltd.
// This file is part of Parity Bridges Common.

// Parity Bridges Common is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity Bridges Common is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity Bridges Common.  If not, see <http://www.gnu.org/licenses/>.

//! Autogenerated runtime API
//! THIS FILE WAS AUTOGENERATED USING parity-bridges-common::runtime-codegen
//! EXECUTED COMMAND: target/debug/runtime-codegen --from-node-url ws://127.0.0.1:9944

#[allow(dead_code, unused_imports, non_camel_case_types)]
#[allow(clippy::all)]
pub mod api {
	use super::api as root_mod;
	pub mod runtime_types {
		use super::runtime_types;
		pub mod bounded_collections {
			use super::runtime_types;
			pub mod bounded_vec {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BoundedVec<_0>(pub ::std::vec::Vec<_0>);
			}
			pub mod weak_bounded_vec {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct WeakBoundedVec<_0>(pub ::std::vec::Vec<_0>);
			}
		}
		pub mod bp_header_chain {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct AuthoritySet {
				pub authorities: ::std::vec::Vec<(
					runtime_types::sp_consensus_grandpa::app::Public,
					::core::primitive::u64,
				)>,
				pub set_id: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum HeaderChainError {
				#[codec(index = 0)]
				UnknownHeader,
				#[codec(index = 1)]
				StorageProof(runtime_types::bp_runtime::storage_proof::Error),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct HeaderFinalityInfo<_0, _1> {
				pub finality_proof: _0,
				pub new_verification_context: ::core::option::Option<_1>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct StoredHeaderData<_0, _1> {
				pub number: _0,
				pub state_root: _1,
			}
		}
		pub mod bp_messages {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct DeliveredMessages {
				pub begin: ::core::primitive::u64,
				pub end: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct InboundLaneData<_0> {
				pub relayers: ::std::vec::Vec<runtime_types::bp_messages::UnrewardedRelayer<_0>>,
				pub last_confirmed_nonce: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct LaneId(pub [::core::primitive::u8; 4usize]);
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct MessageKey {
				pub lane_id: runtime_types::bp_messages::LaneId,
				pub nonce: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum MessagesOperatingMode {
				#[codec(index = 0)]
				Basic(runtime_types::bp_runtime::BasicOperatingMode),
				#[codec(index = 1)]
				RejectingOutboundMessages,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct OutboundLaneData {
				pub oldest_unpruned_nonce: ::core::primitive::u64,
				pub latest_received_nonce: ::core::primitive::u64,
				pub latest_generated_nonce: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum ReceivalResult<_0> {
				#[codec(index = 0)]
				Dispatched(runtime_types::bp_runtime::messages::MessageDispatchResult<_0>),
				#[codec(index = 1)]
				InvalidNonce,
				#[codec(index = 2)]
				TooManyUnrewardedRelayers,
				#[codec(index = 3)]
				TooManyUnconfirmedMessages,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ReceivedMessages<_0> {
				pub lane: runtime_types::bp_messages::LaneId,
				pub receive_results: ::std::vec::Vec<(
					::core::primitive::u64,
					runtime_types::bp_messages::ReceivalResult<_0>,
				)>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct UnrewardedRelayer<_0> {
				pub relayer: _0,
				pub messages: runtime_types::bp_messages::DeliveredMessages,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum VerificationError {
				#[codec(index = 0)]
				EmptyMessageProof,
				#[codec(index = 1)]
				HeaderChain(runtime_types::bp_header_chain::HeaderChainError),
				#[codec(index = 2)]
				InboundLaneStorage(runtime_types::bp_runtime::storage_proof::Error),
				#[codec(index = 3)]
				InvalidMessageWeight,
				#[codec(index = 4)]
				MessagesCountMismatch,
				#[codec(index = 5)]
				MessageStorage(runtime_types::bp_runtime::storage_proof::Error),
				#[codec(index = 6)]
				MessageTooLarge,
				#[codec(index = 7)]
				OutboundLaneStorage(runtime_types::bp_runtime::storage_proof::Error),
				#[codec(index = 8)]
				StorageProof(runtime_types::bp_runtime::storage_proof::Error),
				#[codec(index = 9)]
				Other,
			}
		}
		pub mod bp_parachains {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct BestParaHeadHash {
				pub at_relay_block_number: ::core::primitive::u32,
				pub head_hash: ::subxt::utils::H256,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ParaInfo {
				pub best_head_hash: runtime_types::bp_parachains::BestParaHeadHash,
				pub next_imported_hash_position: ::core::primitive::u32,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ParaStoredHeaderData(pub ::std::vec::Vec<::core::primitive::u8>);
		}
		pub mod bp_runtime {
			use super::runtime_types;
			pub mod messages {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct MessageDispatchResult<_0> {
					pub unspent_weight: ::sp_weights::Weight,
					pub dispatch_level_result: _0,
				}
			}
			pub mod storage_proof {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					DuplicateNodesInProof,
					#[codec(index = 1)]
					UnusedNodesInTheProof,
					#[codec(index = 2)]
					StorageRootMismatch,
					#[codec(index = 3)]
					StorageValueUnavailable,
					#[codec(index = 4)]
					StorageValueEmpty,
					#[codec(index = 5)]
					StorageValueDecodeFailed(runtime_types::bp_runtime::StrippableError),
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum BasicOperatingMode {
				#[codec(index = 0)]
				Normal,
				#[codec(index = 1)]
				Halted,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct HeaderId<_0, _1>(pub _1, pub _0);
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum OwnedBridgeModuleError {
				#[codec(index = 0)]
				Halted,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct StrippableError;
		}
		pub mod finality_grandpa {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Commit<_0, _1, _2, _3> {
				pub target_hash: _0,
				pub target_number: _1,
				pub precommits: ::std::vec::Vec<
					runtime_types::finality_grandpa::SignedPrecommit<_0, _1, _2, _3>,
				>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Equivocation<_0, _1, _2> {
				pub round_number: ::core::primitive::u64,
				pub identity: _0,
				pub first: (_1, _2),
				pub second: (_1, _2),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Precommit<_0, _1> {
				pub target_hash: _0,
				pub target_number: _1,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Prevote<_0, _1> {
				pub target_hash: _0,
				pub target_number: _1,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct SignedPrecommit<_0, _1, _2, _3> {
				pub precommit: runtime_types::finality_grandpa::Precommit<_0, _1>,
				pub signature: _2,
				pub id: _3,
			}
		}
		pub mod frame_support {
			use super::runtime_types;
			pub mod dispatch {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum DispatchClass {
					#[codec(index = 0)]
					Normal,
					#[codec(index = 1)]
					Operational,
					#[codec(index = 2)]
					Mandatory,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct DispatchInfo {
					pub weight: ::sp_weights::Weight,
					pub class: runtime_types::frame_support::dispatch::DispatchClass,
					pub pays_fee: runtime_types::frame_support::dispatch::Pays,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Pays {
					#[codec(index = 0)]
					Yes,
					#[codec(index = 1)]
					No,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PerDispatchClass<_0> {
					pub normal: _0,
					pub operational: _0,
					pub mandatory: _0,
				}
			}
		}
		pub mod frame_system {
			use super::runtime_types;
			pub mod extensions {
				use super::runtime_types;
				pub mod check_genesis {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckGenesis;
				}
				pub mod check_mortality {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckMortality(pub ::sp_runtime::generic::Era);
				}
				pub mod check_non_zero_sender {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckNonZeroSender;
				}
				pub mod check_nonce {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckNonce(#[codec(compact)] pub ::core::primitive::u32);
				}
				pub mod check_spec_version {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckSpecVersion;
				}
				pub mod check_tx_version {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckTxVersion;
				}
				pub mod check_weight {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckWeight;
				}
			}
			pub mod limits {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BlockLength {
					pub max: runtime_types::frame_support::dispatch::PerDispatchClass<
						::core::primitive::u32,
					>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BlockWeights {
					pub base_block: ::sp_weights::Weight,
					pub max_block: ::sp_weights::Weight,
					pub per_class: runtime_types::frame_support::dispatch::PerDispatchClass<
						runtime_types::frame_system::limits::WeightsPerClass,
					>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct WeightsPerClass {
					pub base_extrinsic: ::sp_weights::Weight,
					pub max_extrinsic: ::core::option::Option<::sp_weights::Weight>,
					pub max_total: ::core::option::Option<::sp_weights::Weight>,
					pub reserved: ::core::option::Option<::sp_weights::Weight>,
				}
			}
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					remark { remark: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 1)]
					set_heap_pages { pages: ::core::primitive::u64 },
					#[codec(index = 2)]
					set_code { code: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 3)]
					set_code_without_checks { code: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 4)]
					set_storage {
						items: ::std::vec::Vec<(
							::std::vec::Vec<::core::primitive::u8>,
							::std::vec::Vec<::core::primitive::u8>,
						)>,
					},
					#[codec(index = 5)]
					kill_storage { keys: ::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>> },
					#[codec(index = 6)]
					kill_prefix {
						prefix: ::std::vec::Vec<::core::primitive::u8>,
						subkeys: ::core::primitive::u32,
					},
					#[codec(index = 7)]
					remark_with_event { remark: ::std::vec::Vec<::core::primitive::u8> },
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidSpecName,
					#[codec(index = 1)]
					SpecVersionNeedsToIncrease,
					#[codec(index = 2)]
					FailedToExtractRuntimeVersion,
					#[codec(index = 3)]
					NonDefaultComposite,
					#[codec(index = 4)]
					NonZeroRefCount,
					#[codec(index = 5)]
					CallFiltered,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ExtrinsicSuccess {
						dispatch_info: runtime_types::frame_support::dispatch::DispatchInfo,
					},
					#[codec(index = 1)]
					ExtrinsicFailed {
						dispatch_error: runtime_types::sp_runtime::DispatchError,
						dispatch_info: runtime_types::frame_support::dispatch::DispatchInfo,
					},
					#[codec(index = 2)]
					CodeUpdated,
					#[codec(index = 3)]
					NewAccount { account: ::sp_core::crypto::AccountId32 },
					#[codec(index = 4)]
					KilledAccount { account: ::sp_core::crypto::AccountId32 },
					#[codec(index = 5)]
					Remarked { sender: ::sp_core::crypto::AccountId32, hash: ::subxt::utils::H256 },
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct AccountInfo<_0, _1> {
				pub nonce: _0,
				pub consumers: _0,
				pub providers: _0,
				pub sufficients: _0,
				pub data: _1,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct EventRecord<_0, _1> {
				pub phase: runtime_types::frame_system::Phase,
				pub event: _0,
				pub topics: ::std::vec::Vec<_1>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct LastRuntimeUpgradeInfo {
				#[codec(compact)]
				pub spec_version: ::core::primitive::u32,
				pub spec_name: ::std::string::String,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Phase {
				#[codec(index = 0)]
				ApplyExtrinsic(::core::primitive::u32),
				#[codec(index = 1)]
				Finalization,
				#[codec(index = 2)]
				Initialization,
			}
		}
		pub mod pallet_babe {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					report_equivocation {
						equivocation_proof: ::std::boxed::Box<
							runtime_types::sp_consensus_slots::EquivocationProof<
								::sp_runtime::generic::Header<
									::core::primitive::u32,
									::sp_runtime::traits::BlakeTwo256,
								>,
								runtime_types::sp_consensus_babe::app::Public,
							>,
						>,
						key_owner_proof: ::sp_session::MembershipProof,
					},
					#[codec(index = 1)]
					report_equivocation_unsigned {
						equivocation_proof: ::std::boxed::Box<
							runtime_types::sp_consensus_slots::EquivocationProof<
								::sp_runtime::generic::Header<
									::core::primitive::u32,
									::sp_runtime::traits::BlakeTwo256,
								>,
								runtime_types::sp_consensus_babe::app::Public,
							>,
						>,
						key_owner_proof: ::sp_session::MembershipProof,
					},
					#[codec(index = 2)]
					plan_config_change {
						config: runtime_types::sp_consensus_babe::digests::NextConfigDescriptor,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidEquivocationProof,
					#[codec(index = 1)]
					InvalidKeyOwnershipProof,
					#[codec(index = 2)]
					DuplicateOffenceReport,
					#[codec(index = 3)]
					InvalidConfiguration,
				}
			}
		}
		pub mod pallet_bridge_grandpa {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					submit_finality_proof {
						finality_target: ::std::boxed::Box<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
						justification: ::bp_header_chain::justification::GrandpaJustification<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
					},
					#[codec(index = 1)]
					initialize {
						init_data: ::bp_header_chain::InitializationData<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
					},
					#[codec(index = 2)]
					set_owner { new_owner: ::core::option::Option<::sp_core::crypto::AccountId32> },
					#[codec(index = 3)]
					set_operating_mode {
						operating_mode: runtime_types::bp_runtime::BasicOperatingMode,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidJustification,
					#[codec(index = 1)]
					InvalidAuthoritySet,
					#[codec(index = 2)]
					OldHeader,
					#[codec(index = 3)]
					UnsupportedScheduledChange,
					#[codec(index = 4)]
					NotInitialized,
					#[codec(index = 5)]
					AlreadyInitialized,
					#[codec(index = 6)]
					TooManyAuthoritiesInSet,
					#[codec(index = 7)]
					BridgeModule(runtime_types::bp_runtime::OwnedBridgeModuleError),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					UpdatedBestFinalizedHeader {
						number: ::core::primitive::u32,
						hash: ::subxt::utils::H256,
						grandpa_info: runtime_types::bp_header_chain::HeaderFinalityInfo<
							::bp_header_chain::justification::GrandpaJustification<
								::sp_runtime::generic::Header<
									::core::primitive::u32,
									::sp_runtime::traits::BlakeTwo256,
								>,
							>,
							runtime_types::bp_header_chain::AuthoritySet,
						>,
					},
				}
			}
			pub mod storage_types {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct StoredAuthoritySet {
					pub authorities: runtime_types::bounded_collections::bounded_vec::BoundedVec<(
						runtime_types::sp_consensus_grandpa::app::Public,
						::core::primitive::u64,
					)>,
					pub set_id: ::core::primitive::u64,
				}
			}
		}
		pub mod pallet_bridge_messages {
			use super::runtime_types;
			pub mod outbound_lane {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum ReceivalConfirmationError {
					#[codec(index = 0)]
					FailedToConfirmFutureMessages,
					#[codec(index = 1)]
					EmptyUnrewardedRelayerEntry,
					#[codec(index = 2)]
					NonConsecutiveUnrewardedRelayerEntries,
					#[codec(index = 3)]
					TryingToConfirmMoreMessagesThanExpected,
				}
			}
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set_owner { new_owner: ::core::option::Option<::sp_core::crypto::AccountId32> },
					#[codec(index = 1)]
					set_operating_mode {
						operating_mode: runtime_types::bp_messages::MessagesOperatingMode,
					},
					#[codec(index = 2)]
					receive_messages_proof {
						relayer_id_at_bridged_chain: ::sp_core::crypto::AccountId32,
						proof: bridge_runtime_common::messages::target::FromBridgedChainMessagesProof<
							::subxt::utils::H256,
						>,
						messages_count: ::core::primitive::u32,
						dispatch_weight: ::sp_weights::Weight,
					},
					#[codec(index = 3)]
					receive_messages_delivery_proof {
						proof: bridge_runtime_common::messages::source::FromBridgedChainMessagesDeliveryProof<
							::subxt::utils::H256,
						>,
						relayers_state: ::bp_messages::UnrewardedRelayersState,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					# [codec (index = 0)] NotOperatingNormally , # [codec (index = 1)] InactiveOutboundLane , # [codec (index = 2)] MessageDispatchInactive , # [codec (index = 3)] MessageRejectedByChainVerifier (runtime_types :: bp_messages :: VerificationError ,) , # [codec (index = 4)] MessageRejectedByLaneVerifier (runtime_types :: bp_messages :: VerificationError ,) , # [codec (index = 5)] MessageRejectedByPallet (runtime_types :: bp_messages :: VerificationError ,) , # [codec (index = 6)] FailedToWithdrawMessageFee , # [codec (index = 7)] TooManyMessagesInTheProof , # [codec (index = 8)] InvalidMessagesProof , # [codec (index = 9)] InvalidMessagesDeliveryProof , # [codec (index = 10)] InvalidUnrewardedRelayersState , # [codec (index = 11)] InsufficientDispatchWeight , # [codec (index = 12)] MessageIsNotYetSent , # [codec (index = 13)] ReceivalConfirmation (runtime_types :: pallet_bridge_messages :: outbound_lane :: ReceivalConfirmationError ,) , # [codec (index = 14)] BridgeModule (runtime_types :: bp_runtime :: OwnedBridgeModuleError ,) , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					MessageAccepted {
						lane_id: runtime_types::bp_messages::LaneId,
						nonce: ::core::primitive::u64,
					},
					#[codec(index = 1)]
					MessagesReceived(
						::std::vec::Vec<runtime_types::bp_messages::ReceivedMessages<()>>,
					),
					#[codec(index = 2)]
					MessagesDelivered {
						lane_id: runtime_types::bp_messages::LaneId,
						messages: runtime_types::bp_messages::DeliveredMessages,
					},
				}
			}
		}
		pub mod pallet_bridge_parachains {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					submit_parachain_heads {
						at_relay_block: (::core::primitive::u32, ::subxt::utils::H256),
						parachains: ::std::vec::Vec<(
							::bp_polkadot_core::parachains::ParaId,
							::subxt::utils::H256,
						)>,
						parachain_heads_proof: ::bp_polkadot_core::parachains::ParaHeadsProof,
					},
					#[codec(index = 1)]
					set_owner { new_owner: ::core::option::Option<::sp_core::crypto::AccountId32> },
					#[codec(index = 2)]
					set_operating_mode {
						operating_mode: runtime_types::bp_runtime::BasicOperatingMode,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					UnknownRelayChainBlock,
					#[codec(index = 1)]
					InvalidRelayChainBlockNumber,
					#[codec(index = 2)]
					HeaderChainStorageProof(runtime_types::bp_header_chain::HeaderChainError),
					#[codec(index = 3)]
					BridgeModule(runtime_types::bp_runtime::OwnedBridgeModuleError),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					UntrackedParachainRejected { parachain: ::bp_polkadot_core::parachains::ParaId },
					#[codec(index = 1)]
					MissingParachainHead { parachain: ::bp_polkadot_core::parachains::ParaId },
					#[codec(index = 2)]
					IncorrectParachainHeadHash {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
						actual_parachain_head_hash: ::subxt::utils::H256,
					},
					#[codec(index = 3)]
					RejectedObsoleteParachainHead {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
					},
					#[codec(index = 4)]
					RejectedLargeParachainHead {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
						parachain_head_size: ::core::primitive::u32,
					},
					#[codec(index = 5)]
					UpdatedParachainHead {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
					},
				}
			}
		}
		pub mod pallet_grandpa {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					report_equivocation {
						equivocation_proof: ::std::boxed::Box<
							::sp_consensus_grandpa::EquivocationProof<
								::subxt::utils::H256,
								::core::primitive::u32,
							>,
						>,
						key_owner_proof: ::sp_session::MembershipProof,
					},
					#[codec(index = 1)]
					report_equivocation_unsigned {
						equivocation_proof: ::std::boxed::Box<
							::sp_consensus_grandpa::EquivocationProof<
								::subxt::utils::H256,
								::core::primitive::u32,
							>,
						>,
						key_owner_proof: ::sp_session::MembershipProof,
					},
					#[codec(index = 2)]
					note_stalled {
						delay: ::core::primitive::u32,
						best_finalized_block_number: ::core::primitive::u32,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					PauseFailed,
					#[codec(index = 1)]
					ResumeFailed,
					#[codec(index = 2)]
					ChangePending,
					#[codec(index = 3)]
					TooSoon,
					#[codec(index = 4)]
					InvalidKeyOwnershipProof,
					#[codec(index = 5)]
					InvalidEquivocationProof,
					#[codec(index = 6)]
					DuplicateOffenceReport,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NewAuthorities {
						authority_set: ::std::vec::Vec<(
							runtime_types::sp_consensus_grandpa::app::Public,
							::core::primitive::u64,
						)>,
					},
					#[codec(index = 1)]
					Paused,
					#[codec(index = 2)]
					Resumed,
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct StoredPendingChange<_0> {
				pub scheduled_at: _0,
				pub delay: _0,
				pub next_authorities:
					runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<(
						runtime_types::sp_consensus_grandpa::app::Public,
						::core::primitive::u64,
					)>,
				pub forced: ::core::option::Option<_0>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum StoredState<_0> {
				#[codec(index = 0)]
				Live,
				#[codec(index = 1)]
				PendingPause { scheduled_at: _0, delay: _0 },
				#[codec(index = 2)]
				Paused,
				#[codec(index = 3)]
				PendingResume { scheduled_at: _0, delay: _0 },
			}
		}
		pub mod pallet_im_online {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					heartbeat {
						heartbeat:
							runtime_types::pallet_im_online::Heartbeat<::core::primitive::u32>,
						signature: runtime_types::pallet_im_online::sr25519::app_sr25519::Signature,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidKey,
					#[codec(index = 1)]
					DuplicatedHeartbeat,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					HeartbeatReceived {
						authority_id: runtime_types::pallet_im_online::sr25519::app_sr25519::Public,
					},
					#[codec(index = 1)]
					AllGood,
					#[codec(index = 2)]
					SomeOffline {
						offline: ::std::vec::Vec<(
							::sp_core::crypto::AccountId32,
							::sp_core::crypto::AccountId32,
						)>,
					},
				}
			}
			pub mod sr25519 {
				use super::runtime_types;
				pub mod app_sr25519 {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct Public(pub runtime_types::sp_core::sr25519::Public);
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct Signature(pub runtime_types::sp_core::sr25519::Signature);
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Heartbeat<_0> {
				pub block_number: _0,
				pub session_index: _0,
				pub authority_index: _0,
				pub validators_len: _0,
			}
		}
		pub mod pallet_offences {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Offence {
						kind: [::core::primitive::u8; 16usize],
						timeslot: ::std::vec::Vec<::core::primitive::u8>,
					},
				}
			}
		}
		pub mod pallet_session {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set_keys {
						keys: runtime_types::polkadot_bulletin_chain_runtime::opaque::SessionKeys,
						proof: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 1)]
					purge_keys,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidProof,
					#[codec(index = 1)]
					NoAssociatedValidatorId,
					#[codec(index = 2)]
					DuplicatedKey,
					#[codec(index = 3)]
					NoKeys,
					#[codec(index = 4)]
					NoAccount,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NewSession { session_index: ::core::primitive::u32 },
				}
			}
		}
		pub mod pallet_sudo {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					sudo {
						call: ::std::boxed::Box<
							runtime_types::polkadot_bulletin_chain_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 1)]
					sudo_unchecked_weight {
						call: ::std::boxed::Box<
							runtime_types::polkadot_bulletin_chain_runtime::RuntimeCall,
						>,
						weight: ::sp_weights::Weight,
					},
					#[codec(index = 2)]
					set_key {
						new: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
					},
					#[codec(index = 3)]
					sudo_as {
						who: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						call: ::std::boxed::Box<
							runtime_types::polkadot_bulletin_chain_runtime::RuntimeCall,
						>,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					RequireSudo,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Sudid {
						sudo_result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
					#[codec(index = 1)]
					KeyChanged {
						old_sudoer: ::core::option::Option<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 2)]
					SudoAsDone {
						sudo_result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
				}
			}
		}
		pub mod pallet_timestamp {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set {
						#[codec(compact)]
						now: ::core::primitive::u64,
					},
				}
			}
		}
		pub mod pallet_transaction_storage {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					store { data: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 1)]
					renew { block: ::core::primitive::u32, index: ::core::primitive::u32 },
					#[codec(index = 2)]
					check_proof {
						proof: runtime_types::sp_transaction_storage_proof::TransactionStorageProof,
					},
					#[codec(index = 3)]
					authorize_account {
						who: ::sp_core::crypto::AccountId32,
						transactions: ::core::primitive::u32,
						bytes: ::core::primitive::u64,
					},
					#[codec(index = 4)]
					authorize_preimage {
						hash: [::core::primitive::u8; 32usize],
						max_size: ::core::primitive::u64,
					},
					#[codec(index = 5)]
					remove_expired_account_authorization { who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 6)]
					remove_expired_preimage_authorization { hash: [::core::primitive::u8; 32usize] },
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					BadContext,
					#[codec(index = 1)]
					BadDataSize,
					#[codec(index = 2)]
					TooManyTransactions,
					#[codec(index = 3)]
					RenewedNotFound,
					#[codec(index = 4)]
					UnexpectedProof,
					#[codec(index = 5)]
					InvalidProof,
					#[codec(index = 6)]
					MissingStateData,
					#[codec(index = 7)]
					DoubleCheck,
					#[codec(index = 8)]
					AuthorizationNotFound,
					#[codec(index = 9)]
					AuthorizationNotExpired,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Stored { index: ::core::primitive::u32 },
					#[codec(index = 1)]
					Renewed { index: ::core::primitive::u32 },
					#[codec(index = 2)]
					ProofChecked,
					#[codec(index = 3)]
					AccountAuthorized {
						who: ::sp_core::crypto::AccountId32,
						transactions: ::core::primitive::u32,
						bytes: ::core::primitive::u64,
					},
					#[codec(index = 4)]
					PreimageAuthorized {
						hash: [::core::primitive::u8; 32usize],
						max_size: ::core::primitive::u64,
					},
					#[codec(index = 5)]
					ExpiredAccountAuthorizationRemoved { who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 6)]
					ExpiredPreimageAuthorizationRemoved { hash: [::core::primitive::u8; 32usize] },
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Authorization<_0> {
				pub extent: runtime_types::pallet_transaction_storage::AuthorizationExtent,
				pub expiration: _0,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct AuthorizationExtent {
				pub transactions: ::core::primitive::u32,
				pub bytes: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum AuthorizationScope<_0> {
				#[codec(index = 0)]
				Account(_0),
				#[codec(index = 1)]
				Preimage([::core::primitive::u8; 32usize]),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct TransactionInfo {
				pub chunk_root: ::subxt::utils::H256,
				pub content_hash: ::subxt::utils::H256,
				pub size: ::core::primitive::u32,
				pub block_chunks: ::core::primitive::u32,
			}
		}
		pub mod pallet_validator_set {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					add_validator { who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 1)]
					remove_validator { who: ::sp_core::crypto::AccountId32 },
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					Duplicate,
					#[codec(index = 1)]
					NotAValidator,
					#[codec(index = 2)]
					TooManyValidators,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ValidatorAdded(::sp_core::crypto::AccountId32),
					#[codec(index = 1)]
					ValidatorRemoved(::sp_core::crypto::AccountId32),
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Validator<_0> {
				pub min_set_keys_block: _0,
			}
		}
		pub mod polkadot_bulletin_chain_runtime {
			use super::runtime_types;
			pub mod opaque {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct SessionKeys {
					pub babe: runtime_types::sp_consensus_babe::app::Public,
					pub grandpa: runtime_types::sp_consensus_grandpa::app::Public,
					pub im_online: runtime_types::pallet_im_online::sr25519::app_sr25519::Public,
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Runtime;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeCall {
				#[codec(index = 0)]
				System(runtime_types::frame_system::pallet::Call),
				#[codec(index = 1)]
				Babe(runtime_types::pallet_babe::pallet::Call),
				#[codec(index = 2)]
				Timestamp(runtime_types::pallet_timestamp::pallet::Call),
				#[codec(index = 6)]
				ValidatorSet(runtime_types::pallet_validator_set::pallet::Call),
				#[codec(index = 7)]
				Session(runtime_types::pallet_session::pallet::Call),
				#[codec(index = 8)]
				ImOnline(runtime_types::pallet_im_online::pallet::Call),
				#[codec(index = 9)]
				Grandpa(runtime_types::pallet_grandpa::pallet::Call),
				#[codec(index = 10)]
				Sudo(runtime_types::pallet_sudo::pallet::Call),
				#[codec(index = 11)]
				TransactionStorage(runtime_types::pallet_transaction_storage::pallet::Call),
				#[codec(index = 12)]
				BridgePolkadotGrandpa(runtime_types::pallet_bridge_grandpa::pallet::Call),
				#[codec(index = 13)]
				BridgePolkadotParachains(runtime_types::pallet_bridge_parachains::pallet::Call),
				#[codec(index = 14)]
				BridgePolkadotBridgeHubMessages(
					runtime_types::pallet_bridge_messages::pallet::Call,
				),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeEvent {
				#[codec(index = 0)]
				System(runtime_types::frame_system::pallet::Event),
				#[codec(index = 4)]
				Offences(runtime_types::pallet_offences::pallet::Event),
				#[codec(index = 6)]
				ValidatorSet(runtime_types::pallet_validator_set::pallet::Event),
				#[codec(index = 7)]
				Session(runtime_types::pallet_session::pallet::Event),
				#[codec(index = 8)]
				ImOnline(runtime_types::pallet_im_online::pallet::Event),
				#[codec(index = 9)]
				Grandpa(runtime_types::pallet_grandpa::pallet::Event),
				#[codec(index = 10)]
				Sudo(runtime_types::pallet_sudo::pallet::Event),
				#[codec(index = 11)]
				TransactionStorage(runtime_types::pallet_transaction_storage::pallet::Event),
				#[codec(index = 12)]
				BridgePolkadotGrandpa(runtime_types::pallet_bridge_grandpa::pallet::Event),
				#[codec(index = 13)]
				BridgePolkadotParachains(runtime_types::pallet_bridge_parachains::pallet::Event),
				#[codec(index = 14)]
				BridgePolkadotBridgeHubMessages(
					runtime_types::pallet_bridge_messages::pallet::Event,
				),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ValidateSigned;
		}
		pub mod sp_arithmetic {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum ArithmeticError {
				#[codec(index = 0)]
				Underflow,
				#[codec(index = 1)]
				Overflow,
				#[codec(index = 2)]
				DivisionByZero,
			}
		}
		pub mod sp_consensus_babe {
			use super::runtime_types;
			pub mod app {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub runtime_types::sp_core::sr25519::Public);
			}
			pub mod digests {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum NextConfigDescriptor {
					#[codec(index = 1)]
					V1 {
						c: (::core::primitive::u64, ::core::primitive::u64),
						allowed_slots: runtime_types::sp_consensus_babe::AllowedSlots,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum PreDigest {
					#[codec(index = 1)]
					Primary(runtime_types::sp_consensus_babe::digests::PrimaryPreDigest),
					#[codec(index = 2)]
					SecondaryPlain(
						runtime_types::sp_consensus_babe::digests::SecondaryPlainPreDigest,
					),
					#[codec(index = 3)]
					SecondaryVRF(runtime_types::sp_consensus_babe::digests::SecondaryVRFPreDigest),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PrimaryPreDigest {
					pub authority_index: ::core::primitive::u32,
					pub slot: runtime_types::sp_consensus_slots::Slot,
					pub vrf_signature: runtime_types::sp_core::sr25519::vrf::VrfSignature,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct SecondaryPlainPreDigest {
					pub authority_index: ::core::primitive::u32,
					pub slot: runtime_types::sp_consensus_slots::Slot,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct SecondaryVRFPreDigest {
					pub authority_index: ::core::primitive::u32,
					pub slot: runtime_types::sp_consensus_slots::Slot,
					pub vrf_signature: runtime_types::sp_core::sr25519::vrf::VrfSignature,
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum AllowedSlots {
				#[codec(index = 0)]
				PrimarySlots,
				#[codec(index = 1)]
				PrimaryAndSecondaryPlainSlots,
				#[codec(index = 2)]
				PrimaryAndSecondaryVRFSlots,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct BabeEpochConfiguration {
				pub c: (::core::primitive::u64, ::core::primitive::u64),
				pub allowed_slots: runtime_types::sp_consensus_babe::AllowedSlots,
			}
		}
		pub mod sp_consensus_grandpa {
			use super::runtime_types;
			pub mod app {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub runtime_types::sp_core::ed25519::Public);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub runtime_types::sp_core::ed25519::Signature);
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Equivocation<_0, _1> {
				#[codec(index = 0)]
				Prevote(
					runtime_types::finality_grandpa::Equivocation<
						runtime_types::sp_consensus_grandpa::app::Public,
						runtime_types::finality_grandpa::Prevote<_0, _1>,
						runtime_types::sp_consensus_grandpa::app::Signature,
					>,
				),
				#[codec(index = 1)]
				Precommit(
					runtime_types::finality_grandpa::Equivocation<
						runtime_types::sp_consensus_grandpa::app::Public,
						runtime_types::finality_grandpa::Precommit<_0, _1>,
						runtime_types::sp_consensus_grandpa::app::Signature,
					>,
				),
			}
		}
		pub mod sp_consensus_slots {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct EquivocationProof<_0, _1> {
				pub offender: _1,
				pub slot: runtime_types::sp_consensus_slots::Slot,
				pub first_header: _0,
				pub second_header: _0,
			}
			#[derive(
				:: codec :: Decode,
				:: codec :: Encode,
				:: subxt :: ext :: codec :: CompactAs,
				Clone,
				Debug,
				PartialEq,
			)]
			pub struct Slot(pub ::core::primitive::u64);
		}
		pub mod sp_core {
			use super::runtime_types;
			pub mod crypto {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct KeyTypeId(pub [::core::primitive::u8; 4usize]);
			}
			pub mod ecdsa {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub [::core::primitive::u8; 65usize]);
			}
			pub mod ed25519 {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub [::core::primitive::u8; 32usize]);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub [::core::primitive::u8; 64usize]);
			}
			pub mod sr25519 {
				use super::runtime_types;
				pub mod vrf {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct VrfSignature {
						pub output: [::core::primitive::u8; 32usize],
						pub proof: [::core::primitive::u8; 64usize],
					}
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub [::core::primitive::u8; 32usize]);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub [::core::primitive::u8; 64usize]);
			}
		}
		pub mod sp_runtime {
			use super::runtime_types;
			pub mod generic {
				use super::runtime_types;
				pub mod digest {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum DigestItem {
						#[codec(index = 6)]
						PreRuntime(
							[::core::primitive::u8; 4usize],
							::std::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 4)]
						Consensus(
							[::core::primitive::u8; 4usize],
							::std::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 5)]
						Seal(
							[::core::primitive::u8; 4usize],
							::std::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 0)]
						Other(::std::vec::Vec<::core::primitive::u8>),
						#[codec(index = 8)]
						RuntimeEnvironmentUpdated,
					}
				}
				pub mod unchecked_extrinsic {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct UncheckedExtrinsic<_0, _1, _2, _3>(
						pub ::std::vec::Vec<::core::primitive::u8>,
						#[codec(skip)] pub ::core::marker::PhantomData<(_1, _0, _2, _3)>,
					);
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum DispatchError {
				#[codec(index = 0)]
				Other,
				#[codec(index = 1)]
				CannotLookup,
				#[codec(index = 2)]
				BadOrigin,
				#[codec(index = 3)]
				Module(runtime_types::sp_runtime::ModuleError),
				#[codec(index = 4)]
				ConsumerRemaining,
				#[codec(index = 5)]
				NoProviders,
				#[codec(index = 6)]
				TooManyConsumers,
				#[codec(index = 7)]
				Token(runtime_types::sp_runtime::TokenError),
				#[codec(index = 8)]
				Arithmetic(runtime_types::sp_arithmetic::ArithmeticError),
				#[codec(index = 9)]
				Transactional(runtime_types::sp_runtime::TransactionalError),
				#[codec(index = 10)]
				Exhausted,
				#[codec(index = 11)]
				Corruption,
				#[codec(index = 12)]
				Unavailable,
				#[codec(index = 13)]
				RootNotAllowed,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ModuleError {
				pub index: ::core::primitive::u8,
				pub error: [::core::primitive::u8; 4usize],
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum MultiSignature {
				#[codec(index = 0)]
				Ed25519(runtime_types::sp_core::ed25519::Signature),
				#[codec(index = 1)]
				Sr25519(runtime_types::sp_core::sr25519::Signature),
				#[codec(index = 2)]
				Ecdsa(runtime_types::sp_core::ecdsa::Signature),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum TokenError {
				#[codec(index = 0)]
				FundsUnavailable,
				#[codec(index = 1)]
				OnlyProvider,
				#[codec(index = 2)]
				BelowMinimum,
				#[codec(index = 3)]
				CannotCreate,
				#[codec(index = 4)]
				UnknownAsset,
				#[codec(index = 5)]
				Frozen,
				#[codec(index = 6)]
				Unsupported,
				#[codec(index = 7)]
				CannotCreateHold,
				#[codec(index = 8)]
				NotExpendable,
				#[codec(index = 9)]
				Blocked,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum TransactionalError {
				#[codec(index = 0)]
				LimitReached,
				#[codec(index = 1)]
				NoLayer,
			}
		}
		pub mod sp_staking {
			use super::runtime_types;
			pub mod offence {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct OffenceDetails<_0, _1> {
					pub offender: _1,
					pub reporters: ::std::vec::Vec<_0>,
				}
			}
		}
		pub mod sp_transaction_storage_proof {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct TransactionStorageProof {
				pub chunk: ::std::vec::Vec<::core::primitive::u8>,
				pub proof: ::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>>,
			}
		}
		pub mod sp_version {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct RuntimeVersion {
				pub spec_name: ::std::string::String,
				pub impl_name: ::std::string::String,
				pub authoring_version: ::core::primitive::u32,
				pub spec_version: ::core::primitive::u32,
				pub impl_version: ::core::primitive::u32,
				pub apis:
					::std::vec::Vec<([::core::primitive::u8; 8usize], ::core::primitive::u32)>,
				pub transaction_version: ::core::primitive::u32,
				pub state_version: ::core::primitive::u8,
			}
		}
		pub mod sp_weights {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct RuntimeDbWeight {
				pub read: ::core::primitive::u64,
				pub write: ::core::primitive::u64,
			}
		}
	}
}
