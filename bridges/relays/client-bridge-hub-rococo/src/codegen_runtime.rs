// Copyright 2019-2023 Parity Technologies (UK) Ltd.
// This file is part of Parity Bridges Common.

// Parity Bridges Common is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity Bridges Common is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity Bridges Common.  If not, see <http://www.gnu.org/licenses/>.

//! Autogenerated runtime API
//! THIS FILE WAS AUTOGENERATED USING parity-bridges-common::runtime-codegen
//! EXECUTED COMMAND: target/debug/runtime-codegen --from-wasm-file
//! ../../../polkadot-sdk/target/release/wbuild/bridge-hub-rococo-runtime/bridge_hub_rococo_runtime.
//! compact.compressed.wasm

#[allow(dead_code, unused_imports, non_camel_case_types)]
#[allow(clippy::all)]
#[allow(rustdoc::broken_intra_doc_links)]
pub mod api {
	#[allow(unused_imports)]
	mod root_mod {
		pub use super::*;
	}
	pub mod runtime_types {
		use super::runtime_types;
		pub mod bounded_collections {
			use super::runtime_types;
			pub mod bounded_btree_set {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BoundedBTreeSet<_0>(pub ::std::vec::Vec<_0>);
			}
			pub mod bounded_vec {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BoundedVec<_0>(pub ::std::vec::Vec<_0>);
			}
			pub mod weak_bounded_vec {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct WeakBoundedVec<_0>(pub ::std::vec::Vec<_0>);
			}
		}
		pub mod bp_header_chain {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct AuthoritySet {
				pub authorities: ::std::vec::Vec<(
					runtime_types::sp_consensus_grandpa::app::Public,
					::core::primitive::u64,
				)>,
				pub set_id: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum HeaderChainError {
				#[codec(index = 0)]
				UnknownHeader,
				#[codec(index = 1)]
				StorageProof(runtime_types::bp_runtime::storage_proof::Error),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct HeaderFinalityInfo<_0, _1> {
				pub finality_proof: _0,
				pub new_verification_context: ::core::option::Option<_1>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct StoredHeaderData<_0, _1> {
				pub number: _0,
				pub state_root: _1,
			}
		}
		pub mod bp_messages {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct DeliveredMessages {
				pub begin: ::core::primitive::u64,
				pub end: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct InboundLaneData<_0> {
				pub relayers: ::std::vec::Vec<runtime_types::bp_messages::UnrewardedRelayer<_0>>,
				pub last_confirmed_nonce: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct LaneId(pub [::core::primitive::u8; 4usize]);
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct MessageKey {
				pub lane_id: runtime_types::bp_messages::LaneId,
				pub nonce: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum MessagesOperatingMode {
				#[codec(index = 0)]
				Basic(runtime_types::bp_runtime::BasicOperatingMode),
				#[codec(index = 1)]
				RejectingOutboundMessages,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct OutboundLaneData {
				pub oldest_unpruned_nonce: ::core::primitive::u64,
				pub latest_received_nonce: ::core::primitive::u64,
				pub latest_generated_nonce: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum ReceivalResult<_0> {
				#[codec(index = 0)]
				Dispatched(runtime_types::bp_runtime::messages::MessageDispatchResult<_0>),
				#[codec(index = 1)]
				InvalidNonce,
				#[codec(index = 2)]
				TooManyUnrewardedRelayers,
				#[codec(index = 3)]
				TooManyUnconfirmedMessages,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ReceivedMessages<_0> {
				pub lane: runtime_types::bp_messages::LaneId,
				pub receive_results: ::std::vec::Vec<(
					::core::primitive::u64,
					runtime_types::bp_messages::ReceivalResult<_0>,
				)>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct UnrewardedRelayer<_0> {
				pub relayer: _0,
				pub messages: runtime_types::bp_messages::DeliveredMessages,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum VerificationError {
				#[codec(index = 0)]
				EmptyMessageProof,
				#[codec(index = 1)]
				HeaderChain(runtime_types::bp_header_chain::HeaderChainError),
				#[codec(index = 2)]
				InboundLaneStorage(runtime_types::bp_runtime::storage_proof::Error),
				#[codec(index = 3)]
				InvalidMessageWeight,
				#[codec(index = 4)]
				MessagesCountMismatch,
				#[codec(index = 5)]
				MessageStorage(runtime_types::bp_runtime::storage_proof::Error),
				#[codec(index = 6)]
				MessageTooLarge,
				#[codec(index = 7)]
				OutboundLaneStorage(runtime_types::bp_runtime::storage_proof::Error),
				#[codec(index = 8)]
				StorageProof(runtime_types::bp_runtime::storage_proof::Error),
				#[codec(index = 9)]
				Other,
			}
		}
		pub mod bp_parachains {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct BestParaHeadHash {
				pub at_relay_block_number: ::core::primitive::u32,
				pub head_hash: ::subxt::utils::H256,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ParaInfo {
				pub best_head_hash: runtime_types::bp_parachains::BestParaHeadHash,
				pub next_imported_hash_position: ::core::primitive::u32,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ParaStoredHeaderData(pub ::std::vec::Vec<::core::primitive::u8>);
		}
		pub mod bp_relayers {
			use super::runtime_types;
			pub mod registration {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Registration<_0, _1> {
					pub valid_till: _0,
					pub stake: _1,
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum RewardsAccountOwner {
				#[codec(index = 0)]
				ThisChain,
				#[codec(index = 1)]
				BridgedChain,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct RewardsAccountParams {
				pub lane_id: runtime_types::bp_messages::LaneId,
				pub bridged_chain_id: [::core::primitive::u8; 4usize],
				pub owner: runtime_types::bp_relayers::RewardsAccountOwner,
			}
		}
		pub mod bp_runtime {
			use super::runtime_types;
			pub mod messages {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct MessageDispatchResult<_0> {
					pub unspent_weight: ::sp_weights::Weight,
					pub dispatch_level_result: _0,
				}
			}
			pub mod storage_proof {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					DuplicateNodesInProof,
					#[codec(index = 1)]
					UnusedNodesInTheProof,
					#[codec(index = 2)]
					StorageRootMismatch,
					#[codec(index = 3)]
					StorageValueUnavailable,
					#[codec(index = 4)]
					StorageValueEmpty,
					#[codec(index = 5)]
					StorageValueDecodeFailed(runtime_types::bp_runtime::StrippableError),
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum BasicOperatingMode {
				#[codec(index = 0)]
				Normal,
				#[codec(index = 1)]
				Halted,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct HeaderId<_0, _1>(pub _1, pub _0);
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum OwnedBridgeModuleError {
				#[codec(index = 0)]
				Halted,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct StrippableError;
		}
		pub mod bridge_hub_common {
			use super::runtime_types;
			pub mod message_queue {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum AggregateMessageOrigin {
					#[codec(index = 0)]
					Here,
					#[codec(index = 1)]
					Parent,
					#[codec(index = 2)]
					Sibling(runtime_types::polkadot_parachain_primitives::primitives::Id),
					#[codec(index = 3)]
					Snowbridge(runtime_types::snowbridge_core::ChannelId),
				}
			}
		}
		pub mod bridge_hub_rococo_runtime {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct BridgeRejectObsoleteHeadersAndMessages;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum OriginCaller {
				#[codec(index = 0)]
				system(
					runtime_types::frame_support::dispatch::RawOrigin<
						::sp_core::crypto::AccountId32,
					>,
				),
				#[codec(index = 31)]
				PolkadotXcm(runtime_types::pallet_xcm::pallet::Origin),
				#[codec(index = 32)]
				CumulusXcm(runtime_types::cumulus_pallet_xcm::pallet::Origin),
				#[codec(index = 3)]
				Void(runtime_types::sp_core::Void),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Runtime;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeCall {
				#[codec(index = 0)]
				System(runtime_types::frame_system::pallet::Call),
				#[codec(index = 1)]
				ParachainSystem(runtime_types::cumulus_pallet_parachain_system::pallet::Call),
				#[codec(index = 2)]
				Timestamp(runtime_types::pallet_timestamp::pallet::Call),
				#[codec(index = 3)]
				ParachainInfo(runtime_types::staging_parachain_info::pallet::Call),
				#[codec(index = 10)]
				Balances(runtime_types::pallet_balances::pallet::Call),
				#[codec(index = 21)]
				CollatorSelection(runtime_types::pallet_collator_selection::pallet::Call),
				#[codec(index = 22)]
				Session(runtime_types::pallet_session::pallet::Call),
				#[codec(index = 30)]
				XcmpQueue(runtime_types::cumulus_pallet_xcmp_queue::pallet::Call),
				#[codec(index = 31)]
				PolkadotXcm(runtime_types::pallet_xcm::pallet::Call),
				#[codec(index = 32)]
				CumulusXcm(runtime_types::cumulus_pallet_xcm::pallet::Call),
				#[codec(index = 40)]
				Utility(runtime_types::pallet_utility::pallet::Call),
				#[codec(index = 36)]
				Multisig(runtime_types::pallet_multisig::pallet::Call),
				#[codec(index = 47)]
				BridgeRelayers(runtime_types::pallet_bridge_relayers::pallet::Call),
				#[codec(index = 48)]
				BridgeWestendGrandpa(runtime_types::pallet_bridge_grandpa::pallet::Call),
				#[codec(index = 49)]
				BridgeWestendParachains(runtime_types::pallet_bridge_parachains::pallet::Call),
				#[codec(index = 51)]
				BridgeWestendMessages(runtime_types::pallet_bridge_messages::pallet::Call),
				#[codec(index = 60)]
				BridgePolkadotBulletinGrandpa(runtime_types::pallet_bridge_grandpa::pallet::Call2),
				#[codec(index = 61)]
				BridgePolkadotBulletinMessages(
					runtime_types::pallet_bridge_messages::pallet::Call2,
				),
				#[codec(index = 80)]
				EthereumInboundQueue(runtime_types::snowbridge_pallet_inbound_queue::pallet::Call),
				#[codec(index = 81)]
				EthereumOutboundQueue(
					runtime_types::snowbridge_pallet_outbound_queue::pallet::Call,
				),
				#[codec(index = 82)]
				EthereumBeaconClient(
					runtime_types::snowbridge_pallet_ethereum_client::pallet::Call,
				),
				#[codec(index = 83)]
				EthereumSystem(runtime_types::snowbridge_pallet_system::pallet::Call),
				#[codec(index = 250)]
				MessageQueue(runtime_types::pallet_message_queue::pallet::Call),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeError {
				#[codec(index = 0)]
				System(runtime_types::frame_system::pallet::Error),
				#[codec(index = 1)]
				ParachainSystem(runtime_types::cumulus_pallet_parachain_system::pallet::Error),
				#[codec(index = 10)]
				Balances(runtime_types::pallet_balances::pallet::Error),
				#[codec(index = 21)]
				CollatorSelection(runtime_types::pallet_collator_selection::pallet::Error),
				#[codec(index = 22)]
				Session(runtime_types::pallet_session::pallet::Error),
				#[codec(index = 30)]
				XcmpQueue(runtime_types::cumulus_pallet_xcmp_queue::pallet::Error),
				#[codec(index = 31)]
				PolkadotXcm(runtime_types::pallet_xcm::pallet::Error),
				#[codec(index = 40)]
				Utility(runtime_types::pallet_utility::pallet::Error),
				#[codec(index = 36)]
				Multisig(runtime_types::pallet_multisig::pallet::Error),
				#[codec(index = 47)]
				BridgeRelayers(runtime_types::pallet_bridge_relayers::pallet::Error),
				#[codec(index = 48)]
				BridgeWestendGrandpa(runtime_types::pallet_bridge_grandpa::pallet::Error),
				#[codec(index = 49)]
				BridgeWestendParachains(runtime_types::pallet_bridge_parachains::pallet::Error),
				#[codec(index = 51)]
				BridgeWestendMessages(runtime_types::pallet_bridge_messages::pallet::Error),
				#[codec(index = 60)]
				BridgePolkadotBulletinGrandpa(runtime_types::pallet_bridge_grandpa::pallet::Error2),
				#[codec(index = 61)]
				BridgePolkadotBulletinMessages(
					runtime_types::pallet_bridge_messages::pallet::Error2,
				),
				#[codec(index = 80)]
				EthereumInboundQueue(runtime_types::snowbridge_pallet_inbound_queue::pallet::Error),
				#[codec(index = 81)]
				EthereumOutboundQueue(
					runtime_types::snowbridge_pallet_outbound_queue::pallet::Error,
				),
				#[codec(index = 82)]
				EthereumBeaconClient(
					runtime_types::snowbridge_pallet_ethereum_client::pallet::Error,
				),
				#[codec(index = 83)]
				EthereumSystem(runtime_types::snowbridge_pallet_system::pallet::Error),
				#[codec(index = 250)]
				MessageQueue(runtime_types::pallet_message_queue::pallet::Error),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeEvent {
				#[codec(index = 0)]
				System(runtime_types::frame_system::pallet::Event),
				#[codec(index = 1)]
				ParachainSystem(runtime_types::cumulus_pallet_parachain_system::pallet::Event),
				#[codec(index = 10)]
				Balances(runtime_types::pallet_balances::pallet::Event),
				#[codec(index = 11)]
				TransactionPayment(runtime_types::pallet_transaction_payment::pallet::Event),
				#[codec(index = 21)]
				CollatorSelection(runtime_types::pallet_collator_selection::pallet::Event),
				#[codec(index = 22)]
				Session(runtime_types::pallet_session::pallet::Event),
				#[codec(index = 30)]
				XcmpQueue(runtime_types::cumulus_pallet_xcmp_queue::pallet::Event),
				#[codec(index = 31)]
				PolkadotXcm(runtime_types::pallet_xcm::pallet::Event),
				#[codec(index = 32)]
				CumulusXcm(runtime_types::cumulus_pallet_xcm::pallet::Event),
				#[codec(index = 40)]
				Utility(runtime_types::pallet_utility::pallet::Event),
				#[codec(index = 36)]
				Multisig(runtime_types::pallet_multisig::pallet::Event),
				#[codec(index = 47)]
				BridgeRelayers(runtime_types::pallet_bridge_relayers::pallet::Event),
				#[codec(index = 48)]
				BridgeWestendGrandpa(runtime_types::pallet_bridge_grandpa::pallet::Event),
				#[codec(index = 49)]
				BridgeWestendParachains(runtime_types::pallet_bridge_parachains::pallet::Event),
				#[codec(index = 51)]
				BridgeWestendMessages(runtime_types::pallet_bridge_messages::pallet::Event),
				#[codec(index = 60)]
				BridgePolkadotBulletinGrandpa(runtime_types::pallet_bridge_grandpa::pallet::Event2),
				#[codec(index = 61)]
				BridgePolkadotBulletinMessages(
					runtime_types::pallet_bridge_messages::pallet::Event2,
				),
				#[codec(index = 80)]
				EthereumInboundQueue(runtime_types::snowbridge_pallet_inbound_queue::pallet::Event),
				#[codec(index = 81)]
				EthereumOutboundQueue(
					runtime_types::snowbridge_pallet_outbound_queue::pallet::Event,
				),
				#[codec(index = 82)]
				EthereumBeaconClient(
					runtime_types::snowbridge_pallet_ethereum_client::pallet::Event,
				),
				#[codec(index = 83)]
				EthereumSystem(runtime_types::snowbridge_pallet_system::pallet::Event),
				#[codec(index = 250)]
				MessageQueue(runtime_types::pallet_message_queue::pallet::Event),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeHoldReason {}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct SessionKeys {
				pub aura: runtime_types::sp_consensus_aura::sr25519::app_sr25519::Public,
			}
		}
		pub mod bridge_runtime_common {
			use super::runtime_types;
			pub mod messages_xcm_extension {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum XcmBlobMessageDispatchResult {
					#[codec(index = 0)]
					InvalidPayload,
					#[codec(index = 1)]
					Dispatched,
					#[codec(index = 2)]
					NotDispatched,
				}
			}
			pub mod refund_relayer_extension {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct RefundBridgedGrandpaMessages;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct RefundBridgedParachainMessages;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct RefundTransactionExtensionAdapter<_0>(pub _0);
			}
		}
		pub mod cumulus_pallet_parachain_system {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					# [codec (index = 0)] set_validation_data { data : runtime_types :: cumulus_primitives_parachain_inherent :: ParachainInherentData , } , # [codec (index = 1)] sudo_send_upward_message { message : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] authorize_upgrade { code_hash : :: subxt :: utils :: H256 , check_version : :: core :: primitive :: bool , } , # [codec (index = 3)] enact_authorized_upgrade { code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					OverlappingUpgrades,
					#[codec(index = 1)]
					ProhibitedByPolkadot,
					#[codec(index = 2)]
					TooBig,
					#[codec(index = 3)]
					ValidationDataNotAvailable,
					#[codec(index = 4)]
					HostConfigurationNotAvailable,
					#[codec(index = 5)]
					NotScheduled,
					#[codec(index = 6)]
					NothingAuthorized,
					#[codec(index = 7)]
					Unauthorized,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ValidationFunctionStored,
					#[codec(index = 1)]
					ValidationFunctionApplied { relay_chain_block_num: ::core::primitive::u32 },
					#[codec(index = 2)]
					ValidationFunctionDiscarded,
					#[codec(index = 3)]
					DownwardMessagesReceived { count: ::core::primitive::u32 },
					#[codec(index = 4)]
					DownwardMessagesProcessed {
						weight_used: ::sp_weights::Weight,
						dmq_head: ::subxt::utils::H256,
					},
					#[codec(index = 5)]
					UpwardMessageSent {
						message_hash: ::core::option::Option<[::core::primitive::u8; 32usize]>,
					},
				}
			}
			pub mod relay_state_snapshot {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct MessagingStateSnapshot { pub dmq_mqc_head : :: subxt :: utils :: H256 , pub relay_dispatch_queue_remaining_capacity : runtime_types :: cumulus_pallet_parachain_system :: relay_state_snapshot :: RelayDispatchQueueRemainingCapacity , pub ingress_channels : :: std :: vec :: Vec < (runtime_types :: polkadot_parachain_primitives :: primitives :: Id , runtime_types :: polkadot_primitives :: v6 :: AbridgedHrmpChannel ,) > , pub egress_channels : :: std :: vec :: Vec < (runtime_types :: polkadot_parachain_primitives :: primitives :: Id , runtime_types :: polkadot_primitives :: v6 :: AbridgedHrmpChannel ,) > , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct RelayDispatchQueueRemainingCapacity {
					pub remaining_count: ::core::primitive::u32,
					pub remaining_size: ::core::primitive::u32,
				}
			}
			pub mod unincluded_segment {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Ancestor < _0 > { pub used_bandwidth : runtime_types :: cumulus_pallet_parachain_system :: unincluded_segment :: UsedBandwidth , pub para_head_hash : :: core :: option :: Option < _0 > , pub consumed_go_ahead_signal : :: core :: option :: Option < runtime_types :: polkadot_primitives :: v6 :: UpgradeGoAhead > , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct HrmpChannelUpdate {
					pub msg_count: ::core::primitive::u32,
					pub total_bytes: ::core::primitive::u32,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct SegmentTracker < _0 > { pub used_bandwidth : runtime_types :: cumulus_pallet_parachain_system :: unincluded_segment :: UsedBandwidth , pub hrmp_watermark : :: core :: option :: Option < :: core :: primitive :: u32 > , pub consumed_go_ahead_signal : :: core :: option :: Option < runtime_types :: polkadot_primitives :: v6 :: UpgradeGoAhead > , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _0 > }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct UsedBandwidth { pub ump_msg_count : :: core :: primitive :: u32 , pub ump_total_bytes : :: core :: primitive :: u32 , pub hrmp_outgoing : :: subxt :: utils :: KeyedVec < runtime_types :: polkadot_parachain_primitives :: primitives :: Id , runtime_types :: cumulus_pallet_parachain_system :: unincluded_segment :: HrmpChannelUpdate > , }
			}
		}
		pub mod cumulus_pallet_xcm {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					InvalidFormat([::core::primitive::u8; 32usize]),
					#[codec(index = 1)]
					UnsupportedVersion([::core::primitive::u8; 32usize]),
					#[codec(index = 2)]
					ExecutedDownward(
						[::core::primitive::u8; 32usize],
						runtime_types::staging_xcm::v4::traits::Outcome,
					),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Origin {
					#[codec(index = 0)]
					Relay,
					#[codec(index = 1)]
					SiblingParachain(runtime_types::polkadot_parachain_primitives::primitives::Id),
				}
			}
		}
		pub mod cumulus_pallet_xcmp_queue {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 1)]
					suspend_xcm_execution,
					#[codec(index = 2)]
					resume_xcm_execution,
					#[codec(index = 3)]
					update_suspend_threshold { new: ::core::primitive::u32 },
					#[codec(index = 4)]
					update_drop_threshold { new: ::core::primitive::u32 },
					#[codec(index = 5)]
					update_resume_threshold { new: ::core::primitive::u32 },
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					BadQueueConfig,
					#[codec(index = 1)]
					AlreadySuspended,
					#[codec(index = 2)]
					AlreadyResumed,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					XcmpMessageSent { message_hash: [::core::primitive::u8; 32usize] },
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct OutboundChannelDetails {
				pub recipient: runtime_types::polkadot_parachain_primitives::primitives::Id,
				pub state: runtime_types::cumulus_pallet_xcmp_queue::OutboundState,
				pub signals_exist: ::core::primitive::bool,
				pub first_index: ::core::primitive::u16,
				pub last_index: ::core::primitive::u16,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum OutboundState {
				#[codec(index = 0)]
				Ok,
				#[codec(index = 1)]
				Suspended,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct QueueConfigData {
				pub suspend_threshold: ::core::primitive::u32,
				pub drop_threshold: ::core::primitive::u32,
				pub resume_threshold: ::core::primitive::u32,
			}
		}
		pub mod cumulus_primitives_parachain_inherent {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct MessageQueueChain(pub ::subxt::utils::H256);
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ParachainInherentData {
				pub validation_data:
					runtime_types::polkadot_primitives::v6::PersistedValidationData<
						::subxt::utils::H256,
						::core::primitive::u32,
					>,
				pub relay_chain_state: runtime_types::sp_trie::storage_proof::StorageProof,
				pub downward_messages: ::std::vec::Vec<
					runtime_types::polkadot_core_primitives::InboundDownwardMessage<
						::core::primitive::u32,
					>,
				>,
				pub horizontal_messages: ::subxt::utils::KeyedVec<
					runtime_types::polkadot_parachain_primitives::primitives::Id,
					::std::vec::Vec<
						runtime_types::polkadot_core_primitives::InboundHrmpMessage<
							::core::primitive::u32,
						>,
					>,
				>,
			}
		}
		pub mod finality_grandpa {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Commit<_0, _1, _2, _3> {
				pub target_hash: _0,
				pub target_number: _1,
				pub precommits: ::std::vec::Vec<
					runtime_types::finality_grandpa::SignedPrecommit<_0, _1, _2, _3>,
				>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Precommit<_0, _1> {
				pub target_hash: _0,
				pub target_number: _1,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct SignedPrecommit<_0, _1, _2, _3> {
				pub precommit: runtime_types::finality_grandpa::Precommit<_0, _1>,
				pub signature: _2,
				pub id: _3,
			}
		}
		pub mod frame_support {
			use super::runtime_types;
			pub mod dispatch {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum DispatchClass {
					#[codec(index = 0)]
					Normal,
					#[codec(index = 1)]
					Operational,
					#[codec(index = 2)]
					Mandatory,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct DispatchInfo {
					pub weight: ::sp_weights::Weight,
					pub class: runtime_types::frame_support::dispatch::DispatchClass,
					pub pays_fee: runtime_types::frame_support::dispatch::Pays,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Pays {
					#[codec(index = 0)]
					Yes,
					#[codec(index = 1)]
					No,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PerDispatchClass<_0> {
					pub normal: _0,
					pub operational: _0,
					pub mandatory: _0,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum RawOrigin<_0> {
					#[codec(index = 0)]
					Root,
					#[codec(index = 1)]
					Signed(_0),
					#[codec(index = 2)]
					None,
				}
			}
			pub mod traits {
				use super::runtime_types;
				pub mod messages {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum ProcessMessageError {
						#[codec(index = 0)]
						BadFormat,
						#[codec(index = 1)]
						Corrupt,
						#[codec(index = 2)]
						Unsupported,
						#[codec(index = 3)]
						Overweight(::sp_weights::Weight),
						#[codec(index = 4)]
						Yield,
					}
				}
				pub mod tokens {
					use super::runtime_types;
					pub mod misc {
						use super::runtime_types;
						#[derive(
							:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq,
						)]
						pub enum BalanceStatus {
							#[codec(index = 0)]
							Free,
							#[codec(index = 1)]
							Reserved,
						}
					}
				}
			}
		}
		pub mod frame_system {
			use super::runtime_types;
			pub mod extensions {
				use super::runtime_types;
				pub mod check_genesis {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckGenesis;
				}
				pub mod check_mortality {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckMortality(pub ::sp_runtime::generic::Era);
				}
				pub mod check_non_zero_sender {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckNonZeroSender;
				}
				pub mod check_nonce {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckNonce(#[codec(compact)] pub ::core::primitive::u32);
				}
				pub mod check_spec_version {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckSpecVersion;
				}
				pub mod check_tx_version {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckTxVersion;
				}
				pub mod check_weight {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckWeight;
				}
			}
			pub mod limits {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BlockLength {
					pub max: runtime_types::frame_support::dispatch::PerDispatchClass<
						::core::primitive::u32,
					>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BlockWeights {
					pub base_block: ::sp_weights::Weight,
					pub max_block: ::sp_weights::Weight,
					pub per_class: runtime_types::frame_support::dispatch::PerDispatchClass<
						runtime_types::frame_system::limits::WeightsPerClass,
					>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct WeightsPerClass {
					pub base_extrinsic: ::sp_weights::Weight,
					pub max_extrinsic: ::core::option::Option<::sp_weights::Weight>,
					pub max_total: ::core::option::Option<::sp_weights::Weight>,
					pub reserved: ::core::option::Option<::sp_weights::Weight>,
				}
			}
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					remark { remark: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 1)]
					set_heap_pages { pages: ::core::primitive::u64 },
					#[codec(index = 2)]
					set_code { code: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 3)]
					set_code_without_checks { code: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 4)]
					set_storage {
						items: ::std::vec::Vec<(
							::std::vec::Vec<::core::primitive::u8>,
							::std::vec::Vec<::core::primitive::u8>,
						)>,
					},
					#[codec(index = 5)]
					kill_storage { keys: ::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>> },
					#[codec(index = 6)]
					kill_prefix {
						prefix: ::std::vec::Vec<::core::primitive::u8>,
						subkeys: ::core::primitive::u32,
					},
					#[codec(index = 7)]
					remark_with_event { remark: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 9)]
					authorize_upgrade { code_hash: ::subxt::utils::H256 },
					#[codec(index = 10)]
					authorize_upgrade_without_checks { code_hash: ::subxt::utils::H256 },
					#[codec(index = 11)]
					apply_authorized_upgrade { code: ::std::vec::Vec<::core::primitive::u8> },
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidSpecName,
					#[codec(index = 1)]
					SpecVersionNeedsToIncrease,
					#[codec(index = 2)]
					FailedToExtractRuntimeVersion,
					#[codec(index = 3)]
					NonDefaultComposite,
					#[codec(index = 4)]
					NonZeroRefCount,
					#[codec(index = 5)]
					CallFiltered,
					#[codec(index = 6)]
					NothingAuthorized,
					#[codec(index = 7)]
					Unauthorized,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ExtrinsicSuccess {
						dispatch_info: runtime_types::frame_support::dispatch::DispatchInfo,
					},
					#[codec(index = 1)]
					ExtrinsicFailed {
						dispatch_error: runtime_types::sp_runtime::DispatchError,
						dispatch_info: runtime_types::frame_support::dispatch::DispatchInfo,
					},
					#[codec(index = 2)]
					CodeUpdated,
					#[codec(index = 3)]
					NewAccount { account: ::sp_core::crypto::AccountId32 },
					#[codec(index = 4)]
					KilledAccount { account: ::sp_core::crypto::AccountId32 },
					#[codec(index = 5)]
					Remarked { sender: ::sp_core::crypto::AccountId32, hash: ::subxt::utils::H256 },
					#[codec(index = 6)]
					UpgradeAuthorized {
						code_hash: ::subxt::utils::H256,
						check_version: ::core::primitive::bool,
					},
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct AccountInfo<_0, _1> {
				pub nonce: _0,
				pub consumers: ::core::primitive::u32,
				pub providers: ::core::primitive::u32,
				pub sufficients: ::core::primitive::u32,
				pub data: _1,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct CodeUpgradeAuthorization {
				pub code_hash: ::subxt::utils::H256,
				pub check_version: ::core::primitive::bool,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct EventRecord<_0, _1> {
				pub phase: runtime_types::frame_system::Phase,
				pub event: _0,
				pub topics: ::std::vec::Vec<_1>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct LastRuntimeUpgradeInfo {
				#[codec(compact)]
				pub spec_version: ::core::primitive::u32,
				pub spec_name: ::std::string::String,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Phase {
				#[codec(index = 0)]
				ApplyExtrinsic(::core::primitive::u32),
				#[codec(index = 1)]
				Finalization,
				#[codec(index = 2)]
				Initialization,
			}
		}
		pub mod pallet_balances {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					transfer_allow_death {
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						value: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					force_transfer {
						source: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						value: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					transfer_keep_alive {
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						value: ::core::primitive::u128,
					},
					#[codec(index = 4)]
					transfer_all {
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						keep_alive: ::core::primitive::bool,
					},
					#[codec(index = 5)]
					force_unreserve {
						who: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 6)]
					upgrade_accounts { who: ::std::vec::Vec<::sp_core::crypto::AccountId32> },
					#[codec(index = 8)]
					force_set_balance {
						who: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						new_free: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					force_adjust_total_issuance {
						direction: runtime_types::pallet_balances::types::AdjustmentDirection,
						#[codec(compact)]
						delta: ::core::primitive::u128,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					VestingBalance,
					#[codec(index = 1)]
					LiquidityRestrictions,
					#[codec(index = 2)]
					InsufficientBalance,
					#[codec(index = 3)]
					ExistentialDeposit,
					#[codec(index = 4)]
					Expendability,
					#[codec(index = 5)]
					ExistingVestingSchedule,
					#[codec(index = 6)]
					DeadAccount,
					#[codec(index = 7)]
					TooManyReserves,
					#[codec(index = 8)]
					TooManyHolds,
					#[codec(index = 9)]
					TooManyFreezes,
					#[codec(index = 10)]
					IssuanceDeactivated,
					#[codec(index = 11)]
					DeltaZero,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Endowed {
						account: ::sp_core::crypto::AccountId32,
						free_balance: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					DustLost {
						account: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					Transfer {
						from: ::sp_core::crypto::AccountId32,
						to: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					BalanceSet {
						who: ::sp_core::crypto::AccountId32,
						free: ::core::primitive::u128,
					},
					#[codec(index = 4)]
					Reserved {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 5)]
					Unreserved {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 6)]
					ReserveRepatriated {
						from: ::sp_core::crypto::AccountId32,
						to: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
						destination_status:
							runtime_types::frame_support::traits::tokens::misc::BalanceStatus,
					},
					#[codec(index = 7)]
					Deposit { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 8)]
					Withdraw {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					Slashed { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 10)]
					Minted { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 11)]
					Burned { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 12)]
					Suspended {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 13)]
					Restored {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 14)]
					Upgraded { who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 15)]
					Issued { amount: ::core::primitive::u128 },
					#[codec(index = 16)]
					Rescinded { amount: ::core::primitive::u128 },
					#[codec(index = 17)]
					Locked { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 18)]
					Unlocked {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 19)]
					Frozen { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 20)]
					Thawed { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 21)]
					TotalIssuanceForced {
						old: ::core::primitive::u128,
						new: ::core::primitive::u128,
					},
				}
			}
			pub mod types {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct AccountData<_0> {
					pub free: _0,
					pub reserved: _0,
					pub frozen: _0,
					pub flags: runtime_types::pallet_balances::types::ExtraFlags,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum AdjustmentDirection {
					#[codec(index = 0)]
					Increase,
					#[codec(index = 1)]
					Decrease,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BalanceLock<_0> {
					pub id: [::core::primitive::u8; 8usize],
					pub amount: _0,
					pub reasons: runtime_types::pallet_balances::types::Reasons,
				}
				#[derive(
					:: codec :: Decode,
					:: codec :: Encode,
					:: subxt :: ext :: codec :: CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct ExtraFlags(pub ::core::primitive::u128);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct IdAmount<_0, _1> {
					pub id: _0,
					pub amount: _1,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Reasons {
					#[codec(index = 0)]
					Fee,
					#[codec(index = 1)]
					Misc,
					#[codec(index = 2)]
					All,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct ReserveData<_0, _1> {
					pub id: _0,
					pub amount: _1,
				}
			}
		}
		pub mod pallet_bridge_grandpa {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					submit_finality_proof {
						finality_target: ::std::boxed::Box<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
						justification: ::bp_header_chain::justification::GrandpaJustification<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
					},
					#[codec(index = 1)]
					initialize {
						init_data: ::bp_header_chain::InitializationData<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
					},
					#[codec(index = 2)]
					set_owner { new_owner: ::core::option::Option<::sp_core::crypto::AccountId32> },
					#[codec(index = 3)]
					set_operating_mode {
						operating_mode: runtime_types::bp_runtime::BasicOperatingMode,
					},
					#[codec(index = 4)]
					submit_finality_proof_ex {
						finality_target: ::std::boxed::Box<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
						justification: ::bp_header_chain::justification::GrandpaJustification<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
						current_set_id: ::core::primitive::u64,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call2 {
					#[codec(index = 0)]
					submit_finality_proof {
						finality_target: ::std::boxed::Box<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
						justification: ::bp_header_chain::justification::GrandpaJustification<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
					},
					#[codec(index = 1)]
					initialize {
						init_data: ::bp_header_chain::InitializationData<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
					},
					#[codec(index = 2)]
					set_owner { new_owner: ::core::option::Option<::sp_core::crypto::AccountId32> },
					#[codec(index = 3)]
					set_operating_mode {
						operating_mode: runtime_types::bp_runtime::BasicOperatingMode,
					},
					#[codec(index = 4)]
					submit_finality_proof_ex {
						finality_target: ::std::boxed::Box<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
						justification: ::bp_header_chain::justification::GrandpaJustification<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
						current_set_id: ::core::primitive::u64,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidJustification,
					#[codec(index = 1)]
					InvalidAuthoritySet,
					#[codec(index = 2)]
					OldHeader,
					#[codec(index = 3)]
					UnsupportedScheduledChange,
					#[codec(index = 4)]
					NotInitialized,
					#[codec(index = 5)]
					AlreadyInitialized,
					#[codec(index = 6)]
					TooManyAuthoritiesInSet,
					#[codec(index = 7)]
					BridgeModule(runtime_types::bp_runtime::OwnedBridgeModuleError),
					#[codec(index = 8)]
					InvalidAuthoritySetId,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error2 {
					#[codec(index = 0)]
					InvalidJustification,
					#[codec(index = 1)]
					InvalidAuthoritySet,
					#[codec(index = 2)]
					OldHeader,
					#[codec(index = 3)]
					UnsupportedScheduledChange,
					#[codec(index = 4)]
					NotInitialized,
					#[codec(index = 5)]
					AlreadyInitialized,
					#[codec(index = 6)]
					TooManyAuthoritiesInSet,
					#[codec(index = 7)]
					BridgeModule(runtime_types::bp_runtime::OwnedBridgeModuleError),
					#[codec(index = 8)]
					InvalidAuthoritySetId,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					UpdatedBestFinalizedHeader {
						number: ::core::primitive::u32,
						hash: ::subxt::utils::H256,
						grandpa_info: runtime_types::bp_header_chain::HeaderFinalityInfo<
							::bp_header_chain::justification::GrandpaJustification<
								::sp_runtime::generic::Header<
									::core::primitive::u32,
									::sp_runtime::traits::BlakeTwo256,
								>,
							>,
							runtime_types::bp_header_chain::AuthoritySet,
						>,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event2 {
					#[codec(index = 0)]
					UpdatedBestFinalizedHeader {
						number: ::core::primitive::u32,
						hash: ::subxt::utils::H256,
						grandpa_info: runtime_types::bp_header_chain::HeaderFinalityInfo<
							::bp_header_chain::justification::GrandpaJustification<
								::sp_runtime::generic::Header<
									::core::primitive::u32,
									::sp_runtime::traits::BlakeTwo256,
								>,
							>,
							runtime_types::bp_header_chain::AuthoritySet,
						>,
					},
				}
			}
			pub mod storage_types {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct StoredAuthoritySet {
					pub authorities: runtime_types::bounded_collections::bounded_vec::BoundedVec<(
						runtime_types::sp_consensus_grandpa::app::Public,
						::core::primitive::u64,
					)>,
					pub set_id: ::core::primitive::u64,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct StoredAuthoritySet2 {
					pub authorities: runtime_types::bounded_collections::bounded_vec::BoundedVec<(
						runtime_types::sp_consensus_grandpa::app::Public,
						::core::primitive::u64,
					)>,
					pub set_id: ::core::primitive::u64,
				}
			}
		}
		pub mod pallet_bridge_messages {
			use super::runtime_types;
			pub mod outbound_lane {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum ReceivalConfirmationError {
					#[codec(index = 0)]
					FailedToConfirmFutureMessages,
					#[codec(index = 1)]
					EmptyUnrewardedRelayerEntry,
					#[codec(index = 2)]
					NonConsecutiveUnrewardedRelayerEntries,
					#[codec(index = 3)]
					TryingToConfirmMoreMessagesThanExpected,
				}
			}
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					# [codec (index = 0)] set_owner { new_owner : :: core :: option :: Option < :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 1)] set_operating_mode { operating_mode : runtime_types :: bp_messages :: MessagesOperatingMode , } , # [codec (index = 2)] receive_messages_proof { relayer_id_at_bridged_chain : :: sp_core :: crypto :: AccountId32 , proof : :: bridge_runtime_common :: messages :: target :: FromBridgedChainMessagesProof < :: subxt :: utils :: H256 > , messages_count : :: core :: primitive :: u32 , dispatch_weight : :: sp_weights :: Weight , } , # [codec (index = 3)] receive_messages_delivery_proof { proof : :: bridge_runtime_common :: messages :: source :: FromBridgedChainMessagesDeliveryProof < :: subxt :: utils :: H256 > , relayers_state : :: bp_messages :: UnrewardedRelayersState , } , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call2 {
					# [codec (index = 0)] set_owner { new_owner : :: core :: option :: Option < :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 1)] set_operating_mode { operating_mode : runtime_types :: bp_messages :: MessagesOperatingMode , } , # [codec (index = 2)] receive_messages_proof { relayer_id_at_bridged_chain : :: sp_core :: crypto :: AccountId32 , proof : :: bridge_runtime_common :: messages :: target :: FromBridgedChainMessagesProof < :: subxt :: utils :: H256 > , messages_count : :: core :: primitive :: u32 , dispatch_weight : :: sp_weights :: Weight , } , # [codec (index = 3)] receive_messages_delivery_proof { proof : :: bridge_runtime_common :: messages :: source :: FromBridgedChainMessagesDeliveryProof < :: subxt :: utils :: H256 > , relayers_state : :: bp_messages :: UnrewardedRelayersState , } , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					# [codec (index = 0)] NotOperatingNormally , # [codec (index = 1)] InactiveOutboundLane , # [codec (index = 2)] MessageDispatchInactive , # [codec (index = 3)] MessageRejectedByChainVerifier (runtime_types :: bp_messages :: VerificationError ,) , # [codec (index = 4)] MessageRejectedByPallet (runtime_types :: bp_messages :: VerificationError ,) , # [codec (index = 5)] FailedToWithdrawMessageFee , # [codec (index = 6)] TooManyMessagesInTheProof , # [codec (index = 7)] InvalidMessagesProof , # [codec (index = 8)] InvalidMessagesDeliveryProof , # [codec (index = 9)] InvalidUnrewardedRelayersState , # [codec (index = 10)] InsufficientDispatchWeight , # [codec (index = 11)] MessageIsNotYetSent , # [codec (index = 12)] ReceivalConfirmation (runtime_types :: pallet_bridge_messages :: outbound_lane :: ReceivalConfirmationError ,) , # [codec (index = 13)] BridgeModule (runtime_types :: bp_runtime :: OwnedBridgeModuleError ,) , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error2 {
					# [codec (index = 0)] NotOperatingNormally , # [codec (index = 1)] InactiveOutboundLane , # [codec (index = 2)] MessageDispatchInactive , # [codec (index = 3)] MessageRejectedByChainVerifier (runtime_types :: bp_messages :: VerificationError ,) , # [codec (index = 4)] MessageRejectedByPallet (runtime_types :: bp_messages :: VerificationError ,) , # [codec (index = 5)] FailedToWithdrawMessageFee , # [codec (index = 6)] TooManyMessagesInTheProof , # [codec (index = 7)] InvalidMessagesProof , # [codec (index = 8)] InvalidMessagesDeliveryProof , # [codec (index = 9)] InvalidUnrewardedRelayersState , # [codec (index = 10)] InsufficientDispatchWeight , # [codec (index = 11)] MessageIsNotYetSent , # [codec (index = 12)] ReceivalConfirmation (runtime_types :: pallet_bridge_messages :: outbound_lane :: ReceivalConfirmationError ,) , # [codec (index = 13)] BridgeModule (runtime_types :: bp_runtime :: OwnedBridgeModuleError ,) , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					# [codec (index = 0)] MessageAccepted { lane_id : runtime_types :: bp_messages :: LaneId , nonce : :: core :: primitive :: u64 , } , # [codec (index = 1)] MessagesReceived (:: std :: vec :: Vec < runtime_types :: bp_messages :: ReceivedMessages < runtime_types :: bridge_runtime_common :: messages_xcm_extension :: XcmBlobMessageDispatchResult > > ,) , # [codec (index = 2)] MessagesDelivered { lane_id : runtime_types :: bp_messages :: LaneId , messages : runtime_types :: bp_messages :: DeliveredMessages , } , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event2 {
					# [codec (index = 0)] MessageAccepted { lane_id : runtime_types :: bp_messages :: LaneId , nonce : :: core :: primitive :: u64 , } , # [codec (index = 1)] MessagesReceived (:: std :: vec :: Vec < runtime_types :: bp_messages :: ReceivedMessages < runtime_types :: bridge_runtime_common :: messages_xcm_extension :: XcmBlobMessageDispatchResult > > ,) , # [codec (index = 2)] MessagesDelivered { lane_id : runtime_types :: bp_messages :: LaneId , messages : runtime_types :: bp_messages :: DeliveredMessages , } , }
			}
		}
		pub mod pallet_bridge_parachains {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					submit_parachain_heads {
						at_relay_block: (::core::primitive::u32, ::subxt::utils::H256),
						parachains: ::std::vec::Vec<(
							::bp_polkadot_core::parachains::ParaId,
							::subxt::utils::H256,
						)>,
						parachain_heads_proof: ::bp_polkadot_core::parachains::ParaHeadsProof,
					},
					#[codec(index = 1)]
					set_owner { new_owner: ::core::option::Option<::sp_core::crypto::AccountId32> },
					#[codec(index = 2)]
					set_operating_mode {
						operating_mode: runtime_types::bp_runtime::BasicOperatingMode,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					UnknownRelayChainBlock,
					#[codec(index = 1)]
					InvalidRelayChainBlockNumber,
					#[codec(index = 2)]
					HeaderChainStorageProof(runtime_types::bp_header_chain::HeaderChainError),
					#[codec(index = 3)]
					BridgeModule(runtime_types::bp_runtime::OwnedBridgeModuleError),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					UntrackedParachainRejected { parachain: ::bp_polkadot_core::parachains::ParaId },
					#[codec(index = 1)]
					MissingParachainHead { parachain: ::bp_polkadot_core::parachains::ParaId },
					#[codec(index = 2)]
					IncorrectParachainHeadHash {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
						actual_parachain_head_hash: ::subxt::utils::H256,
					},
					#[codec(index = 3)]
					RejectedObsoleteParachainHead {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
					},
					#[codec(index = 4)]
					RejectedLargeParachainHead {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
						parachain_head_size: ::core::primitive::u32,
					},
					#[codec(index = 5)]
					UpdatedParachainHead {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
					},
				}
			}
		}
		pub mod pallet_bridge_relayers {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					claim_rewards {
						rewards_account_params: runtime_types::bp_relayers::RewardsAccountParams,
					},
					#[codec(index = 1)]
					register { valid_till: ::core::primitive::u32 },
					#[codec(index = 2)]
					deregister,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					NoRewardForRelayer,
					#[codec(index = 1)]
					FailedToPayReward,
					#[codec(index = 2)]
					InvalidRegistrationLease,
					#[codec(index = 3)]
					CannotReduceRegistrationLease,
					#[codec(index = 4)]
					FailedToReserve,
					#[codec(index = 5)]
					FailedToUnreserve,
					#[codec(index = 6)]
					NotRegistered,
					#[codec(index = 7)]
					RegistrationIsStillActive,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					RewardRegistered {
						relayer: ::sp_core::crypto::AccountId32,
						rewards_account_params: runtime_types::bp_relayers::RewardsAccountParams,
						reward: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					RewardPaid {
						relayer: ::sp_core::crypto::AccountId32,
						rewards_account_params: runtime_types::bp_relayers::RewardsAccountParams,
						reward: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					RegistrationUpdated {
						relayer: ::sp_core::crypto::AccountId32,
						registration: runtime_types::bp_relayers::registration::Registration<
							::core::primitive::u32,
							::core::primitive::u128,
						>,
					},
					#[codec(index = 3)]
					Deregistered { relayer: ::sp_core::crypto::AccountId32 },
					#[codec(index = 4)]
					SlashedAndDeregistered {
						relayer: ::sp_core::crypto::AccountId32,
						registration: runtime_types::bp_relayers::registration::Registration<
							::core::primitive::u32,
							::core::primitive::u128,
						>,
					},
				}
			}
		}
		pub mod pallet_collator_selection {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set_invulnerables { new: ::std::vec::Vec<::sp_core::crypto::AccountId32> },
					#[codec(index = 1)]
					set_desired_candidates { max: ::core::primitive::u32 },
					#[codec(index = 2)]
					set_candidacy_bond { bond: ::core::primitive::u128 },
					#[codec(index = 3)]
					register_as_candidate,
					#[codec(index = 4)]
					leave_intent,
					#[codec(index = 5)]
					add_invulnerable { who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 6)]
					remove_invulnerable { who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 7)]
					update_bond { new_deposit: ::core::primitive::u128 },
					#[codec(index = 8)]
					take_candidate_slot {
						deposit: ::core::primitive::u128,
						target: ::sp_core::crypto::AccountId32,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct CandidateInfo<_0, _1> {
					pub who: _0,
					pub deposit: _1,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					TooManyCandidates,
					#[codec(index = 1)]
					TooFewEligibleCollators,
					#[codec(index = 2)]
					AlreadyCandidate,
					#[codec(index = 3)]
					NotCandidate,
					#[codec(index = 4)]
					TooManyInvulnerables,
					#[codec(index = 5)]
					AlreadyInvulnerable,
					#[codec(index = 6)]
					NotInvulnerable,
					#[codec(index = 7)]
					NoAssociatedValidatorId,
					#[codec(index = 8)]
					ValidatorNotRegistered,
					#[codec(index = 9)]
					InsertToCandidateListFailed,
					#[codec(index = 10)]
					RemoveFromCandidateListFailed,
					#[codec(index = 11)]
					DepositTooLow,
					#[codec(index = 12)]
					UpdateCandidateListFailed,
					#[codec(index = 13)]
					InsufficientBond,
					#[codec(index = 14)]
					TargetIsNotCandidate,
					#[codec(index = 15)]
					IdenticalDeposit,
					#[codec(index = 16)]
					InvalidUnreserve,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NewInvulnerables {
						invulnerables: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 1)]
					InvulnerableAdded { account_id: ::sp_core::crypto::AccountId32 },
					#[codec(index = 2)]
					InvulnerableRemoved { account_id: ::sp_core::crypto::AccountId32 },
					#[codec(index = 3)]
					NewDesiredCandidates { desired_candidates: ::core::primitive::u32 },
					#[codec(index = 4)]
					NewCandidacyBond { bond_amount: ::core::primitive::u128 },
					#[codec(index = 5)]
					CandidateAdded {
						account_id: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
					#[codec(index = 6)]
					CandidateBondUpdated {
						account_id: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
					#[codec(index = 7)]
					CandidateRemoved { account_id: ::sp_core::crypto::AccountId32 },
					#[codec(index = 8)]
					CandidateReplaced {
						old: ::sp_core::crypto::AccountId32,
						new: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					InvalidInvulnerableSkipped { account_id: ::sp_core::crypto::AccountId32 },
				}
			}
		}
		pub mod pallet_message_queue {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					reap_page {
						message_origin:
							runtime_types::bridge_hub_common::message_queue::AggregateMessageOrigin,
						page_index: ::core::primitive::u32,
					},
					#[codec(index = 1)]
					execute_overweight {
						message_origin:
							runtime_types::bridge_hub_common::message_queue::AggregateMessageOrigin,
						page: ::core::primitive::u32,
						index: ::core::primitive::u32,
						weight_limit: ::sp_weights::Weight,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					NotReapable,
					#[codec(index = 1)]
					NoPage,
					#[codec(index = 2)]
					NoMessage,
					#[codec(index = 3)]
					AlreadyProcessed,
					#[codec(index = 4)]
					Queued,
					#[codec(index = 5)]
					InsufficientWeight,
					#[codec(index = 6)]
					TemporarilyUnprocessable,
					#[codec(index = 7)]
					QueuePaused,
					#[codec(index = 8)]
					RecursiveDisallowed,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ProcessingFailed {
						id: ::subxt::utils::H256,
						origin:
							runtime_types::bridge_hub_common::message_queue::AggregateMessageOrigin,
						error: runtime_types::frame_support::traits::messages::ProcessMessageError,
					},
					#[codec(index = 1)]
					Processed {
						id: ::subxt::utils::H256,
						origin:
							runtime_types::bridge_hub_common::message_queue::AggregateMessageOrigin,
						weight_used: ::sp_weights::Weight,
						success: ::core::primitive::bool,
					},
					#[codec(index = 2)]
					OverweightEnqueued {
						id: [::core::primitive::u8; 32usize],
						origin:
							runtime_types::bridge_hub_common::message_queue::AggregateMessageOrigin,
						page_index: ::core::primitive::u32,
						message_index: ::core::primitive::u32,
					},
					#[codec(index = 3)]
					PageReaped {
						origin:
							runtime_types::bridge_hub_common::message_queue::AggregateMessageOrigin,
						index: ::core::primitive::u32,
					},
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct BookState<_0> {
				pub begin: ::core::primitive::u32,
				pub end: ::core::primitive::u32,
				pub count: ::core::primitive::u32,
				pub ready_neighbours:
					::core::option::Option<runtime_types::pallet_message_queue::Neighbours<_0>>,
				pub message_count: ::core::primitive::u64,
				pub size: ::core::primitive::u64,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Neighbours<_0> {
				pub prev: _0,
				pub next: _0,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Page<_0> {
				pub remaining: _0,
				pub remaining_size: _0,
				pub first_index: _0,
				pub first: _0,
				pub last: _0,
				pub heap: runtime_types::bounded_collections::bounded_vec::BoundedVec<
					::core::primitive::u8,
				>,
			}
		}
		pub mod pallet_multisig {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					as_multi_threshold_1 {
						other_signatories: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
						call: ::std::boxed::Box<
							runtime_types::bridge_hub_rococo_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 1)]
					as_multi {
						threshold: ::core::primitive::u16,
						other_signatories: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
						maybe_timepoint: ::core::option::Option<
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						>,
						call: ::std::boxed::Box<
							runtime_types::bridge_hub_rococo_runtime::RuntimeCall,
						>,
						max_weight: ::sp_weights::Weight,
					},
					#[codec(index = 2)]
					approve_as_multi {
						threshold: ::core::primitive::u16,
						other_signatories: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
						maybe_timepoint: ::core::option::Option<
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						>,
						call_hash: [::core::primitive::u8; 32usize],
						max_weight: ::sp_weights::Weight,
					},
					#[codec(index = 3)]
					cancel_as_multi {
						threshold: ::core::primitive::u16,
						other_signatories: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						call_hash: [::core::primitive::u8; 32usize],
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					MinimumThreshold,
					#[codec(index = 1)]
					AlreadyApproved,
					#[codec(index = 2)]
					NoApprovalsNeeded,
					#[codec(index = 3)]
					TooFewSignatories,
					#[codec(index = 4)]
					TooManySignatories,
					#[codec(index = 5)]
					SignatoriesOutOfOrder,
					#[codec(index = 6)]
					SenderInSignatories,
					#[codec(index = 7)]
					NotFound,
					#[codec(index = 8)]
					NotOwner,
					#[codec(index = 9)]
					NoTimepoint,
					#[codec(index = 10)]
					WrongTimepoint,
					#[codec(index = 11)]
					UnexpectedTimepoint,
					#[codec(index = 12)]
					MaxWeightTooLow,
					#[codec(index = 13)]
					AlreadyStored,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NewMultisig {
						approving: ::sp_core::crypto::AccountId32,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 1)]
					MultisigApproval {
						approving: ::sp_core::crypto::AccountId32,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 2)]
					MultisigExecuted {
						approving: ::sp_core::crypto::AccountId32,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
						result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
					#[codec(index = 3)]
					MultisigCancelled {
						cancelling: ::sp_core::crypto::AccountId32,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
					},
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Multisig<_0, _1, _2> {
				pub when: runtime_types::pallet_multisig::Timepoint<_0>,
				pub deposit: _1,
				pub depositor: _2,
				pub approvals: runtime_types::bounded_collections::bounded_vec::BoundedVec<_2>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Timepoint<_0> {
				pub height: _0,
				pub index: ::core::primitive::u32,
			}
		}
		pub mod pallet_session {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set_keys {
						keys: runtime_types::bridge_hub_rococo_runtime::SessionKeys,
						proof: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 1)]
					purge_keys,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidProof,
					#[codec(index = 1)]
					NoAssociatedValidatorId,
					#[codec(index = 2)]
					DuplicatedKey,
					#[codec(index = 3)]
					NoKeys,
					#[codec(index = 4)]
					NoAccount,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NewSession { session_index: ::core::primitive::u32 },
				}
			}
		}
		pub mod pallet_timestamp {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set {
						#[codec(compact)]
						now: ::core::primitive::u64,
					},
				}
			}
		}
		pub mod pallet_transaction_payment {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					TransactionFeePaid {
						who: ::sp_core::crypto::AccountId32,
						actual_fee: ::core::primitive::u128,
						tip: ::core::primitive::u128,
					},
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ChargeTransactionPayment(#[codec(compact)] pub ::core::primitive::u128);
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Releases {
				#[codec(index = 0)]
				V1Ancient,
				#[codec(index = 1)]
				V2,
			}
		}
		pub mod pallet_utility {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					batch {
						calls:
							::std::vec::Vec<runtime_types::bridge_hub_rococo_runtime::RuntimeCall>,
					},
					#[codec(index = 1)]
					as_derivative {
						index: ::core::primitive::u16,
						call: ::std::boxed::Box<
							runtime_types::bridge_hub_rococo_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 2)]
					batch_all {
						calls:
							::std::vec::Vec<runtime_types::bridge_hub_rococo_runtime::RuntimeCall>,
					},
					#[codec(index = 3)]
					dispatch_as {
						as_origin: ::std::boxed::Box<
							runtime_types::bridge_hub_rococo_runtime::OriginCaller,
						>,
						call: ::std::boxed::Box<
							runtime_types::bridge_hub_rococo_runtime::RuntimeCall,
						>,
					},
					#[codec(index = 4)]
					force_batch {
						calls:
							::std::vec::Vec<runtime_types::bridge_hub_rococo_runtime::RuntimeCall>,
					},
					#[codec(index = 5)]
					with_weight {
						call: ::std::boxed::Box<
							runtime_types::bridge_hub_rococo_runtime::RuntimeCall,
						>,
						weight: ::sp_weights::Weight,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					TooManyCalls,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					BatchInterrupted {
						index: ::core::primitive::u32,
						error: runtime_types::sp_runtime::DispatchError,
					},
					#[codec(index = 1)]
					BatchCompleted,
					#[codec(index = 2)]
					BatchCompletedWithErrors,
					#[codec(index = 3)]
					ItemCompleted,
					#[codec(index = 4)]
					ItemFailed { error: runtime_types::sp_runtime::DispatchError },
					#[codec(index = 5)]
					DispatchedAs {
						result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
				}
			}
		}
		pub mod pallet_xcm {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					send {
						dest: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						message: ::std::boxed::Box<runtime_types::xcm::VersionedXcm>,
					},
					#[codec(index = 1)]
					teleport_assets {
						dest: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						beneficiary: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						assets: ::std::boxed::Box<runtime_types::xcm::VersionedAssets>,
						fee_asset_item: ::core::primitive::u32,
					},
					#[codec(index = 2)]
					reserve_transfer_assets {
						dest: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						beneficiary: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						assets: ::std::boxed::Box<runtime_types::xcm::VersionedAssets>,
						fee_asset_item: ::core::primitive::u32,
					},
					#[codec(index = 3)]
					execute {
						message: ::std::boxed::Box<runtime_types::xcm::VersionedXcm2>,
						max_weight: ::sp_weights::Weight,
					},
					#[codec(index = 4)]
					force_xcm_version {
						location:
							::std::boxed::Box<runtime_types::staging_xcm::v4::location::Location>,
						version: ::core::primitive::u32,
					},
					#[codec(index = 5)]
					force_default_xcm_version {
						maybe_xcm_version: ::core::option::Option<::core::primitive::u32>,
					},
					#[codec(index = 6)]
					force_subscribe_version_notify {
						location: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
					},
					#[codec(index = 7)]
					force_unsubscribe_version_notify {
						location: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
					},
					#[codec(index = 8)]
					limited_reserve_transfer_assets {
						dest: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						beneficiary: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						assets: ::std::boxed::Box<runtime_types::xcm::VersionedAssets>,
						fee_asset_item: ::core::primitive::u32,
						weight_limit: runtime_types::xcm::v3::WeightLimit,
					},
					#[codec(index = 9)]
					limited_teleport_assets {
						dest: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						beneficiary: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						assets: ::std::boxed::Box<runtime_types::xcm::VersionedAssets>,
						fee_asset_item: ::core::primitive::u32,
						weight_limit: runtime_types::xcm::v3::WeightLimit,
					},
					#[codec(index = 10)]
					force_suspension { suspended: ::core::primitive::bool },
					#[codec(index = 11)]
					transfer_assets {
						dest: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						beneficiary: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						assets: ::std::boxed::Box<runtime_types::xcm::VersionedAssets>,
						fee_asset_item: ::core::primitive::u32,
						weight_limit: runtime_types::xcm::v3::WeightLimit,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					Unreachable,
					#[codec(index = 1)]
					SendFailure,
					#[codec(index = 2)]
					Filtered,
					#[codec(index = 3)]
					UnweighableMessage,
					#[codec(index = 4)]
					DestinationNotInvertible,
					#[codec(index = 5)]
					Empty,
					#[codec(index = 6)]
					CannotReanchor,
					#[codec(index = 7)]
					TooManyAssets,
					#[codec(index = 8)]
					InvalidOrigin,
					#[codec(index = 9)]
					BadVersion,
					#[codec(index = 10)]
					BadLocation,
					#[codec(index = 11)]
					NoSubscription,
					#[codec(index = 12)]
					AlreadySubscribed,
					#[codec(index = 13)]
					CannotCheckOutTeleport,
					#[codec(index = 14)]
					LowBalance,
					#[codec(index = 15)]
					TooManyLocks,
					#[codec(index = 16)]
					AccountNotSovereign,
					#[codec(index = 17)]
					FeesNotMet,
					#[codec(index = 18)]
					LockNotFound,
					#[codec(index = 19)]
					InUse,
					#[codec(index = 20)]
					InvalidAssetNotConcrete,
					#[codec(index = 21)]
					InvalidAssetUnknownReserve,
					#[codec(index = 22)]
					InvalidAssetUnsupportedReserve,
					#[codec(index = 23)]
					TooManyReserves,
					#[codec(index = 24)]
					LocalExecutionIncomplete,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Attempted { outcome: runtime_types::staging_xcm::v4::traits::Outcome },
					#[codec(index = 1)]
					Sent {
						origin: runtime_types::staging_xcm::v4::location::Location,
						destination: runtime_types::staging_xcm::v4::location::Location,
						message: runtime_types::staging_xcm::v4::Xcm,
						message_id: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 2)]
					UnexpectedResponse {
						origin: runtime_types::staging_xcm::v4::location::Location,
						query_id: ::core::primitive::u64,
					},
					#[codec(index = 3)]
					ResponseReady {
						query_id: ::core::primitive::u64,
						response: runtime_types::staging_xcm::v4::Response,
					},
					#[codec(index = 4)]
					Notified {
						query_id: ::core::primitive::u64,
						pallet_index: ::core::primitive::u8,
						call_index: ::core::primitive::u8,
					},
					#[codec(index = 5)]
					NotifyOverweight {
						query_id: ::core::primitive::u64,
						pallet_index: ::core::primitive::u8,
						call_index: ::core::primitive::u8,
						actual_weight: ::sp_weights::Weight,
						max_budgeted_weight: ::sp_weights::Weight,
					},
					#[codec(index = 6)]
					NotifyDispatchError {
						query_id: ::core::primitive::u64,
						pallet_index: ::core::primitive::u8,
						call_index: ::core::primitive::u8,
					},
					#[codec(index = 7)]
					NotifyDecodeFailed {
						query_id: ::core::primitive::u64,
						pallet_index: ::core::primitive::u8,
						call_index: ::core::primitive::u8,
					},
					#[codec(index = 8)]
					InvalidResponder {
						origin: runtime_types::staging_xcm::v4::location::Location,
						query_id: ::core::primitive::u64,
						expected_location: ::core::option::Option<
							runtime_types::staging_xcm::v4::location::Location,
						>,
					},
					#[codec(index = 9)]
					InvalidResponderVersion {
						origin: runtime_types::staging_xcm::v4::location::Location,
						query_id: ::core::primitive::u64,
					},
					#[codec(index = 10)]
					ResponseTaken { query_id: ::core::primitive::u64 },
					#[codec(index = 11)]
					AssetsTrapped {
						hash: ::subxt::utils::H256,
						origin: runtime_types::staging_xcm::v4::location::Location,
						assets: runtime_types::xcm::VersionedAssets,
					},
					#[codec(index = 12)]
					VersionChangeNotified {
						destination: runtime_types::staging_xcm::v4::location::Location,
						result: ::core::primitive::u32,
						cost: runtime_types::staging_xcm::v4::asset::Assets,
						message_id: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 13)]
					SupportedVersionChanged {
						location: runtime_types::staging_xcm::v4::location::Location,
						version: ::core::primitive::u32,
					},
					#[codec(index = 14)]
					NotifyTargetSendFail {
						location: runtime_types::staging_xcm::v4::location::Location,
						query_id: ::core::primitive::u64,
						error: runtime_types::xcm::v3::traits::Error,
					},
					#[codec(index = 15)]
					NotifyTargetMigrationFail {
						location: runtime_types::xcm::VersionedLocation,
						query_id: ::core::primitive::u64,
					},
					#[codec(index = 16)]
					InvalidQuerierVersion {
						origin: runtime_types::staging_xcm::v4::location::Location,
						query_id: ::core::primitive::u64,
					},
					#[codec(index = 17)]
					InvalidQuerier {
						origin: runtime_types::staging_xcm::v4::location::Location,
						query_id: ::core::primitive::u64,
						expected_querier: runtime_types::staging_xcm::v4::location::Location,
						maybe_actual_querier: ::core::option::Option<
							runtime_types::staging_xcm::v4::location::Location,
						>,
					},
					#[codec(index = 18)]
					VersionNotifyStarted {
						destination: runtime_types::staging_xcm::v4::location::Location,
						cost: runtime_types::staging_xcm::v4::asset::Assets,
						message_id: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 19)]
					VersionNotifyRequested {
						destination: runtime_types::staging_xcm::v4::location::Location,
						cost: runtime_types::staging_xcm::v4::asset::Assets,
						message_id: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 20)]
					VersionNotifyUnrequested {
						destination: runtime_types::staging_xcm::v4::location::Location,
						cost: runtime_types::staging_xcm::v4::asset::Assets,
						message_id: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 21)]
					FeesPaid {
						paying: runtime_types::staging_xcm::v4::location::Location,
						fees: runtime_types::staging_xcm::v4::asset::Assets,
					},
					#[codec(index = 22)]
					AssetsClaimed {
						hash: ::subxt::utils::H256,
						origin: runtime_types::staging_xcm::v4::location::Location,
						assets: runtime_types::xcm::VersionedAssets,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Origin {
					#[codec(index = 0)]
					Xcm(runtime_types::staging_xcm::v4::location::Location),
					#[codec(index = 1)]
					Response(runtime_types::staging_xcm::v4::location::Location),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum QueryStatus<_0> {
					#[codec(index = 0)]
					Pending {
						responder: runtime_types::xcm::VersionedLocation,
						maybe_match_querier:
							::core::option::Option<runtime_types::xcm::VersionedLocation>,
						maybe_notify:
							::core::option::Option<(::core::primitive::u8, ::core::primitive::u8)>,
						timeout: _0,
					},
					#[codec(index = 1)]
					VersionNotifier {
						origin: runtime_types::xcm::VersionedLocation,
						is_active: ::core::primitive::bool,
					},
					#[codec(index = 2)]
					Ready { response: runtime_types::xcm::VersionedResponse, at: _0 },
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct RemoteLockedFungibleRecord<_0> {
					pub amount: ::core::primitive::u128,
					pub owner: runtime_types::xcm::VersionedLocation,
					pub locker: runtime_types::xcm::VersionedLocation,
					pub consumers: runtime_types::bounded_collections::bounded_vec::BoundedVec<(
						_0,
						::core::primitive::u128,
					)>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum VersionMigrationStage {
					#[codec(index = 0)]
					MigrateSupportedVersion,
					#[codec(index = 1)]
					MigrateVersionNotifiers,
					#[codec(index = 2)]
					NotifyCurrentTargets(
						::core::option::Option<::std::vec::Vec<::core::primitive::u8>>,
					),
					#[codec(index = 3)]
					MigrateAndNotifyOldTargets,
				}
			}
		}
		pub mod polkadot_core_primitives {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct InboundDownwardMessage<_0> {
				pub sent_at: _0,
				pub msg: ::std::vec::Vec<::core::primitive::u8>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct InboundHrmpMessage<_0> {
				pub sent_at: _0,
				pub data: ::std::vec::Vec<::core::primitive::u8>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct OutboundHrmpMessage<_0> {
				pub recipient: _0,
				pub data: ::std::vec::Vec<::core::primitive::u8>,
			}
		}
		pub mod polkadot_parachain_primitives {
			use super::runtime_types;
			pub mod primitives {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct HeadData(pub ::std::vec::Vec<::core::primitive::u8>);
				#[derive(
					:: codec :: Decode,
					:: codec :: Encode,
					:: subxt :: ext :: codec :: CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct Id(pub ::core::primitive::u32);
			}
		}
		pub mod polkadot_primitives {
			use super::runtime_types;
			pub mod v6 {
				use super::runtime_types;
				pub mod async_backing {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct AsyncBackingParams {
						pub max_candidate_depth: ::core::primitive::u32,
						pub allowed_ancestry_len: ::core::primitive::u32,
					}
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct AbridgedHostConfiguration {
					pub max_code_size: ::core::primitive::u32,
					pub max_head_data_size: ::core::primitive::u32,
					pub max_upward_queue_count: ::core::primitive::u32,
					pub max_upward_queue_size: ::core::primitive::u32,
					pub max_upward_message_size: ::core::primitive::u32,
					pub max_upward_message_num_per_candidate: ::core::primitive::u32,
					pub hrmp_max_message_num_per_candidate: ::core::primitive::u32,
					pub validation_upgrade_cooldown: ::core::primitive::u32,
					pub validation_upgrade_delay: ::core::primitive::u32,
					pub async_backing_params:
						runtime_types::polkadot_primitives::v6::async_backing::AsyncBackingParams,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct AbridgedHrmpChannel {
					pub max_capacity: ::core::primitive::u32,
					pub max_total_size: ::core::primitive::u32,
					pub max_message_size: ::core::primitive::u32,
					pub msg_count: ::core::primitive::u32,
					pub total_size: ::core::primitive::u32,
					pub mqc_head: ::core::option::Option<::subxt::utils::H256>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PersistedValidationData<_0, _1> {
					pub parent_head:
						runtime_types::polkadot_parachain_primitives::primitives::HeadData,
					pub relay_parent_number: _1,
					pub relay_parent_storage_root: _0,
					pub max_pov_size: ::core::primitive::u32,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum UpgradeGoAhead {
					#[codec(index = 0)]
					Abort,
					#[codec(index = 1)]
					GoAhead,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum UpgradeRestriction {
					#[codec(index = 0)]
					Present,
				}
			}
		}
		pub mod primitive_types {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct U256(pub [::core::primitive::u64; 4usize]);
		}
		pub mod snowbridge_amcl {
			use super::runtime_types;
			pub mod bls381 {
				use super::runtime_types;
				pub mod big {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct Big {
						pub w: [::core::primitive::i32; 14usize],
					}
				}
				pub mod ecp {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct ECP {
						pub x: runtime_types::snowbridge_amcl::bls381::fp::FP,
						pub y: runtime_types::snowbridge_amcl::bls381::fp::FP,
						pub z: runtime_types::snowbridge_amcl::bls381::fp::FP,
					}
				}
				pub mod fp {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct FP {
						pub x: runtime_types::snowbridge_amcl::bls381::big::Big,
						pub xes: ::core::primitive::i32,
					}
				}
			}
		}
		pub mod snowbridge_beacon_primitives {
			use super::runtime_types;
			pub mod bls {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum BlsError {
					#[codec(index = 0)]
					InvalidSignature,
					#[codec(index = 1)]
					InvalidPublicKey,
					#[codec(index = 2)]
					InvalidAggregatePublicKeys,
					#[codec(index = 3)]
					SignatureVerificationFailed,
				}
			}
			pub mod types {
				use super::runtime_types;
				pub mod deneb {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct ExecutionPayloadHeader {
						pub parent_hash: ::subxt::utils::H256,
						pub fee_recipient: ::subxt::utils::H160,
						pub state_root: ::subxt::utils::H256,
						pub receipts_root: ::subxt::utils::H256,
						pub logs_bloom: ::std::vec::Vec<::core::primitive::u8>,
						pub prev_randao: ::subxt::utils::H256,
						pub block_number: ::core::primitive::u64,
						pub gas_limit: ::core::primitive::u64,
						pub gas_used: ::core::primitive::u64,
						pub timestamp: ::core::primitive::u64,
						pub extra_data: ::std::vec::Vec<::core::primitive::u8>,
						pub base_fee_per_gas: runtime_types::primitive_types::U256,
						pub block_hash: ::subxt::utils::H256,
						pub transactions_root: ::subxt::utils::H256,
						pub withdrawals_root: ::subxt::utils::H256,
						pub blob_gas_used: ::core::primitive::u64,
						pub excess_blob_gas: ::core::primitive::u64,
					}
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BeaconHeader {
					pub slot: ::core::primitive::u64,
					pub proposer_index: ::core::primitive::u64,
					pub parent_root: ::subxt::utils::H256,
					pub state_root: ::subxt::utils::H256,
					pub body_root: ::subxt::utils::H256,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct CompactBeaconState {
					#[codec(compact)]
					pub slot: ::core::primitive::u64,
					pub block_roots_root: ::subxt::utils::H256,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct CompactExecutionHeader {
					pub parent_hash: ::subxt::utils::H256,
					#[codec(compact)]
					pub block_number: ::core::primitive::u64,
					pub state_root: ::subxt::utils::H256,
					pub receipts_root: ::subxt::utils::H256,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct ExecutionHeaderState {
					pub beacon_block_root: ::subxt::utils::H256,
					pub beacon_slot: ::core::primitive::u64,
					pub block_hash: ::subxt::utils::H256,
					pub block_number: ::core::primitive::u64,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct ExecutionPayloadHeader {
					pub parent_hash: ::subxt::utils::H256,
					pub fee_recipient: ::subxt::utils::H160,
					pub state_root: ::subxt::utils::H256,
					pub receipts_root: ::subxt::utils::H256,
					pub logs_bloom: ::std::vec::Vec<::core::primitive::u8>,
					pub prev_randao: ::subxt::utils::H256,
					pub block_number: ::core::primitive::u64,
					pub gas_limit: ::core::primitive::u64,
					pub gas_used: ::core::primitive::u64,
					pub timestamp: ::core::primitive::u64,
					pub extra_data: ::std::vec::Vec<::core::primitive::u8>,
					pub base_fee_per_gas: runtime_types::primitive_types::U256,
					pub block_hash: ::subxt::utils::H256,
					pub transactions_root: ::subxt::utils::H256,
					pub withdrawals_root: ::subxt::utils::H256,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Fork {
					pub version: [::core::primitive::u8; 4usize],
					pub epoch: ::core::primitive::u64,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct ForkVersions {
					pub genesis: runtime_types::snowbridge_beacon_primitives::types::Fork,
					pub altair: runtime_types::snowbridge_beacon_primitives::types::Fork,
					pub bellatrix: runtime_types::snowbridge_beacon_primitives::types::Fork,
					pub capella: runtime_types::snowbridge_beacon_primitives::types::Fork,
					pub deneb: runtime_types::snowbridge_beacon_primitives::types::Fork,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PublicKey(pub [::core::primitive::u8; 48usize]);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub [::core::primitive::u8; 96usize]);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct SyncAggregate {
					pub sync_committee_bits: [::core::primitive::u8; 64usize],
					pub sync_committee_signature:
						runtime_types::snowbridge_beacon_primitives::types::Signature,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct SyncCommittee {
					pub pubkeys:
						[runtime_types::snowbridge_beacon_primitives::types::PublicKey; 512usize],
					pub aggregate_pubkey:
						runtime_types::snowbridge_beacon_primitives::types::PublicKey,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct SyncCommitteePrepared {
					pub root: ::subxt::utils::H256,
					pub pubkeys: ::std::boxed::Box<
						[runtime_types::snowbridge_milagro_bls::keys::PublicKey; 512usize],
					>,
					pub aggregate_pubkey: runtime_types::snowbridge_milagro_bls::keys::PublicKey,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum VersionedExecutionPayloadHeader {
					# [codec (index = 0)] Capella (runtime_types :: snowbridge_beacon_primitives :: types :: ExecutionPayloadHeader ,) , # [codec (index = 1)] Deneb (runtime_types :: snowbridge_beacon_primitives :: types :: deneb :: ExecutionPayloadHeader ,) , }
			}
			pub mod updates {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct AncestryProof {
					pub header_branch: ::std::vec::Vec<::subxt::utils::H256>,
					pub finalized_block_root: ::subxt::utils::H256,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct CheckpointUpdate {
					pub header: runtime_types::snowbridge_beacon_primitives::types::BeaconHeader,
					pub current_sync_committee:
						runtime_types::snowbridge_beacon_primitives::types::SyncCommittee,
					pub current_sync_committee_branch: ::std::vec::Vec<::subxt::utils::H256>,
					pub validators_root: ::subxt::utils::H256,
					pub block_roots_root: ::subxt::utils::H256,
					pub block_roots_branch: ::std::vec::Vec<::subxt::utils::H256>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct ExecutionHeaderUpdate { pub header : runtime_types :: snowbridge_beacon_primitives :: types :: BeaconHeader , pub ancestry_proof : :: core :: option :: Option < runtime_types :: snowbridge_beacon_primitives :: updates :: AncestryProof > , pub execution_header : runtime_types :: snowbridge_beacon_primitives :: types :: VersionedExecutionPayloadHeader , pub execution_branch : :: std :: vec :: Vec < :: subxt :: utils :: H256 > , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct NextSyncCommitteeUpdate {
					pub next_sync_committee:
						runtime_types::snowbridge_beacon_primitives::types::SyncCommittee,
					pub next_sync_committee_branch: ::std::vec::Vec<::subxt::utils::H256>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Update { pub attested_header : runtime_types :: snowbridge_beacon_primitives :: types :: BeaconHeader , pub sync_aggregate : runtime_types :: snowbridge_beacon_primitives :: types :: SyncAggregate , pub signature_slot : :: core :: primitive :: u64 , pub next_sync_committee_update : :: core :: option :: Option < runtime_types :: snowbridge_beacon_primitives :: updates :: NextSyncCommitteeUpdate > , pub finalized_header : runtime_types :: snowbridge_beacon_primitives :: types :: BeaconHeader , pub finality_branch : :: std :: vec :: Vec < :: subxt :: utils :: H256 > , pub block_roots_root : :: subxt :: utils :: H256 , pub block_roots_branch : :: std :: vec :: Vec < :: subxt :: utils :: H256 > , }
			}
		}
		pub mod snowbridge_core {
			use super::runtime_types;
			pub mod inbound {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Log {
					pub address: ::subxt::utils::H160,
					pub topics: ::std::vec::Vec<::subxt::utils::H256>,
					pub data: ::std::vec::Vec<::core::primitive::u8>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Message {
					pub event_log: runtime_types::snowbridge_core::inbound::Log,
					pub proof: runtime_types::snowbridge_core::inbound::Proof,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Proof {
					pub block_hash: ::subxt::utils::H256,
					pub tx_index: ::core::primitive::u32,
					pub data: (
						::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>>,
						::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>>,
					),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum VerificationError {
					#[codec(index = 0)]
					HeaderNotFound,
					#[codec(index = 1)]
					LogNotFound,
					#[codec(index = 2)]
					InvalidLog,
					#[codec(index = 3)]
					InvalidProof,
				}
			}
			pub mod operating_mode {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum BasicOperatingMode {
					#[codec(index = 0)]
					Normal,
					#[codec(index = 1)]
					Halted,
				}
			}
			pub mod outbound {
				use super::runtime_types;
				pub mod v1 {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct Initializer {
						pub params: ::std::vec::Vec<::core::primitive::u8>,
						pub maximum_required_gas: ::core::primitive::u64,
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum OperatingMode {
						#[codec(index = 0)]
						Normal,
						#[codec(index = 1)]
						RejectingOutboundMessages,
					}
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum SendError {
					#[codec(index = 0)]
					MessageTooLarge,
					#[codec(index = 1)]
					Halted,
					#[codec(index = 2)]
					InvalidChannel,
				}
			}
			pub mod pricing {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PricingParameters<_0> {
					pub exchange_rate: runtime_types::sp_arithmetic::fixed_point::FixedU128,
					pub rewards: runtime_types::snowbridge_core::pricing::Rewards<_0>,
					pub fee_per_gas: runtime_types::primitive_types::U256,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Rewards<_0> {
					pub local: _0,
					pub remote: runtime_types::primitive_types::U256,
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Channel {
				pub agent_id: ::subxt::utils::H256,
				pub para_id: runtime_types::polkadot_parachain_primitives::primitives::Id,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ChannelId(pub [::core::primitive::u8; 32usize]);
		}
		pub mod snowbridge_milagro_bls {
			use super::runtime_types;
			pub mod keys {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PublicKey {
					pub point: runtime_types::snowbridge_amcl::bls381::ecp::ECP,
				}
			}
		}
		pub mod snowbridge_pallet_ethereum_client {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					# [codec (index = 0)] force_checkpoint { update : :: std :: boxed :: Box < runtime_types :: snowbridge_beacon_primitives :: updates :: CheckpointUpdate > , } , # [codec (index = 1)] submit { update : :: std :: boxed :: Box < runtime_types :: snowbridge_beacon_primitives :: updates :: Update > , } , # [codec (index = 2)] submit_execution_header { update : :: std :: boxed :: Box < runtime_types :: snowbridge_beacon_primitives :: updates :: ExecutionHeaderUpdate > , } , # [codec (index = 3)] set_operating_mode { mode : runtime_types :: snowbridge_core :: operating_mode :: BasicOperatingMode , } , }
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					SkippedSyncCommitteePeriod,
					#[codec(index = 1)]
					IrrelevantUpdate,
					#[codec(index = 2)]
					NotBootstrapped,
					#[codec(index = 3)]
					SyncCommitteeParticipantsNotSupermajority,
					#[codec(index = 4)]
					InvalidHeaderMerkleProof,
					#[codec(index = 5)]
					InvalidSyncCommitteeMerkleProof,
					#[codec(index = 6)]
					InvalidExecutionHeaderProof,
					#[codec(index = 7)]
					InvalidAncestryMerkleProof,
					#[codec(index = 8)]
					InvalidBlockRootsRootMerkleProof,
					#[codec(index = 9)]
					HeaderNotFinalized,
					#[codec(index = 10)]
					BlockBodyHashTreeRootFailed,
					#[codec(index = 11)]
					HeaderHashTreeRootFailed,
					#[codec(index = 12)]
					SyncCommitteeHashTreeRootFailed,
					#[codec(index = 13)]
					SigningRootHashTreeRootFailed,
					#[codec(index = 14)]
					ForkDataHashTreeRootFailed,
					#[codec(index = 15)]
					ExpectedFinalizedHeaderNotStored,
					#[codec(index = 16)]
					BLSPreparePublicKeysFailed,
					#[codec(index = 17)]
					BLSVerificationFailed(
						runtime_types::snowbridge_beacon_primitives::bls::BlsError,
					),
					#[codec(index = 18)]
					InvalidUpdateSlot,
					#[codec(index = 19)]
					InvalidSyncCommitteeUpdate,
					#[codec(index = 20)]
					ExecutionHeaderTooFarBehind,
					#[codec(index = 21)]
					ExecutionHeaderSkippedBlock,
					#[codec(index = 22)]
					Halted,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					BeaconHeaderImported {
						block_hash: ::subxt::utils::H256,
						slot: ::core::primitive::u64,
					},
					#[codec(index = 1)]
					ExecutionHeaderImported {
						block_hash: ::subxt::utils::H256,
						block_number: ::core::primitive::u64,
					},
					#[codec(index = 2)]
					SyncCommitteeUpdated { period: ::core::primitive::u64 },
					#[codec(index = 3)]
					OperatingModeChanged {
						mode: runtime_types::snowbridge_core::operating_mode::BasicOperatingMode,
					},
				}
			}
		}
		pub mod snowbridge_pallet_inbound_queue {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					submit { message: runtime_types::snowbridge_core::inbound::Message },
					#[codec(index = 1)]
					set_operating_mode {
						mode: runtime_types::snowbridge_core::operating_mode::BasicOperatingMode,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidGateway,
					#[codec(index = 1)]
					InvalidEnvelope,
					#[codec(index = 2)]
					InvalidNonce,
					#[codec(index = 3)]
					InvalidPayload,
					#[codec(index = 4)]
					InvalidChannel,
					#[codec(index = 5)]
					MaxNonceReached,
					#[codec(index = 6)]
					InvalidAccountConversion,
					#[codec(index = 7)]
					Halted,
					#[codec(index = 8)]
					Verification(runtime_types::snowbridge_core::inbound::VerificationError),
					#[codec(index = 9)]
					Send(runtime_types::snowbridge_pallet_inbound_queue::pallet::SendError),
					#[codec(index = 10)]
					ConvertMessage(
						runtime_types::snowbridge_router_primitives::inbound::ConvertMessageError,
					),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					MessageReceived {
						channel_id: runtime_types::snowbridge_core::ChannelId,
						nonce: ::core::primitive::u64,
						message_id: [::core::primitive::u8; 32usize],
						fee_burned: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					OperatingModeChanged {
						mode: runtime_types::snowbridge_core::operating_mode::BasicOperatingMode,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum SendError {
					#[codec(index = 0)]
					NotApplicable,
					#[codec(index = 1)]
					NotRoutable,
					#[codec(index = 2)]
					Transport,
					#[codec(index = 3)]
					DestinationUnsupported,
					#[codec(index = 4)]
					ExceedsMaxMessageSize,
					#[codec(index = 5)]
					MissingArgument,
					#[codec(index = 6)]
					Fees,
				}
			}
		}
		pub mod snowbridge_pallet_outbound_queue {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set_operating_mode {
						mode: runtime_types::snowbridge_core::operating_mode::BasicOperatingMode,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					MessageTooLarge,
					#[codec(index = 1)]
					Halted,
					#[codec(index = 2)]
					InvalidChannel,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					MessageQueued { id: ::subxt::utils::H256 },
					#[codec(index = 1)]
					MessageAccepted { id: ::subxt::utils::H256, nonce: ::core::primitive::u64 },
					#[codec(index = 2)]
					MessagesCommitted { root: ::subxt::utils::H256, count: ::core::primitive::u64 },
					#[codec(index = 3)]
					OperatingModeChanged {
						mode: runtime_types::snowbridge_core::operating_mode::BasicOperatingMode,
					},
				}
			}
			pub mod types {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct CommittedMessage {
					pub channel_id: runtime_types::snowbridge_core::ChannelId,
					#[codec(compact)]
					pub nonce: ::core::primitive::u64,
					pub command: ::core::primitive::u8,
					pub params: ::std::vec::Vec<::core::primitive::u8>,
					#[codec(compact)]
					pub max_dispatch_gas: ::core::primitive::u64,
					#[codec(compact)]
					pub max_fee_per_gas: ::core::primitive::u128,
					#[codec(compact)]
					pub reward: ::core::primitive::u128,
					pub id: ::subxt::utils::H256,
				}
			}
		}
		pub mod snowbridge_pallet_system {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					upgrade {
						impl_address: ::subxt::utils::H160,
						impl_code_hash: ::subxt::utils::H256,
						initializer: ::core::option::Option<
							runtime_types::snowbridge_core::outbound::v1::Initializer,
						>,
					},
					#[codec(index = 1)]
					set_operating_mode {
						mode: runtime_types::snowbridge_core::outbound::v1::OperatingMode,
					},
					#[codec(index = 2)]
					set_pricing_parameters {
						params: runtime_types::snowbridge_core::pricing::PricingParameters<
							::core::primitive::u128,
						>,
					},
					#[codec(index = 3)]
					create_agent,
					#[codec(index = 4)]
					create_channel {
						mode: runtime_types::snowbridge_core::outbound::v1::OperatingMode,
					},
					#[codec(index = 5)]
					update_channel {
						mode: runtime_types::snowbridge_core::outbound::v1::OperatingMode,
					},
					#[codec(index = 6)]
					force_update_channel {
						channel_id: runtime_types::snowbridge_core::ChannelId,
						mode: runtime_types::snowbridge_core::outbound::v1::OperatingMode,
					},
					#[codec(index = 7)]
					transfer_native_from_agent {
						recipient: ::subxt::utils::H160,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 8)]
					force_transfer_native_from_agent {
						location: ::std::boxed::Box<runtime_types::xcm::VersionedLocation>,
						recipient: ::subxt::utils::H160,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					set_token_transfer_fees {
						create_asset_xcm: ::core::primitive::u128,
						transfer_asset_xcm: ::core::primitive::u128,
						register_token: runtime_types::primitive_types::U256,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					LocationConversionFailed,
					#[codec(index = 1)]
					AgentAlreadyCreated,
					#[codec(index = 2)]
					NoAgent,
					#[codec(index = 3)]
					ChannelAlreadyCreated,
					#[codec(index = 4)]
					NoChannel,
					#[codec(index = 5)]
					UnsupportedLocationVersion,
					#[codec(index = 6)]
					InvalidLocation,
					#[codec(index = 7)]
					Send(runtime_types::snowbridge_core::outbound::SendError),
					#[codec(index = 8)]
					InvalidTokenTransferFees,
					#[codec(index = 9)]
					InvalidPricingParameters,
					#[codec(index = 10)]
					InvalidUpgradeParameters,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Upgrade {
						impl_address: ::subxt::utils::H160,
						impl_code_hash: ::subxt::utils::H256,
						initializer_params_hash: ::core::option::Option<::subxt::utils::H256>,
					},
					#[codec(index = 1)]
					CreateAgent {
						location:
							::std::boxed::Box<runtime_types::staging_xcm::v4::location::Location>,
						agent_id: ::subxt::utils::H256,
					},
					#[codec(index = 2)]
					CreateChannel {
						channel_id: runtime_types::snowbridge_core::ChannelId,
						agent_id: ::subxt::utils::H256,
					},
					#[codec(index = 3)]
					UpdateChannel {
						channel_id: runtime_types::snowbridge_core::ChannelId,
						mode: runtime_types::snowbridge_core::outbound::v1::OperatingMode,
					},
					#[codec(index = 4)]
					SetOperatingMode {
						mode: runtime_types::snowbridge_core::outbound::v1::OperatingMode,
					},
					#[codec(index = 5)]
					TransferNativeFromAgent {
						agent_id: ::subxt::utils::H256,
						recipient: ::subxt::utils::H160,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 6)]
					SetTokenTransferFees {
						create_asset_xcm: ::core::primitive::u128,
						transfer_asset_xcm: ::core::primitive::u128,
						register_token: runtime_types::primitive_types::U256,
					},
					#[codec(index = 7)]
					PricingParametersChanged {
						params: runtime_types::snowbridge_core::pricing::PricingParameters<
							::core::primitive::u128,
						>,
					},
				}
			}
		}
		pub mod snowbridge_router_primitives {
			use super::runtime_types;
			pub mod inbound {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum ConvertMessageError {
					#[codec(index = 0)]
					UnsupportedVersion,
				}
			}
		}
		pub mod sp_arithmetic {
			use super::runtime_types;
			pub mod fixed_point {
				use super::runtime_types;
				#[derive(
					:: codec :: Decode,
					:: codec :: Encode,
					:: subxt :: ext :: codec :: CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct FixedU128(pub ::core::primitive::u128);
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum ArithmeticError {
				#[codec(index = 0)]
				Underflow,
				#[codec(index = 1)]
				Overflow,
				#[codec(index = 2)]
				DivisionByZero,
			}
		}
		pub mod sp_consensus_aura {
			use super::runtime_types;
			pub mod sr25519 {
				use super::runtime_types;
				pub mod app_sr25519 {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct Public(pub runtime_types::sp_core::sr25519::Public);
				}
			}
		}
		pub mod sp_consensus_grandpa {
			use super::runtime_types;
			pub mod app {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub runtime_types::sp_core::ed25519::Public);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub runtime_types::sp_core::ed25519::Signature);
			}
		}
		pub mod sp_consensus_slots {
			use super::runtime_types;
			#[derive(
				:: codec :: Decode,
				:: codec :: Encode,
				:: subxt :: ext :: codec :: CompactAs,
				Clone,
				Debug,
				PartialEq,
			)]
			pub struct Slot(pub ::core::primitive::u64);
		}
		pub mod sp_core {
			use super::runtime_types;
			pub mod crypto {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct KeyTypeId(pub [::core::primitive::u8; 4usize]);
			}
			pub mod ecdsa {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub [::core::primitive::u8; 65usize]);
			}
			pub mod ed25519 {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub [::core::primitive::u8; 32usize]);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub [::core::primitive::u8; 64usize]);
			}
			pub mod sr25519 {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub [::core::primitive::u8; 32usize]);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub [::core::primitive::u8; 64usize]);
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Void {}
		}
		pub mod sp_runtime {
			use super::runtime_types;
			pub mod generic {
				use super::runtime_types;
				pub mod digest {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum DigestItem {
						#[codec(index = 6)]
						PreRuntime(
							[::core::primitive::u8; 4usize],
							::std::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 4)]
						Consensus(
							[::core::primitive::u8; 4usize],
							::std::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 5)]
						Seal(
							[::core::primitive::u8; 4usize],
							::std::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 0)]
						Other(::std::vec::Vec<::core::primitive::u8>),
						#[codec(index = 8)]
						RuntimeEnvironmentUpdated,
					}
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum DispatchError {
				#[codec(index = 0)]
				Other,
				#[codec(index = 1)]
				CannotLookup,
				#[codec(index = 2)]
				BadOrigin,
				#[codec(index = 3)]
				Module(runtime_types::sp_runtime::ModuleError),
				#[codec(index = 4)]
				ConsumerRemaining,
				#[codec(index = 5)]
				NoProviders,
				#[codec(index = 6)]
				TooManyConsumers,
				#[codec(index = 7)]
				Token(runtime_types::sp_runtime::TokenError),
				#[codec(index = 8)]
				Arithmetic(runtime_types::sp_arithmetic::ArithmeticError),
				#[codec(index = 9)]
				Transactional(runtime_types::sp_runtime::TransactionalError),
				#[codec(index = 10)]
				Exhausted,
				#[codec(index = 11)]
				Corruption,
				#[codec(index = 12)]
				Unavailable,
				#[codec(index = 13)]
				RootNotAllowed,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ModuleError {
				pub index: ::core::primitive::u8,
				pub error: [::core::primitive::u8; 4usize],
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum MultiSignature {
				#[codec(index = 0)]
				Ed25519(runtime_types::sp_core::ed25519::Signature),
				#[codec(index = 1)]
				Sr25519(runtime_types::sp_core::sr25519::Signature),
				#[codec(index = 2)]
				Ecdsa(runtime_types::sp_core::ecdsa::Signature),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum TokenError {
				#[codec(index = 0)]
				FundsUnavailable,
				#[codec(index = 1)]
				OnlyProvider,
				#[codec(index = 2)]
				BelowMinimum,
				#[codec(index = 3)]
				CannotCreate,
				#[codec(index = 4)]
				UnknownAsset,
				#[codec(index = 5)]
				Frozen,
				#[codec(index = 6)]
				Unsupported,
				#[codec(index = 7)]
				CannotCreateHold,
				#[codec(index = 8)]
				NotExpendable,
				#[codec(index = 9)]
				Blocked,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum TransactionalError {
				#[codec(index = 0)]
				LimitReached,
				#[codec(index = 1)]
				NoLayer,
			}
		}
		pub mod sp_trie {
			use super::runtime_types;
			pub mod storage_proof {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct StorageProof {
					pub trie_nodes: ::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>>,
				}
			}
		}
		pub mod sp_version {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct RuntimeVersion {
				pub spec_name: ::std::string::String,
				pub impl_name: ::std::string::String,
				pub authoring_version: ::core::primitive::u32,
				pub spec_version: ::core::primitive::u32,
				pub impl_version: ::core::primitive::u32,
				pub apis:
					::std::vec::Vec<([::core::primitive::u8; 8usize], ::core::primitive::u32)>,
				pub transaction_version: ::core::primitive::u32,
				pub state_version: ::core::primitive::u8,
			}
		}
		pub mod sp_weights {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct RuntimeDbWeight {
				pub read: ::core::primitive::u64,
				pub write: ::core::primitive::u64,
			}
		}
		pub mod staging_parachain_info {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {}
			}
		}
		pub mod staging_xcm {
			use super::runtime_types;
			pub mod v3 {
				use super::runtime_types;
				pub mod multilocation {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct MultiLocation {
						pub parents: ::core::primitive::u8,
						pub interior: runtime_types::xcm::v3::junctions::Junctions,
					}
				}
			}
			pub mod v4 {
				use super::runtime_types;
				pub mod asset {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct Asset {
						pub id: runtime_types::staging_xcm::v4::asset::AssetId,
						pub fun: runtime_types::staging_xcm::v4::asset::Fungibility,
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum AssetFilter {
						#[codec(index = 0)]
						Definite(runtime_types::staging_xcm::v4::asset::Assets),
						#[codec(index = 1)]
						Wild(runtime_types::staging_xcm::v4::asset::WildAsset),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct AssetId(pub runtime_types::staging_xcm::v4::location::Location);
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum AssetInstance {
						#[codec(index = 0)]
						Undefined,
						#[codec(index = 1)]
						Index(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 2)]
						Array4([::core::primitive::u8; 4usize]),
						#[codec(index = 3)]
						Array8([::core::primitive::u8; 8usize]),
						#[codec(index = 4)]
						Array16([::core::primitive::u8; 16usize]),
						#[codec(index = 5)]
						Array32([::core::primitive::u8; 32usize]),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct Assets(
						pub ::std::vec::Vec<runtime_types::staging_xcm::v4::asset::Asset>,
					);
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Fungibility {
						#[codec(index = 0)]
						Fungible(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 1)]
						NonFungible(runtime_types::staging_xcm::v4::asset::AssetInstance),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum WildAsset {
						#[codec(index = 0)]
						All,
						#[codec(index = 1)]
						AllOf {
							id: runtime_types::staging_xcm::v4::asset::AssetId,
							fun: runtime_types::staging_xcm::v4::asset::WildFungibility,
						},
						#[codec(index = 2)]
						AllCounted(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 3)]
						AllOfCounted {
							id: runtime_types::staging_xcm::v4::asset::AssetId,
							fun: runtime_types::staging_xcm::v4::asset::WildFungibility,
							#[codec(compact)]
							count: ::core::primitive::u32,
						},
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum WildFungibility {
						#[codec(index = 0)]
						Fungible,
						#[codec(index = 1)]
						NonFungible,
					}
				}
				pub mod junction {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Junction {
						#[codec(index = 0)]
						Parachain(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 1)]
						AccountId32 {
							network: ::core::option::Option<
								runtime_types::staging_xcm::v4::junction::NetworkId,
							>,
							id: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						AccountIndex64 {
							network: ::core::option::Option<
								runtime_types::staging_xcm::v4::junction::NetworkId,
							>,
							#[codec(compact)]
							index: ::core::primitive::u64,
						},
						#[codec(index = 3)]
						AccountKey20 {
							network: ::core::option::Option<
								runtime_types::staging_xcm::v4::junction::NetworkId,
							>,
							key: [::core::primitive::u8; 20usize],
						},
						#[codec(index = 4)]
						PalletInstance(::core::primitive::u8),
						#[codec(index = 5)]
						GeneralIndex(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 6)]
						GeneralKey {
							length: ::core::primitive::u8,
							data: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 7)]
						OnlyChild,
						#[codec(index = 8)]
						Plurality {
							id: runtime_types::xcm::v3::junction::BodyId,
							part: runtime_types::xcm::v3::junction::BodyPart,
						},
						#[codec(index = 9)]
						GlobalConsensus(runtime_types::staging_xcm::v4::junction::NetworkId),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum NetworkId {
						#[codec(index = 0)]
						ByGenesis([::core::primitive::u8; 32usize]),
						#[codec(index = 1)]
						ByFork {
							block_number: ::core::primitive::u64,
							block_hash: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						Polkadot,
						#[codec(index = 3)]
						Kusama,
						#[codec(index = 4)]
						Westend,
						#[codec(index = 5)]
						Rococo,
						#[codec(index = 6)]
						Wococo,
						#[codec(index = 7)]
						Ethereum {
							#[codec(compact)]
							chain_id: ::core::primitive::u64,
						},
						#[codec(index = 8)]
						BitcoinCore,
						#[codec(index = 9)]
						BitcoinCash,
						#[codec(index = 10)]
						PolkadotBulletin,
					}
				}
				pub mod junctions {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Junctions {
						#[codec(index = 0)]
						Here,
						#[codec(index = 1)]
						X1([runtime_types::staging_xcm::v4::junction::Junction; 1usize]),
						#[codec(index = 2)]
						X2([runtime_types::staging_xcm::v4::junction::Junction; 2usize]),
						#[codec(index = 3)]
						X3([runtime_types::staging_xcm::v4::junction::Junction; 3usize]),
						#[codec(index = 4)]
						X4([runtime_types::staging_xcm::v4::junction::Junction; 4usize]),
						#[codec(index = 5)]
						X5([runtime_types::staging_xcm::v4::junction::Junction; 5usize]),
						#[codec(index = 6)]
						X6([runtime_types::staging_xcm::v4::junction::Junction; 6usize]),
						#[codec(index = 7)]
						X7([runtime_types::staging_xcm::v4::junction::Junction; 7usize]),
						#[codec(index = 8)]
						X8([runtime_types::staging_xcm::v4::junction::Junction; 8usize]),
					}
				}
				pub mod location {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct Location {
						pub parents: ::core::primitive::u8,
						pub interior: runtime_types::staging_xcm::v4::junctions::Junctions,
					}
				}
				pub mod traits {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Outcome {
						#[codec(index = 0)]
						Complete { used: ::sp_weights::Weight },
						#[codec(index = 1)]
						Incomplete {
							used: ::sp_weights::Weight,
							error: runtime_types::xcm::v3::traits::Error,
						},
						#[codec(index = 2)]
						Error { error: runtime_types::xcm::v3::traits::Error },
					}
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Instruction {
					#[codec(index = 0)]
					WithdrawAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 1)]
					ReserveAssetDeposited(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 2)]
					ReceiveTeleportedAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 3)]
					QueryResponse {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						response: runtime_types::staging_xcm::v4::Response,
						max_weight: ::sp_weights::Weight,
						querier: ::core::option::Option<
							runtime_types::staging_xcm::v4::location::Location,
						>,
					},
					#[codec(index = 4)]
					TransferAsset {
						assets: runtime_types::staging_xcm::v4::asset::Assets,
						beneficiary: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 5)]
					TransferReserveAsset {
						assets: runtime_types::staging_xcm::v4::asset::Assets,
						dest: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 6)]
					Transact {
						origin_kind: runtime_types::xcm::v2::OriginKind,
						require_weight_at_most: ::sp_weights::Weight,
						call: runtime_types::xcm::double_encoded::DoubleEncoded,
					},
					#[codec(index = 7)]
					HrmpNewChannelOpenRequest {
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						max_message_size: ::core::primitive::u32,
						#[codec(compact)]
						max_capacity: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					HrmpChannelAccepted {
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 9)]
					HrmpChannelClosing {
						#[codec(compact)]
						initiator: ::core::primitive::u32,
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 10)]
					ClearOrigin,
					#[codec(index = 11)]
					DescendOrigin(runtime_types::staging_xcm::v4::junctions::Junctions),
					#[codec(index = 12)]
					ReportError(runtime_types::staging_xcm::v4::QueryResponseInfo),
					#[codec(index = 13)]
					DepositAsset {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						beneficiary: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 14)]
					DepositReserveAsset {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						dest: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 15)]
					ExchangeAsset {
						give: runtime_types::staging_xcm::v4::asset::AssetFilter,
						want: runtime_types::staging_xcm::v4::asset::Assets,
						maximal: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					InitiateReserveWithdraw {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						reserve: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 17)]
					InitiateTeleport {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						dest: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 18)]
					ReportHolding {
						response_info: runtime_types::staging_xcm::v4::QueryResponseInfo,
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
					},
					#[codec(index = 19)]
					BuyExecution {
						fees: runtime_types::staging_xcm::v4::asset::Asset,
						weight_limit: runtime_types::xcm::v3::WeightLimit,
					},
					#[codec(index = 20)]
					RefundSurplus,
					#[codec(index = 21)]
					SetErrorHandler(runtime_types::staging_xcm::v4::Xcm),
					#[codec(index = 22)]
					SetAppendix(runtime_types::staging_xcm::v4::Xcm),
					#[codec(index = 23)]
					ClearError,
					#[codec(index = 24)]
					ClaimAsset {
						assets: runtime_types::staging_xcm::v4::asset::Assets,
						ticket: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 25)]
					Trap(#[codec(compact)] ::core::primitive::u64),
					#[codec(index = 26)]
					SubscribeVersion {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						max_response_weight: ::sp_weights::Weight,
					},
					#[codec(index = 27)]
					UnsubscribeVersion,
					#[codec(index = 28)]
					BurnAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 29)]
					ExpectAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 30)]
					ExpectOrigin(
						::core::option::Option<runtime_types::staging_xcm::v4::location::Location>,
					),
					#[codec(index = 31)]
					ExpectError(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v3::traits::Error,
						)>,
					),
					#[codec(index = 32)]
					ExpectTransactStatus(runtime_types::xcm::v3::MaybeErrorCode),
					#[codec(index = 33)]
					QueryPallet {
						module_name: ::std::vec::Vec<::core::primitive::u8>,
						response_info: runtime_types::staging_xcm::v4::QueryResponseInfo,
					},
					#[codec(index = 34)]
					ExpectPallet {
						#[codec(compact)]
						index: ::core::primitive::u32,
						name: ::std::vec::Vec<::core::primitive::u8>,
						module_name: ::std::vec::Vec<::core::primitive::u8>,
						#[codec(compact)]
						crate_major: ::core::primitive::u32,
						#[codec(compact)]
						min_crate_minor: ::core::primitive::u32,
					},
					#[codec(index = 35)]
					ReportTransactStatus(runtime_types::staging_xcm::v4::QueryResponseInfo),
					#[codec(index = 36)]
					ClearTransactStatus,
					#[codec(index = 37)]
					UniversalOrigin(runtime_types::staging_xcm::v4::junction::Junction),
					#[codec(index = 38)]
					ExportMessage {
						network: runtime_types::staging_xcm::v4::junction::NetworkId,
						destination: runtime_types::staging_xcm::v4::junctions::Junctions,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 39)]
					LockAsset {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						unlocker: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 40)]
					UnlockAsset {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						target: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 41)]
					NoteUnlockable {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						owner: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 42)]
					RequestUnlock {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						locker: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 43)]
					SetFeesMode { jit_withdraw: ::core::primitive::bool },
					#[codec(index = 44)]
					SetTopic([::core::primitive::u8; 32usize]),
					#[codec(index = 45)]
					ClearTopic,
					#[codec(index = 46)]
					AliasOrigin(runtime_types::staging_xcm::v4::location::Location),
					#[codec(index = 47)]
					UnpaidExecution {
						weight_limit: runtime_types::xcm::v3::WeightLimit,
						check_origin: ::core::option::Option<
							runtime_types::staging_xcm::v4::location::Location,
						>,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Instruction2 {
					#[codec(index = 0)]
					WithdrawAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 1)]
					ReserveAssetDeposited(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 2)]
					ReceiveTeleportedAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 3)]
					QueryResponse {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						response: runtime_types::staging_xcm::v4::Response,
						max_weight: ::sp_weights::Weight,
						querier: ::core::option::Option<
							runtime_types::staging_xcm::v4::location::Location,
						>,
					},
					#[codec(index = 4)]
					TransferAsset {
						assets: runtime_types::staging_xcm::v4::asset::Assets,
						beneficiary: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 5)]
					TransferReserveAsset {
						assets: runtime_types::staging_xcm::v4::asset::Assets,
						dest: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 6)]
					Transact {
						origin_kind: runtime_types::xcm::v2::OriginKind,
						require_weight_at_most: ::sp_weights::Weight,
						call: runtime_types::xcm::double_encoded::DoubleEncoded2,
					},
					#[codec(index = 7)]
					HrmpNewChannelOpenRequest {
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						max_message_size: ::core::primitive::u32,
						#[codec(compact)]
						max_capacity: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					HrmpChannelAccepted {
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 9)]
					HrmpChannelClosing {
						#[codec(compact)]
						initiator: ::core::primitive::u32,
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 10)]
					ClearOrigin,
					#[codec(index = 11)]
					DescendOrigin(runtime_types::staging_xcm::v4::junctions::Junctions),
					#[codec(index = 12)]
					ReportError(runtime_types::staging_xcm::v4::QueryResponseInfo),
					#[codec(index = 13)]
					DepositAsset {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						beneficiary: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 14)]
					DepositReserveAsset {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						dest: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 15)]
					ExchangeAsset {
						give: runtime_types::staging_xcm::v4::asset::AssetFilter,
						want: runtime_types::staging_xcm::v4::asset::Assets,
						maximal: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					InitiateReserveWithdraw {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						reserve: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 17)]
					InitiateTeleport {
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
						dest: runtime_types::staging_xcm::v4::location::Location,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 18)]
					ReportHolding {
						response_info: runtime_types::staging_xcm::v4::QueryResponseInfo,
						assets: runtime_types::staging_xcm::v4::asset::AssetFilter,
					},
					#[codec(index = 19)]
					BuyExecution {
						fees: runtime_types::staging_xcm::v4::asset::Asset,
						weight_limit: runtime_types::xcm::v3::WeightLimit,
					},
					#[codec(index = 20)]
					RefundSurplus,
					#[codec(index = 21)]
					SetErrorHandler(runtime_types::staging_xcm::v4::Xcm2),
					#[codec(index = 22)]
					SetAppendix(runtime_types::staging_xcm::v4::Xcm2),
					#[codec(index = 23)]
					ClearError,
					#[codec(index = 24)]
					ClaimAsset {
						assets: runtime_types::staging_xcm::v4::asset::Assets,
						ticket: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 25)]
					Trap(#[codec(compact)] ::core::primitive::u64),
					#[codec(index = 26)]
					SubscribeVersion {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						max_response_weight: ::sp_weights::Weight,
					},
					#[codec(index = 27)]
					UnsubscribeVersion,
					#[codec(index = 28)]
					BurnAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 29)]
					ExpectAsset(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 30)]
					ExpectOrigin(
						::core::option::Option<runtime_types::staging_xcm::v4::location::Location>,
					),
					#[codec(index = 31)]
					ExpectError(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v3::traits::Error,
						)>,
					),
					#[codec(index = 32)]
					ExpectTransactStatus(runtime_types::xcm::v3::MaybeErrorCode),
					#[codec(index = 33)]
					QueryPallet {
						module_name: ::std::vec::Vec<::core::primitive::u8>,
						response_info: runtime_types::staging_xcm::v4::QueryResponseInfo,
					},
					#[codec(index = 34)]
					ExpectPallet {
						#[codec(compact)]
						index: ::core::primitive::u32,
						name: ::std::vec::Vec<::core::primitive::u8>,
						module_name: ::std::vec::Vec<::core::primitive::u8>,
						#[codec(compact)]
						crate_major: ::core::primitive::u32,
						#[codec(compact)]
						min_crate_minor: ::core::primitive::u32,
					},
					#[codec(index = 35)]
					ReportTransactStatus(runtime_types::staging_xcm::v4::QueryResponseInfo),
					#[codec(index = 36)]
					ClearTransactStatus,
					#[codec(index = 37)]
					UniversalOrigin(runtime_types::staging_xcm::v4::junction::Junction),
					#[codec(index = 38)]
					ExportMessage {
						network: runtime_types::staging_xcm::v4::junction::NetworkId,
						destination: runtime_types::staging_xcm::v4::junctions::Junctions,
						xcm: runtime_types::staging_xcm::v4::Xcm,
					},
					#[codec(index = 39)]
					LockAsset {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						unlocker: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 40)]
					UnlockAsset {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						target: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 41)]
					NoteUnlockable {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						owner: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 42)]
					RequestUnlock {
						asset: runtime_types::staging_xcm::v4::asset::Asset,
						locker: runtime_types::staging_xcm::v4::location::Location,
					},
					#[codec(index = 43)]
					SetFeesMode { jit_withdraw: ::core::primitive::bool },
					#[codec(index = 44)]
					SetTopic([::core::primitive::u8; 32usize]),
					#[codec(index = 45)]
					ClearTopic,
					#[codec(index = 46)]
					AliasOrigin(runtime_types::staging_xcm::v4::location::Location),
					#[codec(index = 47)]
					UnpaidExecution {
						weight_limit: runtime_types::xcm::v3::WeightLimit,
						check_origin: ::core::option::Option<
							runtime_types::staging_xcm::v4::location::Location,
						>,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PalletInfo {
					#[codec(compact)]
					pub index: ::core::primitive::u32,
					pub name: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					pub module_name: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					#[codec(compact)]
					pub major: ::core::primitive::u32,
					#[codec(compact)]
					pub minor: ::core::primitive::u32,
					#[codec(compact)]
					pub patch: ::core::primitive::u32,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct QueryResponseInfo {
					pub destination: runtime_types::staging_xcm::v4::location::Location,
					#[codec(compact)]
					pub query_id: ::core::primitive::u64,
					pub max_weight: ::sp_weights::Weight,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Response {
					#[codec(index = 0)]
					Null,
					#[codec(index = 1)]
					Assets(runtime_types::staging_xcm::v4::asset::Assets),
					#[codec(index = 2)]
					ExecutionResult(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v3::traits::Error,
						)>,
					),
					#[codec(index = 3)]
					Version(::core::primitive::u32),
					#[codec(index = 4)]
					PalletsInfo(
						runtime_types::bounded_collections::bounded_vec::BoundedVec<
							runtime_types::staging_xcm::v4::PalletInfo,
						>,
					),
					#[codec(index = 5)]
					DispatchResult(runtime_types::xcm::v3::MaybeErrorCode),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Xcm(pub ::std::vec::Vec<runtime_types::staging_xcm::v4::Instruction>);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Xcm2(pub ::std::vec::Vec<runtime_types::staging_xcm::v4::Instruction2>);
			}
		}
		pub mod xcm {
			use super::runtime_types;
			pub mod double_encoded {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct DoubleEncoded {
					pub encoded: ::std::vec::Vec<::core::primitive::u8>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct DoubleEncoded2 {
					pub encoded: ::std::vec::Vec<::core::primitive::u8>,
				}
			}
			pub mod v2 {
				use super::runtime_types;
				pub mod junction {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Junction {
						#[codec(index = 0)]
						Parachain(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 1)]
						AccountId32 {
							network: runtime_types::xcm::v2::NetworkId,
							id: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						AccountIndex64 {
							network: runtime_types::xcm::v2::NetworkId,
							#[codec(compact)]
							index: ::core::primitive::u64,
						},
						#[codec(index = 3)]
						AccountKey20 {
							network: runtime_types::xcm::v2::NetworkId,
							key: [::core::primitive::u8; 20usize],
						},
						#[codec(index = 4)]
						PalletInstance(::core::primitive::u8),
						#[codec(index = 5)]
						GeneralIndex(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 6)]
						GeneralKey(
							runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
								::core::primitive::u8,
							>,
						),
						#[codec(index = 7)]
						OnlyChild,
						#[codec(index = 8)]
						Plurality {
							id: runtime_types::xcm::v2::BodyId,
							part: runtime_types::xcm::v2::BodyPart,
						},
					}
				}
				pub mod multiasset {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum AssetId {
						#[codec(index = 0)]
						Concrete(runtime_types::xcm::v2::multilocation::MultiLocation),
						#[codec(index = 1)]
						Abstract(::std::vec::Vec<::core::primitive::u8>),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum AssetInstance {
						#[codec(index = 0)]
						Undefined,
						#[codec(index = 1)]
						Index(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 2)]
						Array4([::core::primitive::u8; 4usize]),
						#[codec(index = 3)]
						Array8([::core::primitive::u8; 8usize]),
						#[codec(index = 4)]
						Array16([::core::primitive::u8; 16usize]),
						#[codec(index = 5)]
						Array32([::core::primitive::u8; 32usize]),
						#[codec(index = 6)]
						Blob(::std::vec::Vec<::core::primitive::u8>),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Fungibility {
						#[codec(index = 0)]
						Fungible(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 1)]
						NonFungible(runtime_types::xcm::v2::multiasset::AssetInstance),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct MultiAsset {
						pub id: runtime_types::xcm::v2::multiasset::AssetId,
						pub fun: runtime_types::xcm::v2::multiasset::Fungibility,
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum MultiAssetFilter {
						#[codec(index = 0)]
						Definite(runtime_types::xcm::v2::multiasset::MultiAssets),
						#[codec(index = 1)]
						Wild(runtime_types::xcm::v2::multiasset::WildMultiAsset),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct MultiAssets(
						pub ::std::vec::Vec<runtime_types::xcm::v2::multiasset::MultiAsset>,
					);
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum WildFungibility {
						#[codec(index = 0)]
						Fungible,
						#[codec(index = 1)]
						NonFungible,
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum WildMultiAsset {
						#[codec(index = 0)]
						All,
						#[codec(index = 1)]
						AllOf {
							id: runtime_types::xcm::v2::multiasset::AssetId,
							fun: runtime_types::xcm::v2::multiasset::WildFungibility,
						},
					}
				}
				pub mod multilocation {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Junctions {
						#[codec(index = 0)]
						Here,
						#[codec(index = 1)]
						X1(runtime_types::xcm::v2::junction::Junction),
						#[codec(index = 2)]
						X2(
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
						),
						#[codec(index = 3)]
						X3(
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
						),
						#[codec(index = 4)]
						X4(
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
						),
						#[codec(index = 5)]
						X5(
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
						),
						#[codec(index = 6)]
						X6(
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
						),
						#[codec(index = 7)]
						X7(
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
						),
						#[codec(index = 8)]
						X8(
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
							runtime_types::xcm::v2::junction::Junction,
						),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct MultiLocation {
						pub parents: ::core::primitive::u8,
						pub interior: runtime_types::xcm::v2::multilocation::Junctions,
					}
				}
				pub mod traits {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Error {
						#[codec(index = 0)]
						Overflow,
						#[codec(index = 1)]
						Unimplemented,
						#[codec(index = 2)]
						UntrustedReserveLocation,
						#[codec(index = 3)]
						UntrustedTeleportLocation,
						#[codec(index = 4)]
						MultiLocationFull,
						#[codec(index = 5)]
						MultiLocationNotInvertible,
						#[codec(index = 6)]
						BadOrigin,
						#[codec(index = 7)]
						InvalidLocation,
						#[codec(index = 8)]
						AssetNotFound,
						#[codec(index = 9)]
						FailedToTransactAsset,
						#[codec(index = 10)]
						NotWithdrawable,
						#[codec(index = 11)]
						LocationCannotHold,
						#[codec(index = 12)]
						ExceedsMaxMessageSize,
						#[codec(index = 13)]
						DestinationUnsupported,
						#[codec(index = 14)]
						Transport,
						#[codec(index = 15)]
						Unroutable,
						#[codec(index = 16)]
						UnknownClaim,
						#[codec(index = 17)]
						FailedToDecode,
						#[codec(index = 18)]
						MaxWeightInvalid,
						#[codec(index = 19)]
						NotHoldingFees,
						#[codec(index = 20)]
						TooExpensive,
						#[codec(index = 21)]
						Trap(::core::primitive::u64),
						#[codec(index = 22)]
						UnhandledXcmVersion,
						#[codec(index = 23)]
						WeightLimitReached(::core::primitive::u64),
						#[codec(index = 24)]
						Barrier,
						#[codec(index = 25)]
						WeightNotComputable,
					}
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum BodyId {
					#[codec(index = 0)]
					Unit,
					#[codec(index = 1)]
					Named(
						runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
							::core::primitive::u8,
						>,
					),
					#[codec(index = 2)]
					Index(#[codec(compact)] ::core::primitive::u32),
					#[codec(index = 3)]
					Executive,
					#[codec(index = 4)]
					Technical,
					#[codec(index = 5)]
					Legislative,
					#[codec(index = 6)]
					Judicial,
					#[codec(index = 7)]
					Defense,
					#[codec(index = 8)]
					Administration,
					#[codec(index = 9)]
					Treasury,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum BodyPart {
					#[codec(index = 0)]
					Voice,
					#[codec(index = 1)]
					Members {
						#[codec(compact)]
						count: ::core::primitive::u32,
					},
					#[codec(index = 2)]
					Fraction {
						#[codec(compact)]
						nom: ::core::primitive::u32,
						#[codec(compact)]
						denom: ::core::primitive::u32,
					},
					#[codec(index = 3)]
					AtLeastProportion {
						#[codec(compact)]
						nom: ::core::primitive::u32,
						#[codec(compact)]
						denom: ::core::primitive::u32,
					},
					#[codec(index = 4)]
					MoreThanProportion {
						#[codec(compact)]
						nom: ::core::primitive::u32,
						#[codec(compact)]
						denom: ::core::primitive::u32,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Instruction {
					#[codec(index = 0)]
					WithdrawAsset(runtime_types::xcm::v2::multiasset::MultiAssets),
					#[codec(index = 1)]
					ReserveAssetDeposited(runtime_types::xcm::v2::multiasset::MultiAssets),
					#[codec(index = 2)]
					ReceiveTeleportedAsset(runtime_types::xcm::v2::multiasset::MultiAssets),
					#[codec(index = 3)]
					QueryResponse {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						response: runtime_types::xcm::v2::Response,
						#[codec(compact)]
						max_weight: ::core::primitive::u64,
					},
					#[codec(index = 4)]
					TransferAsset {
						assets: runtime_types::xcm::v2::multiasset::MultiAssets,
						beneficiary: runtime_types::xcm::v2::multilocation::MultiLocation,
					},
					#[codec(index = 5)]
					TransferReserveAsset {
						assets: runtime_types::xcm::v2::multiasset::MultiAssets,
						dest: runtime_types::xcm::v2::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v2::Xcm,
					},
					#[codec(index = 6)]
					Transact {
						origin_type: runtime_types::xcm::v2::OriginKind,
						#[codec(compact)]
						require_weight_at_most: ::core::primitive::u64,
						call: runtime_types::xcm::double_encoded::DoubleEncoded,
					},
					#[codec(index = 7)]
					HrmpNewChannelOpenRequest {
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						max_message_size: ::core::primitive::u32,
						#[codec(compact)]
						max_capacity: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					HrmpChannelAccepted {
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 9)]
					HrmpChannelClosing {
						#[codec(compact)]
						initiator: ::core::primitive::u32,
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 10)]
					ClearOrigin,
					#[codec(index = 11)]
					DescendOrigin(runtime_types::xcm::v2::multilocation::Junctions),
					#[codec(index = 12)]
					ReportError {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						dest: runtime_types::xcm::v2::multilocation::MultiLocation,
						#[codec(compact)]
						max_response_weight: ::core::primitive::u64,
					},
					#[codec(index = 13)]
					DepositAsset {
						assets: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						#[codec(compact)]
						max_assets: ::core::primitive::u32,
						beneficiary: runtime_types::xcm::v2::multilocation::MultiLocation,
					},
					#[codec(index = 14)]
					DepositReserveAsset {
						assets: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						#[codec(compact)]
						max_assets: ::core::primitive::u32,
						dest: runtime_types::xcm::v2::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v2::Xcm,
					},
					#[codec(index = 15)]
					ExchangeAsset {
						give: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						receive: runtime_types::xcm::v2::multiasset::MultiAssets,
					},
					#[codec(index = 16)]
					InitiateReserveWithdraw {
						assets: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						reserve: runtime_types::xcm::v2::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v2::Xcm,
					},
					#[codec(index = 17)]
					InitiateTeleport {
						assets: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						dest: runtime_types::xcm::v2::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v2::Xcm,
					},
					#[codec(index = 18)]
					QueryHolding {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						dest: runtime_types::xcm::v2::multilocation::MultiLocation,
						assets: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						#[codec(compact)]
						max_response_weight: ::core::primitive::u64,
					},
					#[codec(index = 19)]
					BuyExecution {
						fees: runtime_types::xcm::v2::multiasset::MultiAsset,
						weight_limit: runtime_types::xcm::v2::WeightLimit,
					},
					#[codec(index = 20)]
					RefundSurplus,
					#[codec(index = 21)]
					SetErrorHandler(runtime_types::xcm::v2::Xcm),
					#[codec(index = 22)]
					SetAppendix(runtime_types::xcm::v2::Xcm),
					#[codec(index = 23)]
					ClearError,
					#[codec(index = 24)]
					ClaimAsset {
						assets: runtime_types::xcm::v2::multiasset::MultiAssets,
						ticket: runtime_types::xcm::v2::multilocation::MultiLocation,
					},
					#[codec(index = 25)]
					Trap(#[codec(compact)] ::core::primitive::u64),
					#[codec(index = 26)]
					SubscribeVersion {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						#[codec(compact)]
						max_response_weight: ::core::primitive::u64,
					},
					#[codec(index = 27)]
					UnsubscribeVersion,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Instruction2 {
					#[codec(index = 0)]
					WithdrawAsset(runtime_types::xcm::v2::multiasset::MultiAssets),
					#[codec(index = 1)]
					ReserveAssetDeposited(runtime_types::xcm::v2::multiasset::MultiAssets),
					#[codec(index = 2)]
					ReceiveTeleportedAsset(runtime_types::xcm::v2::multiasset::MultiAssets),
					#[codec(index = 3)]
					QueryResponse {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						response: runtime_types::xcm::v2::Response,
						#[codec(compact)]
						max_weight: ::core::primitive::u64,
					},
					#[codec(index = 4)]
					TransferAsset {
						assets: runtime_types::xcm::v2::multiasset::MultiAssets,
						beneficiary: runtime_types::xcm::v2::multilocation::MultiLocation,
					},
					#[codec(index = 5)]
					TransferReserveAsset {
						assets: runtime_types::xcm::v2::multiasset::MultiAssets,
						dest: runtime_types::xcm::v2::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v2::Xcm,
					},
					#[codec(index = 6)]
					Transact {
						origin_type: runtime_types::xcm::v2::OriginKind,
						#[codec(compact)]
						require_weight_at_most: ::core::primitive::u64,
						call: runtime_types::xcm::double_encoded::DoubleEncoded2,
					},
					#[codec(index = 7)]
					HrmpNewChannelOpenRequest {
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						max_message_size: ::core::primitive::u32,
						#[codec(compact)]
						max_capacity: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					HrmpChannelAccepted {
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 9)]
					HrmpChannelClosing {
						#[codec(compact)]
						initiator: ::core::primitive::u32,
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 10)]
					ClearOrigin,
					#[codec(index = 11)]
					DescendOrigin(runtime_types::xcm::v2::multilocation::Junctions),
					#[codec(index = 12)]
					ReportError {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						dest: runtime_types::xcm::v2::multilocation::MultiLocation,
						#[codec(compact)]
						max_response_weight: ::core::primitive::u64,
					},
					#[codec(index = 13)]
					DepositAsset {
						assets: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						#[codec(compact)]
						max_assets: ::core::primitive::u32,
						beneficiary: runtime_types::xcm::v2::multilocation::MultiLocation,
					},
					#[codec(index = 14)]
					DepositReserveAsset {
						assets: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						#[codec(compact)]
						max_assets: ::core::primitive::u32,
						dest: runtime_types::xcm::v2::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v2::Xcm,
					},
					#[codec(index = 15)]
					ExchangeAsset {
						give: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						receive: runtime_types::xcm::v2::multiasset::MultiAssets,
					},
					#[codec(index = 16)]
					InitiateReserveWithdraw {
						assets: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						reserve: runtime_types::xcm::v2::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v2::Xcm,
					},
					#[codec(index = 17)]
					InitiateTeleport {
						assets: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						dest: runtime_types::xcm::v2::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v2::Xcm,
					},
					#[codec(index = 18)]
					QueryHolding {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						dest: runtime_types::xcm::v2::multilocation::MultiLocation,
						assets: runtime_types::xcm::v2::multiasset::MultiAssetFilter,
						#[codec(compact)]
						max_response_weight: ::core::primitive::u64,
					},
					#[codec(index = 19)]
					BuyExecution {
						fees: runtime_types::xcm::v2::multiasset::MultiAsset,
						weight_limit: runtime_types::xcm::v2::WeightLimit,
					},
					#[codec(index = 20)]
					RefundSurplus,
					#[codec(index = 21)]
					SetErrorHandler(runtime_types::xcm::v2::Xcm2),
					#[codec(index = 22)]
					SetAppendix(runtime_types::xcm::v2::Xcm2),
					#[codec(index = 23)]
					ClearError,
					#[codec(index = 24)]
					ClaimAsset {
						assets: runtime_types::xcm::v2::multiasset::MultiAssets,
						ticket: runtime_types::xcm::v2::multilocation::MultiLocation,
					},
					#[codec(index = 25)]
					Trap(#[codec(compact)] ::core::primitive::u64),
					#[codec(index = 26)]
					SubscribeVersion {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						#[codec(compact)]
						max_response_weight: ::core::primitive::u64,
					},
					#[codec(index = 27)]
					UnsubscribeVersion,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum NetworkId {
					#[codec(index = 0)]
					Any,
					#[codec(index = 1)]
					Named(
						runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
							::core::primitive::u8,
						>,
					),
					#[codec(index = 2)]
					Polkadot,
					#[codec(index = 3)]
					Kusama,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum OriginKind {
					#[codec(index = 0)]
					Native,
					#[codec(index = 1)]
					SovereignAccount,
					#[codec(index = 2)]
					Superuser,
					#[codec(index = 3)]
					Xcm,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Response {
					#[codec(index = 0)]
					Null,
					#[codec(index = 1)]
					Assets(runtime_types::xcm::v2::multiasset::MultiAssets),
					#[codec(index = 2)]
					ExecutionResult(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v2::traits::Error,
						)>,
					),
					#[codec(index = 3)]
					Version(::core::primitive::u32),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum WeightLimit {
					#[codec(index = 0)]
					Unlimited,
					#[codec(index = 1)]
					Limited(#[codec(compact)] ::core::primitive::u64),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Xcm(pub ::std::vec::Vec<runtime_types::xcm::v2::Instruction>);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Xcm2(pub ::std::vec::Vec<runtime_types::xcm::v2::Instruction2>);
			}
			pub mod v3 {
				use super::runtime_types;
				pub mod junction {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum BodyId {
						#[codec(index = 0)]
						Unit,
						#[codec(index = 1)]
						Moniker([::core::primitive::u8; 4usize]),
						#[codec(index = 2)]
						Index(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 3)]
						Executive,
						#[codec(index = 4)]
						Technical,
						#[codec(index = 5)]
						Legislative,
						#[codec(index = 6)]
						Judicial,
						#[codec(index = 7)]
						Defense,
						#[codec(index = 8)]
						Administration,
						#[codec(index = 9)]
						Treasury,
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum BodyPart {
						#[codec(index = 0)]
						Voice,
						#[codec(index = 1)]
						Members {
							#[codec(compact)]
							count: ::core::primitive::u32,
						},
						#[codec(index = 2)]
						Fraction {
							#[codec(compact)]
							nom: ::core::primitive::u32,
							#[codec(compact)]
							denom: ::core::primitive::u32,
						},
						#[codec(index = 3)]
						AtLeastProportion {
							#[codec(compact)]
							nom: ::core::primitive::u32,
							#[codec(compact)]
							denom: ::core::primitive::u32,
						},
						#[codec(index = 4)]
						MoreThanProportion {
							#[codec(compact)]
							nom: ::core::primitive::u32,
							#[codec(compact)]
							denom: ::core::primitive::u32,
						},
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Junction {
						#[codec(index = 0)]
						Parachain(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 1)]
						AccountId32 {
							network:
								::core::option::Option<runtime_types::xcm::v3::junction::NetworkId>,
							id: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						AccountIndex64 {
							network:
								::core::option::Option<runtime_types::xcm::v3::junction::NetworkId>,
							#[codec(compact)]
							index: ::core::primitive::u64,
						},
						#[codec(index = 3)]
						AccountKey20 {
							network:
								::core::option::Option<runtime_types::xcm::v3::junction::NetworkId>,
							key: [::core::primitive::u8; 20usize],
						},
						#[codec(index = 4)]
						PalletInstance(::core::primitive::u8),
						#[codec(index = 5)]
						GeneralIndex(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 6)]
						GeneralKey {
							length: ::core::primitive::u8,
							data: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 7)]
						OnlyChild,
						#[codec(index = 8)]
						Plurality {
							id: runtime_types::xcm::v3::junction::BodyId,
							part: runtime_types::xcm::v3::junction::BodyPart,
						},
						#[codec(index = 9)]
						GlobalConsensus(runtime_types::xcm::v3::junction::NetworkId),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum NetworkId {
						#[codec(index = 0)]
						ByGenesis([::core::primitive::u8; 32usize]),
						#[codec(index = 1)]
						ByFork {
							block_number: ::core::primitive::u64,
							block_hash: [::core::primitive::u8; 32usize],
						},
						#[codec(index = 2)]
						Polkadot,
						#[codec(index = 3)]
						Kusama,
						#[codec(index = 4)]
						Westend,
						#[codec(index = 5)]
						Rococo,
						#[codec(index = 6)]
						Wococo,
						#[codec(index = 7)]
						Ethereum {
							#[codec(compact)]
							chain_id: ::core::primitive::u64,
						},
						#[codec(index = 8)]
						BitcoinCore,
						#[codec(index = 9)]
						BitcoinCash,
						#[codec(index = 10)]
						PolkadotBulletin,
					}
				}
				pub mod junctions {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Junctions {
						#[codec(index = 0)]
						Here,
						#[codec(index = 1)]
						X1(runtime_types::xcm::v3::junction::Junction),
						#[codec(index = 2)]
						X2(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 3)]
						X3(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 4)]
						X4(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 5)]
						X5(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 6)]
						X6(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 7)]
						X7(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
						#[codec(index = 8)]
						X8(
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
							runtime_types::xcm::v3::junction::Junction,
						),
					}
				}
				pub mod multiasset {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum AssetId {
						#[codec(index = 0)]
						Concrete(runtime_types::staging_xcm::v3::multilocation::MultiLocation),
						#[codec(index = 1)]
						Abstract([::core::primitive::u8; 32usize]),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum AssetInstance {
						#[codec(index = 0)]
						Undefined,
						#[codec(index = 1)]
						Index(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 2)]
						Array4([::core::primitive::u8; 4usize]),
						#[codec(index = 3)]
						Array8([::core::primitive::u8; 8usize]),
						#[codec(index = 4)]
						Array16([::core::primitive::u8; 16usize]),
						#[codec(index = 5)]
						Array32([::core::primitive::u8; 32usize]),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Fungibility {
						#[codec(index = 0)]
						Fungible(#[codec(compact)] ::core::primitive::u128),
						#[codec(index = 1)]
						NonFungible(runtime_types::xcm::v3::multiasset::AssetInstance),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct MultiAsset {
						pub id: runtime_types::xcm::v3::multiasset::AssetId,
						pub fun: runtime_types::xcm::v3::multiasset::Fungibility,
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum MultiAssetFilter {
						#[codec(index = 0)]
						Definite(runtime_types::xcm::v3::multiasset::MultiAssets),
						#[codec(index = 1)]
						Wild(runtime_types::xcm::v3::multiasset::WildMultiAsset),
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct MultiAssets(
						pub ::std::vec::Vec<runtime_types::xcm::v3::multiasset::MultiAsset>,
					);
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum WildFungibility {
						#[codec(index = 0)]
						Fungible,
						#[codec(index = 1)]
						NonFungible,
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum WildMultiAsset {
						#[codec(index = 0)]
						All,
						#[codec(index = 1)]
						AllOf {
							id: runtime_types::xcm::v3::multiasset::AssetId,
							fun: runtime_types::xcm::v3::multiasset::WildFungibility,
						},
						#[codec(index = 2)]
						AllCounted(#[codec(compact)] ::core::primitive::u32),
						#[codec(index = 3)]
						AllOfCounted {
							id: runtime_types::xcm::v3::multiasset::AssetId,
							fun: runtime_types::xcm::v3::multiasset::WildFungibility,
							#[codec(compact)]
							count: ::core::primitive::u32,
						},
					}
				}
				pub mod traits {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Error {
						#[codec(index = 0)]
						Overflow,
						#[codec(index = 1)]
						Unimplemented,
						#[codec(index = 2)]
						UntrustedReserveLocation,
						#[codec(index = 3)]
						UntrustedTeleportLocation,
						#[codec(index = 4)]
						LocationFull,
						#[codec(index = 5)]
						LocationNotInvertible,
						#[codec(index = 6)]
						BadOrigin,
						#[codec(index = 7)]
						InvalidLocation,
						#[codec(index = 8)]
						AssetNotFound,
						#[codec(index = 9)]
						FailedToTransactAsset,
						#[codec(index = 10)]
						NotWithdrawable,
						#[codec(index = 11)]
						LocationCannotHold,
						#[codec(index = 12)]
						ExceedsMaxMessageSize,
						#[codec(index = 13)]
						DestinationUnsupported,
						#[codec(index = 14)]
						Transport,
						#[codec(index = 15)]
						Unroutable,
						#[codec(index = 16)]
						UnknownClaim,
						#[codec(index = 17)]
						FailedToDecode,
						#[codec(index = 18)]
						MaxWeightInvalid,
						#[codec(index = 19)]
						NotHoldingFees,
						#[codec(index = 20)]
						TooExpensive,
						#[codec(index = 21)]
						Trap(::core::primitive::u64),
						#[codec(index = 22)]
						ExpectationFalse,
						#[codec(index = 23)]
						PalletNotFound,
						#[codec(index = 24)]
						NameMismatch,
						#[codec(index = 25)]
						VersionIncompatible,
						#[codec(index = 26)]
						HoldingWouldOverflow,
						#[codec(index = 27)]
						ExportError,
						#[codec(index = 28)]
						ReanchorFailed,
						#[codec(index = 29)]
						NoDeal,
						#[codec(index = 30)]
						FeesNotMet,
						#[codec(index = 31)]
						LockError,
						#[codec(index = 32)]
						NoPermission,
						#[codec(index = 33)]
						Unanchored,
						#[codec(index = 34)]
						NotDepositable,
						#[codec(index = 35)]
						UnhandledXcmVersion,
						#[codec(index = 36)]
						WeightLimitReached(::sp_weights::Weight),
						#[codec(index = 37)]
						Barrier,
						#[codec(index = 38)]
						WeightNotComputable,
						#[codec(index = 39)]
						ExceedsStackLimit,
					}
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Instruction {
					#[codec(index = 0)]
					WithdrawAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 1)]
					ReserveAssetDeposited(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 2)]
					ReceiveTeleportedAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 3)]
					QueryResponse {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						response: runtime_types::xcm::v3::Response,
						max_weight: ::sp_weights::Weight,
						querier: ::core::option::Option<
							runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						>,
					},
					#[codec(index = 4)]
					TransferAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssets,
						beneficiary: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 5)]
					TransferReserveAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssets,
						dest: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 6)]
					Transact {
						origin_kind: runtime_types::xcm::v2::OriginKind,
						require_weight_at_most: ::sp_weights::Weight,
						call: runtime_types::xcm::double_encoded::DoubleEncoded,
					},
					#[codec(index = 7)]
					HrmpNewChannelOpenRequest {
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						max_message_size: ::core::primitive::u32,
						#[codec(compact)]
						max_capacity: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					HrmpChannelAccepted {
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 9)]
					HrmpChannelClosing {
						#[codec(compact)]
						initiator: ::core::primitive::u32,
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 10)]
					ClearOrigin,
					#[codec(index = 11)]
					DescendOrigin(runtime_types::xcm::v3::junctions::Junctions),
					#[codec(index = 12)]
					ReportError(runtime_types::xcm::v3::QueryResponseInfo),
					#[codec(index = 13)]
					DepositAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						beneficiary: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 14)]
					DepositReserveAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						dest: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 15)]
					ExchangeAsset {
						give: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						want: runtime_types::xcm::v3::multiasset::MultiAssets,
						maximal: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					InitiateReserveWithdraw {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						reserve: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 17)]
					InitiateTeleport {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						dest: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 18)]
					ReportHolding {
						response_info: runtime_types::xcm::v3::QueryResponseInfo,
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
					},
					#[codec(index = 19)]
					BuyExecution {
						fees: runtime_types::xcm::v3::multiasset::MultiAsset,
						weight_limit: runtime_types::xcm::v3::WeightLimit,
					},
					#[codec(index = 20)]
					RefundSurplus,
					#[codec(index = 21)]
					SetErrorHandler(runtime_types::xcm::v3::Xcm),
					#[codec(index = 22)]
					SetAppendix(runtime_types::xcm::v3::Xcm),
					#[codec(index = 23)]
					ClearError,
					#[codec(index = 24)]
					ClaimAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssets,
						ticket: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 25)]
					Trap(#[codec(compact)] ::core::primitive::u64),
					#[codec(index = 26)]
					SubscribeVersion {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						max_response_weight: ::sp_weights::Weight,
					},
					#[codec(index = 27)]
					UnsubscribeVersion,
					#[codec(index = 28)]
					BurnAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 29)]
					ExpectAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 30)]
					ExpectOrigin(
						::core::option::Option<
							runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						>,
					),
					#[codec(index = 31)]
					ExpectError(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v3::traits::Error,
						)>,
					),
					#[codec(index = 32)]
					ExpectTransactStatus(runtime_types::xcm::v3::MaybeErrorCode),
					#[codec(index = 33)]
					QueryPallet {
						module_name: ::std::vec::Vec<::core::primitive::u8>,
						response_info: runtime_types::xcm::v3::QueryResponseInfo,
					},
					#[codec(index = 34)]
					ExpectPallet {
						#[codec(compact)]
						index: ::core::primitive::u32,
						name: ::std::vec::Vec<::core::primitive::u8>,
						module_name: ::std::vec::Vec<::core::primitive::u8>,
						#[codec(compact)]
						crate_major: ::core::primitive::u32,
						#[codec(compact)]
						min_crate_minor: ::core::primitive::u32,
					},
					#[codec(index = 35)]
					ReportTransactStatus(runtime_types::xcm::v3::QueryResponseInfo),
					#[codec(index = 36)]
					ClearTransactStatus,
					#[codec(index = 37)]
					UniversalOrigin(runtime_types::xcm::v3::junction::Junction),
					#[codec(index = 38)]
					ExportMessage {
						network: runtime_types::xcm::v3::junction::NetworkId,
						destination: runtime_types::xcm::v3::junctions::Junctions,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 39)]
					LockAsset {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						unlocker: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 40)]
					UnlockAsset {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						target: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 41)]
					NoteUnlockable {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						owner: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 42)]
					RequestUnlock {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						locker: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 43)]
					SetFeesMode { jit_withdraw: ::core::primitive::bool },
					#[codec(index = 44)]
					SetTopic([::core::primitive::u8; 32usize]),
					#[codec(index = 45)]
					ClearTopic,
					#[codec(index = 46)]
					AliasOrigin(runtime_types::staging_xcm::v3::multilocation::MultiLocation),
					#[codec(index = 47)]
					UnpaidExecution {
						weight_limit: runtime_types::xcm::v3::WeightLimit,
						check_origin: ::core::option::Option<
							runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						>,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Instruction2 {
					#[codec(index = 0)]
					WithdrawAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 1)]
					ReserveAssetDeposited(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 2)]
					ReceiveTeleportedAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 3)]
					QueryResponse {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						response: runtime_types::xcm::v3::Response,
						max_weight: ::sp_weights::Weight,
						querier: ::core::option::Option<
							runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						>,
					},
					#[codec(index = 4)]
					TransferAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssets,
						beneficiary: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 5)]
					TransferReserveAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssets,
						dest: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 6)]
					Transact {
						origin_kind: runtime_types::xcm::v2::OriginKind,
						require_weight_at_most: ::sp_weights::Weight,
						call: runtime_types::xcm::double_encoded::DoubleEncoded2,
					},
					#[codec(index = 7)]
					HrmpNewChannelOpenRequest {
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						max_message_size: ::core::primitive::u32,
						#[codec(compact)]
						max_capacity: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					HrmpChannelAccepted {
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 9)]
					HrmpChannelClosing {
						#[codec(compact)]
						initiator: ::core::primitive::u32,
						#[codec(compact)]
						sender: ::core::primitive::u32,
						#[codec(compact)]
						recipient: ::core::primitive::u32,
					},
					#[codec(index = 10)]
					ClearOrigin,
					#[codec(index = 11)]
					DescendOrigin(runtime_types::xcm::v3::junctions::Junctions),
					#[codec(index = 12)]
					ReportError(runtime_types::xcm::v3::QueryResponseInfo),
					#[codec(index = 13)]
					DepositAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						beneficiary: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 14)]
					DepositReserveAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						dest: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 15)]
					ExchangeAsset {
						give: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						want: runtime_types::xcm::v3::multiasset::MultiAssets,
						maximal: ::core::primitive::bool,
					},
					#[codec(index = 16)]
					InitiateReserveWithdraw {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						reserve: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 17)]
					InitiateTeleport {
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
						dest: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 18)]
					ReportHolding {
						response_info: runtime_types::xcm::v3::QueryResponseInfo,
						assets: runtime_types::xcm::v3::multiasset::MultiAssetFilter,
					},
					#[codec(index = 19)]
					BuyExecution {
						fees: runtime_types::xcm::v3::multiasset::MultiAsset,
						weight_limit: runtime_types::xcm::v3::WeightLimit,
					},
					#[codec(index = 20)]
					RefundSurplus,
					#[codec(index = 21)]
					SetErrorHandler(runtime_types::xcm::v3::Xcm2),
					#[codec(index = 22)]
					SetAppendix(runtime_types::xcm::v3::Xcm2),
					#[codec(index = 23)]
					ClearError,
					#[codec(index = 24)]
					ClaimAsset {
						assets: runtime_types::xcm::v3::multiasset::MultiAssets,
						ticket: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 25)]
					Trap(#[codec(compact)] ::core::primitive::u64),
					#[codec(index = 26)]
					SubscribeVersion {
						#[codec(compact)]
						query_id: ::core::primitive::u64,
						max_response_weight: ::sp_weights::Weight,
					},
					#[codec(index = 27)]
					UnsubscribeVersion,
					#[codec(index = 28)]
					BurnAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 29)]
					ExpectAsset(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 30)]
					ExpectOrigin(
						::core::option::Option<
							runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						>,
					),
					#[codec(index = 31)]
					ExpectError(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v3::traits::Error,
						)>,
					),
					#[codec(index = 32)]
					ExpectTransactStatus(runtime_types::xcm::v3::MaybeErrorCode),
					#[codec(index = 33)]
					QueryPallet {
						module_name: ::std::vec::Vec<::core::primitive::u8>,
						response_info: runtime_types::xcm::v3::QueryResponseInfo,
					},
					#[codec(index = 34)]
					ExpectPallet {
						#[codec(compact)]
						index: ::core::primitive::u32,
						name: ::std::vec::Vec<::core::primitive::u8>,
						module_name: ::std::vec::Vec<::core::primitive::u8>,
						#[codec(compact)]
						crate_major: ::core::primitive::u32,
						#[codec(compact)]
						min_crate_minor: ::core::primitive::u32,
					},
					#[codec(index = 35)]
					ReportTransactStatus(runtime_types::xcm::v3::QueryResponseInfo),
					#[codec(index = 36)]
					ClearTransactStatus,
					#[codec(index = 37)]
					UniversalOrigin(runtime_types::xcm::v3::junction::Junction),
					#[codec(index = 38)]
					ExportMessage {
						network: runtime_types::xcm::v3::junction::NetworkId,
						destination: runtime_types::xcm::v3::junctions::Junctions,
						xcm: runtime_types::xcm::v3::Xcm,
					},
					#[codec(index = 39)]
					LockAsset {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						unlocker: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 40)]
					UnlockAsset {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						target: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 41)]
					NoteUnlockable {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						owner: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 42)]
					RequestUnlock {
						asset: runtime_types::xcm::v3::multiasset::MultiAsset,
						locker: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					},
					#[codec(index = 43)]
					SetFeesMode { jit_withdraw: ::core::primitive::bool },
					#[codec(index = 44)]
					SetTopic([::core::primitive::u8; 32usize]),
					#[codec(index = 45)]
					ClearTopic,
					#[codec(index = 46)]
					AliasOrigin(runtime_types::staging_xcm::v3::multilocation::MultiLocation),
					#[codec(index = 47)]
					UnpaidExecution {
						weight_limit: runtime_types::xcm::v3::WeightLimit,
						check_origin: ::core::option::Option<
							runtime_types::staging_xcm::v3::multilocation::MultiLocation,
						>,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum MaybeErrorCode {
					#[codec(index = 0)]
					Success,
					#[codec(index = 1)]
					Error(
						runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					),
					#[codec(index = 2)]
					TruncatedError(
						runtime_types::bounded_collections::bounded_vec::BoundedVec<
							::core::primitive::u8,
						>,
					),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PalletInfo {
					#[codec(compact)]
					pub index: ::core::primitive::u32,
					pub name: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					pub module_name: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					#[codec(compact)]
					pub major: ::core::primitive::u32,
					#[codec(compact)]
					pub minor: ::core::primitive::u32,
					#[codec(compact)]
					pub patch: ::core::primitive::u32,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct QueryResponseInfo {
					pub destination: runtime_types::staging_xcm::v3::multilocation::MultiLocation,
					#[codec(compact)]
					pub query_id: ::core::primitive::u64,
					pub max_weight: ::sp_weights::Weight,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Response {
					#[codec(index = 0)]
					Null,
					#[codec(index = 1)]
					Assets(runtime_types::xcm::v3::multiasset::MultiAssets),
					#[codec(index = 2)]
					ExecutionResult(
						::core::option::Option<(
							::core::primitive::u32,
							runtime_types::xcm::v3::traits::Error,
						)>,
					),
					#[codec(index = 3)]
					Version(::core::primitive::u32),
					#[codec(index = 4)]
					PalletsInfo(
						runtime_types::bounded_collections::bounded_vec::BoundedVec<
							runtime_types::xcm::v3::PalletInfo,
						>,
					),
					#[codec(index = 5)]
					DispatchResult(runtime_types::xcm::v3::MaybeErrorCode),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum WeightLimit {
					#[codec(index = 0)]
					Unlimited,
					#[codec(index = 1)]
					Limited(::sp_weights::Weight),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Xcm(pub ::std::vec::Vec<runtime_types::xcm::v3::Instruction>);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Xcm2(pub ::std::vec::Vec<runtime_types::xcm::v3::Instruction2>);
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum VersionedAssetId {
				#[codec(index = 3)]
				V3(runtime_types::xcm::v3::multiasset::AssetId),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::asset::AssetId),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum VersionedAssets {
				#[codec(index = 1)]
				V2(runtime_types::xcm::v2::multiasset::MultiAssets),
				#[codec(index = 3)]
				V3(runtime_types::xcm::v3::multiasset::MultiAssets),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::asset::Assets),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum VersionedLocation {
				#[codec(index = 1)]
				V2(runtime_types::xcm::v2::multilocation::MultiLocation),
				#[codec(index = 3)]
				V3(runtime_types::staging_xcm::v3::multilocation::MultiLocation),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::location::Location),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum VersionedResponse {
				#[codec(index = 2)]
				V2(runtime_types::xcm::v2::Response),
				#[codec(index = 3)]
				V3(runtime_types::xcm::v3::Response),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::Response),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum VersionedXcm {
				#[codec(index = 2)]
				V2(runtime_types::xcm::v2::Xcm),
				#[codec(index = 3)]
				V3(runtime_types::xcm::v3::Xcm),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::Xcm),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum VersionedXcm2 {
				#[codec(index = 2)]
				V2(runtime_types::xcm::v2::Xcm2),
				#[codec(index = 3)]
				V3(runtime_types::xcm::v3::Xcm2),
				#[codec(index = 4)]
				V4(runtime_types::staging_xcm::v4::Xcm2),
			}
		}
	}
}
