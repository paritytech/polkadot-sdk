searchState.loadedDescShard("polkadot_erasure_coding", 0, "As part of Polkadot’s availability system, certain …\nBad payload in reconstructed bytes.\nBranch out of bounds.\nAn iterator that yields merkle branches and chunk data for …\nChunk index out of bounds.\nUnable to decode reconstructed bytes.\nErrors in erasure coding.\nInvalid branch proof.\nChunks not of uniform length or the chunks are empty.\nNot enough chunks present.\nCannot encode something for zero or one validator\nToo many chunks present.\nReturned when there are too many validators.\nAn uneven byte-length of a shard is not valid for <code>GF(2^16)</code> …\nUnknown error\nUnknown error\nCannot reconstruct: wrong number of validators.\nVerify a merkle branch, yielding the chunk hash meant to …\nConstruct a trie from chunks of an erasure-coded value. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a mutable reference to the inner from the outer.\nGet a mutable reference to the inner from the outer.\nGet a reference to the inner from the outer.\nGet a reference to the inner from the outer.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nObtain erasure-coded chunks, one for each validator.\nObtain erasure-coded chunks for v1 <code>AvailableData</code>, one for …\nReconstruct decodable data from a set of chunks.\nReconstruct the available data from the set of systematic …\nReconstruct the v1 available data from the set of …\nReconstruct the v1 available data from a set of chunks.\nObtain a threshold of chunks that should be enough to …\nGet the trie root.\nObtain the threshold of systematic chunks that should be …")