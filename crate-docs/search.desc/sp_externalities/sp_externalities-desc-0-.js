searchState.loadedDescShard("sp_externalities", 0, "Substrate externalities abstraction\nExternalities error.\nMarker trait for types that should be registered as …\nSame extension cannot be registered twice.\nExtension <code>TypeId</code> is not registered.\nSomething that provides access to the <code>Extensions</code> store.\nStores extensions that should be made available through …\nExtensions are not supported.\nThe Substrate externalities.\nExtension for the <code>Externalities</code> trait.\nResults concerning an operation to remove many keys.\nFailed to update storage,\nReturn the extension as <code>&amp;mut dyn Any</code>.\nThe number of items removed from the backend database.\nRead child runtime storage.\nGet child storage value hash.\nGet the trie root of a child storage map.\nClear child storage entries which keys are start with the …\nClear a child storage entry (<code>key</code>) of current contract …\nClear storage entries which keys are start with the given …\nClear a storage entry (<code>key</code>) of current contract being …\n…\nMacro for declaring an extension that usable with …\nDeconstruct into the internal components.\nDeregister extension for the given <code>type_id</code>.\nDeregister and drop extension of <code>T</code> type.\nDeregister extension with specified ‘type_id’ and drop …\nWhether a child storage entry exists.\nWhether a storage entry exists.\nTries to find a registered extension and returns a mutable …\nTries to find a registered extension by the given <code>type_id</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn a mutable reference to the requested extension.\n…\n…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a mutable iterator over all extensions.\nClear an entire child storage.\nThe number of iterations (each requiring a storage …\nA continuation cursor which, if <code>Some</code> must be provided to …\nMerge <code>other</code> into <code>self</code>.\nCreate new instance of <code>Self</code>.\nReturns the key immediately following the given key, if it …\nReturns the key immediately following the given key, if it …\nSet or clear a child storage entry.\nSet or clear a storage entry (<code>key</code>) of current contract …\n…\n…\nRegister the given extension.\nRegister extension <code>ext</code>.\nRegister extension <code>extension</code> with specified <code>type_id</code>.\nRegister extension <code>extension</code> using the given <code>type_id</code>.\n…\nSet the given externalities while executing the given …\nSet child storage entry <code>key</code> of current contract being …\nWrite a key value pair to the offchain storage database.\nSet storage entry <code>key</code> of current contract being called …\n…\nRead runtime storage.\nAppend storage item.\nCommit the last transaction started by …\nGet storage value hash.\nIndex specified transaction slice and store it.\nRenew existing piece of transaction storage.\nRollback the last transaction started by …\nGet the trie root of the current storage map.\nStart a new nested transaction.\nGet the <code>TypeId</code> of this <code>Extension</code>.\nThe number of unique keys removed, taking into account …\n…\nExecute the given closure with the currently set …")