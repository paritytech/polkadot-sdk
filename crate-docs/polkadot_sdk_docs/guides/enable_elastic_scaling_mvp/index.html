<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="How to enable elastic scaling MVP on a parachain."><title>polkadot_sdk_docs::guides::enable_elastic_scaling_mvp - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-5bc39a1768837dd0.css"><script id="default-settings" 
data-theme="ayu"
data-use_system_theme="false"></script><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="polkadot_sdk_docs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="stylesheet" href="../../../theme.css"><link rel="icon" href="https://polkadot.network/favicon-32x32.png"><script>
	function createToC() {
		let sidebar = document.querySelector(".sidebar");
		let headers = document.querySelectorAll("#main-content h2, #main-content h3, #main-content h4");
		console.log(`detected polkadot_sdk_docs: headers: ${headers.length}`);

		let toc = document.createElement("div");
		toc.classList.add("sidebar-table-of-contents");
		toc.appendChild(document.createElement("h2").appendChild(document.createTextNode("Table of Contents")).parentNode);

		let modules = document.querySelectorAll("main .item-table a.mod");

		// the first two headers are always junk
		headers.forEach(header => {
			let link = document.createElement("a");
			link.href = "#" + header.id;
			link.textContent = header.textContent;
			link.className = header.tagName.toLowerCase();

			toc.appendChild(link);

			if (header.id == "modules" && header.textContent == "Modules") {
				modules.forEach(module => {
					let link = document.createElement("a");
					link.href = module.href;
					link.textContent = module.textContent;
					link.className = "h3";

					toc.appendChild(link);
				});
			}
		});

		// insert toc as the second child in sidebar
		let sidebar_children = sidebar.children;
		if (sidebar_children.length > 1) {
			sidebar.insertBefore(toc, sidebar_children[1]);
		} else {
			sidebar.appendChild(toc);
		}
	}

	function hideSidebarElements() {
		// Create the 'Expand for More' button
		var expandButton = document.createElement('button');
		expandButton.innerText = 'Expand More Items';
		expandButton.classList.add('expand-button');

		// Insert the button at the top of the sidebar or before the '.sidebar-elems'
		var sidebarElems = document.querySelector('.sidebar-elems');
		sidebarElems.parentNode.insertBefore(expandButton, sidebarElems);

		// Initially hide the '.sidebar-elems'
		sidebarElems.style.display = 'none';

		// Add click event listener to the button
		expandButton.addEventListener('click', function () {
			// Toggle the display of the '.sidebar-elems'
			if (sidebarElems.style.display === 'none') {
				sidebarElems.style.display = 'block';
				expandButton.innerText = 'Collapse';
			} else {
				sidebarElems.style.display = 'none';
				expandButton.innerText = 'Expand for More';
			}
		});
	}

	window.addEventListener("DOMContentLoaded", (event) => {
		// if the crate is one that starts with `polkadot_sdk_docs`
		let crate_name = document.querySelector("#main-content > div > h1 > a:nth-child(1)");
		if (!crate_name.textContent.startsWith("polkadot_sdk_docs")) {
			console.log("skipping -- not `polkadot_sdk_docs`");
			return;
		} else {
			// insert class 'sdk-docs' to the body, so it enables the custom css rules.
			document.body.classList.add("sdk-docs");
		}

		createToC();
		hideSidebarElements();

		console.log("updating page based on being `polkadot_sdk_docs` crate");
	});
</script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

<style>
	body.sdk-docs {
		nav.side-bar {
			width: 300px;
		}

		.sidebar-table-of-contents {
			margin-bottom: 1em;
			padding: 0.5em;
		}

		.sidebar-table-of-contents a {
			display: block;
			margin: 0.2em 0;
		}

		.sidebar-table-of-contents .h2 {
			font-weight: bold;
			margin-left: 0;
		}

		.sidebar-table-of-contents .h3 {
			margin-left: 1em;
		}

		.sidebar-table-of-contents .h4 {
			margin-left: 2em;
		}

		.sidebar h2.location {
			display: none;
		}

		.sidebar-elems {
			display: none;
		}

		/* Center the 'Expand for More' button */
		.expand-button {
			display: inline-block;
			/* Use inline-block for sizing */
			margin: 10px auto;
			/* Auto margins for horizontal centering */
			padding: 5px 10px;
			background-color: #007bff;
			color: white;
			text-align: center;
			cursor: pointer;
			border: none;
			border-radius: 5px;
			width: auto;
			/* Centering the button within its parent container */
			position: relative;
			left: 50%;
			transform: translateX(-50%);
		}
	}
</style>

<script async defer src="https://apisa.parity.io/latest.js"></script><noscript><img src="https://apisa.parity.io/latest.js" alt="" referrerpolicy="no-referrer-when-downgrade" /></noscript></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../polkadot_sdk_docs/index.html"><img src="https://europe1.discourse-cdn.com/standard21/uploads/polkadot2/original/1X/eb57081e2bb7c39e5fcb1a98b443e423fa4448ae.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../polkadot_sdk_docs/index.html"><img src="https://europe1.discourse-cdn.com/standard21/uploads/polkadot2/original/1X/eb57081e2bb7c39e5fcb1a98b443e423fa4448ae.svg" alt="logo"></a><h2><a href="../../../polkadot_sdk_docs/index.html">polkadot_sdk_docs</a><span class="version">0.0.1</span></h2></div><h2 class="location"><a href="#">Module enable_elastic_scaling_mvp</a></h2><div class="sidebar-elems"><h2><a href="../index.html">In polkadot_sdk_docs::guides</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../polkadot_sdk_docs/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">polkadot_sdk_docs</a>::<wbr><a href="../index.html">guides</a>::<wbr><a class="mod" href="#">enable_elastic_scaling_mvp</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/polkadot_sdk_docs/guides/enable_elastic_scaling_mvp.rs.html#1-142">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>How to enable elastic scaling MVP on a parachain.</p>
<h2 id="enable-elastic-scaling-mvp-for-a-parachain"><a class="doc-anchor" href="#enable-elastic-scaling-mvp-for-a-parachain">§</a>Enable elastic scaling MVP for a parachain</h2><div class="warning">This guide assumes full familiarity with Asynchronous Backing and its
terminology, as defined in https://wiki.polkadot.network/docs/maintain-guides-async-backing.
Furthermore, the parachain should have already been upgraded according to the guide.</div>
<h3 id="quick-introduction-to-elastic-scaling"><a class="doc-anchor" href="#quick-introduction-to-elastic-scaling">§</a>Quick introduction to elastic scaling</h3>
<p><a href="https://polkadot.network/blog/elastic-scaling-streamling-growth-on-polkadot">Elastic scaling</a>
is a feature that will enable parachains to seamlessly scale up/down the number of used cores.
This can be desirable in order to increase the compute or storage throughput of a parachain or
to lower the latency between a transaction being submitted and it getting built in a parachain
block.</p>
<p>At present, with Asynchronous Backing enabled, a parachain can only include a block on the relay
chain every 6 seconds, irregardless of how many cores the parachain acquires. Elastic scaling
builds further on the 10x throughput increase of Async Backing, enabling collators to submit up
to 3 parachain blocks per relay chain block, resulting in a further 3x throughput increase.</p>
<h3 id="current-limitations-of-the-mvp"><a class="doc-anchor" href="#current-limitations-of-the-mvp">§</a>Current limitations of the MVP</h3>
<p>The full implementation of elastic scaling spans across the entire relay/parachain stack and is
still <a href="https://github.com/paritytech/polkadot-sdk/issues/1829">work in progress</a>.
The MVP is still considered experimental software, so stability is not guaranteed.
If you encounter any problems,
<a href="https://github.com/paritytech/polkadot-sdk/issues">please open an issue</a>.
Below are described the current limitations of the MVP:</p>
<ol>
<li><strong>Limited core count</strong>. Parachain block authoring is sequential, so the second block will
start being built only after the previous block is imported. The current block production is
capped at 2 seconds of execution. Therefore, assuming the full 2 seconds are used, a
parachain can only utilise at most 3 cores in a relay chain slot of 6 seconds. If the full
execution time is not being used, higher core counts can be achieved.</li>
<li><strong>Single collator requirement for consistently scaling beyond a core at full authorship
duration of 2 seconds per block.</strong> Using the current implementation with multiple collators
adds additional latency to the block production pipeline. Assuming block execution takes
about the same as authorship, the additional overhead is equal the duration of the authorship
plus the block announcement. Each collator must first import the previous block before
authoring a new one, so it is clear that the highest throughput can be achieved using a
single collator. Experiments show that the peak performance using more than one collator
(measured up to 10 collators) is utilising 2 cores with authorship time of 1.3 seconds per
block, which leaves 400ms for networking overhead. This would allow for 2.6 seconds of
execution, compared to the 2 seconds async backing enabled.
<a href="https://github.com/paritytech/polkadot-sdk/issues/4696">More experiments</a> are being
conducted in this space.</li>
<li><strong>Trusted collator set.</strong> The collator set needs to be trusted until there’s a mitigation
that would prevent or deter multiple collators from submitting the same collation to multiple
backing groups. A solution is being discussed
<a href="https://github.com/polkadot-fellows/RFCs/issues/92">here</a>.</li>
<li><strong>Fixed scaling.</strong> For true elasticity, the parachain must be able to seamlessly acquire or
sell coretime as the user demand grows and shrinks over time, in an automated manner. This is
currently lacking - a parachain can only scale up or down by “manually” acquiring coretime.
This is not in the scope of the relay chain functionality. Parachains can already start
implementing such autoscaling, but we aim to provide a framework/examples for developing
autoscaling strategies.</li>
</ol>
<p>Another hard limitation that is not envisioned to ever be lifted is that parachains which create
forks will generally not be able to utilise the full number of cores they acquire.</p>
<h3 id="using-elastic-scaling-mvp"><a class="doc-anchor" href="#using-elastic-scaling-mvp">§</a>Using elastic scaling MVP</h3><h4 id="prerequisites"><a class="doc-anchor" href="#prerequisites">§</a>Prerequisites</h4>
<ul>
<li>Ensure Asynchronous Backing is enabled on the network and you have enabled it on the parachain
using <a href="../async_backing_guide/index.html" title="mod polkadot_sdk_docs::guides::async_backing_guide"><code>crate::guides::async_backing_guide</code></a>.</li>
<li>Ensure the <code>AsyncBackingParams.max_candidate_depth</code> value is configured to a value that is at
least double the maximum targeted parachain velocity. For example, if the parachain will build
at most 3 candidates per relay chain block, the <code>max_candidate_depth</code> should be at least 6.</li>
<li>Use a trusted single collator for maximum throughput.</li>
<li>Ensure enough coretime is assigned to the parachain. For maximum throughput the upper bound is
3 cores.</li>
</ul>
<div class="warning">Phase 1 is not needed if using the `polkadot-parachain` binary built
from the latest polkadot-sdk release! Simply pass the `--experimental-use-slot-based` parameter
to the command line and jump to Phase 2.</div>
<p>The following steps assume using the cumulus parachain template.</p>
<h4 id="phase-1---for-custom-parachain-node-update-parachain-node"><a class="doc-anchor" href="#phase-1---for-custom-parachain-node-update-parachain-node">§</a>Phase 1 - (For custom parachain node) Update Parachain Node</h4>
<p>This assumes you are using
<a href="https://github.com/paritytech/polkadot-sdk/tree/master/templates/parachain">the latest parachain template</a>.</p>
<p>This phase consists of plugging in the new slot-based collator.</p>
<ol>
<li>In <code>node/src/service.rs</code> import the slot based collator instead of the lookahead collator.</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>cumulus_client_consensus_aura::collators::slot_based::{
	<span class="self">self </span><span class="kw">as </span>slot_based, Params <span class="kw">as </span>SlotBasedParams,
};</code></pre></div>
<ol start="2">
<li>In <code>start_consensus()</code>
<ul>
<li>Remove the <code>overseer_handle</code> param (also remove the
<code>OverseerHandle</code> type import if it’s not used elsewhere).</li>
<li>Rename <code>AuraParams</code> to <code>SlotBasedParams</code>, remove the <code>overseer_handle</code> field and add a
<code>slot_drift</code> field with a   value of <code>Duration::from_secs(1)</code>.</li>
<li>Replace the single future returned by <code>aura::run</code> with the two futures returned by it and
spawn them as separate tasks:</li>
</ul>
</li>
</ol>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(collation_future, block_builder_future) =
	slot_based::run::&lt;Block, &lt;AuraId <span class="kw">as </span>AppCrypto&gt;::Pair, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>&gt;(params);

task_manager.spawn_essential_handle().spawn(
	<span class="string">"collation-task"</span>,
	<span class="prelude-val">Some</span>(<span class="string">"parachain-block-authoring"</span>),
	collation_future,
);
task_manager.spawn_essential_handle().spawn(
	<span class="string">"block-builder-task"</span>,
	<span class="prelude-val">Some</span>(<span class="string">"parachain-block-authoring"</span>),
	block_builder_future,
);</code></pre></div>
<ol start="3">
<li>In <code>start_parachain_node()</code> remove the <code>overseer_handle</code> param passed to <code>start_consensus</code>.</li>
</ol>
<h4 id="phase-2---activate-fixed-factor-scaling-in-the-runtime"><a class="doc-anchor" href="#phase-2---activate-fixed-factor-scaling-in-the-runtime">§</a>Phase 2 - Activate fixed factor scaling in the runtime</h4>
<p>This phase consists of a couple of changes needed to be made to the parachain’s runtime in order
to utilise fixed factor scaling.</p>
<p>First of all, you need to decide the upper limit to how many parachain blocks you need to
produce per relay chain block (in direct correlation with the number of acquired cores). This
should be either 1 (no scaling), 2 or 3. This is called the parachain velocity.</p>
<p>If you configure a velocity which is different from the number of assigned cores, the measured
velocity in practice will be the minimum of these two.</p>
<p>The chosen velocity will also be used to compute:</p>
<ul>
<li>The slot duration, by dividing the 6000 ms duration of the relay chain slot duration by the
velocity.</li>
<li>The unincluded segment capacity, by multiplying the velocity with 2 and adding 1 to
it.</li>
</ul>
<p>Let’s assume a desired maximum velocity of 3 parachain blocks per relay chain block. The needed
changes would all be done in <code>runtime/src/lib.rs</code>:</p>
<ol>
<li>
<p>Rename <code>BLOCK_PROCESSING_VELOCITY</code> to <code>MAX_BLOCK_PROCESSING_VELOCITY</code> and increase it to the
desired value. In this example, 3.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">const </span>MAX_BLOCK_PROCESSING_VELOCITY: u32 = <span class="number">3</span>;</code></pre></div>
</li>
<li>
<p>Set the <code>MILLISECS_PER_BLOCK</code> to the desired value.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">const </span>MILLISECS_PER_BLOCK: u32 =
    RELAY_CHAIN_SLOT_DURATION_MILLIS / MAX_BLOCK_PROCESSING_VELOCITY;</code></pre></div>
<p>Note: for a parachain which measures time in terms of its own block number, changing block
time may cause complications, requiring additional changes.  See here more information:
<a href="../async_backing_guide/index.html#timing-by-block-number" title="mod polkadot_sdk_docs::guides::async_backing_guide"><code>crate::guides::async_backing_guide</code></a>.</p>
</li>
<li>
<p>Increase the <code>UNINCLUDED_SEGMENT_CAPACITY</code> to the desired value.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">const </span>UNINCLUDED_SEGMENT_CAPACITY: u32 = <span class="number">2 </span>* MAX_BLOCK_PROCESSING_VELOCITY + <span class="number">1</span>;</code></pre></div>
</li>
</ol>
</div></details></section></div></main><script> mermaid.init({ startOnLoad: true, theme: "dark" }, "pre.language-mermaid > code");</script>


</body></html>