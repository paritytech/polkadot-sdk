<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Learn about how to write safe and defensive code in your FRAME runtime. Defensive programming is a design paradigm that enables a program to continue running despite unexpected behavior, input, or events that may arise in runtime. Usually, unforeseen circumstances may cause the program to stop or, in the Rust context, panic!. Defensive practices allow for these circumstances to be accounted for ahead of time and for them to be handled gracefully, which is in line with the intended fault-tolerant and deterministic nature of blockchains."><title>polkadot_sdk_docs::reference_docs::defensive_programming - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-9ee3a5e31a2afa3e.css"><script id="default-settings" 
data-theme="ayu"
data-use_system_theme="false"></script><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="polkadot_sdk_docs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0 (82e1608df 2023-12-21)" data-channel="1.75.0" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="stylesheet" href="../../../theme.css"><link rel="icon" href="https://polkadot.network/favicon-32x32.png"><script>
	function createToC() {
		let sidebar = document.querySelector(".sidebar");
		let headers = document.querySelectorAll("#main-content h2, #main-content h3, #main-content h4");
		console.log(`detected polkadot_sdk_docs: headers: ${headers.length}`);

		let toc = document.createElement("div");
		toc.classList.add("sidebar-table-of-contents");
		toc.appendChild(document.createElement("h2").appendChild(document.createTextNode("Table of Contents")).parentNode);

		let modules = document.querySelectorAll("main .item-table a.mod");

		// the first two headers are always junk
		headers.forEach(header => {
			let link = document.createElement("a");
			link.href = "#" + header.id;
			link.textContent = header.textContent;
			link.className = header.tagName.toLowerCase();

			toc.appendChild(link);

			if (header.id == "modules" && header.textContent == "Modules") {
				modules.forEach(module => {
					let link = document.createElement("a");
					link.href = module.href;
					link.textContent = module.textContent;
					link.className = "h3";

					toc.appendChild(link);
				});
			}
		});

		// insert toc as the second child in sidebar
		let sidebar_children = sidebar.children;
		if (sidebar_children.length > 1) {
			sidebar.insertBefore(toc, sidebar_children[1]);
		} else {
			sidebar.appendChild(toc);
		}
	}

	function hideSidebarElements() {
		// Create the 'Expand for More' button
		var expandButton = document.createElement('button');
		expandButton.innerText = 'Expand More Items';
		expandButton.classList.add('expand-button');

		// Insert the button at the top of the sidebar or before the '.sidebar-elems'
		var sidebarElems = document.querySelector('.sidebar-elems');
		sidebarElems.parentNode.insertBefore(expandButton, sidebarElems);

		// Initially hide the '.sidebar-elems'
		sidebarElems.style.display = 'none';

		// Add click event listener to the button
		expandButton.addEventListener('click', function () {
			// Toggle the display of the '.sidebar-elems'
			if (sidebarElems.style.display === 'none') {
				sidebarElems.style.display = 'block';
				expandButton.innerText = 'Collapse';
			} else {
				sidebarElems.style.display = 'none';
				expandButton.innerText = 'Expand for More';
			}
		});
	}

	window.addEventListener("DOMContentLoaded", (event) => {
		// if the crate is one that starts with `polkadot_sdk_docs`
		let crate_name = document.querySelector("#main-content > div > h1 > a:nth-child(1)");
		if (!crate_name.textContent.startsWith("polkadot_sdk_docs")) {
			console.log("skipping -- not `polkadot_sdk_docs`");
			return;
		} else {
			// insert class 'sdk-docs' to the body, so it enables the custom css rules.
			document.body.classList.add("sdk-docs");
		}

		createToC();
		hideSidebarElements();

		console.log("updating page based on being `polkadot_sdk_docs` crate");
	});
</script>

<style>
	body.sdk-docs {
		nav.side-bar {
			width: 300px;
		}

		.sidebar-table-of-contents {
			margin-bottom: 1em;
			padding: 0.5em;
		}

		.sidebar-table-of-contents a {
			display: block;
			margin: 0.2em 0;
		}

		.sidebar-table-of-contents .h2 {
			font-weight: bold;
			margin-left: 0;
		}

		.sidebar-table-of-contents .h3 {
			margin-left: 1em;
		}

		.sidebar-table-of-contents .h4 {
			margin-left: 2em;
		}

		.sidebar h2.location {
			display: none;
		}

		.sidebar-elems {
			display: none;
		}

		/* Center the 'Expand for More' button */
		.expand-button {
			display: inline-block;
			/* Use inline-block for sizing */
			margin: 10px auto;
			/* Auto margins for horizontal centering */
			padding: 5px 10px;
			background-color: #007bff;
			color: white;
			text-align: center;
			cursor: pointer;
			border: none;
			border-radius: 5px;
			width: auto;
			/* Centering the button within its parent container */
			position: relative;
			left: 50%;
			transform: translateX(-50%);
		}
	}
</style>

<script async defer src="https://apisa.parity.io/latest.js"></script><noscript><img src="https://apisa.parity.io/latest.js" alt="" referrerpolicy="no-referrer-when-downgrade" /></noscript></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../polkadot_sdk_docs/index.html"><img src="https://europe1.discourse-cdn.com/standard21/uploads/polkadot2/original/1X/eb57081e2bb7c39e5fcb1a98b443e423fa4448ae.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../polkadot_sdk_docs/index.html"><img src="https://europe1.discourse-cdn.com/standard21/uploads/polkadot2/original/1X/eb57081e2bb7c39e5fcb1a98b443e423fa4448ae.svg" alt="logo"></a><h2><a href="../../../polkadot_sdk_docs/index.html">polkadot_sdk_docs</a><span class="version">0.0.1</span></h2></div><h2 class="location"><a href="#">Module defensive_programming</a></h2><div class="sidebar-elems"><h2><a href="../index.html">In polkadot_sdk_docs::reference_docs</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">polkadot_sdk_docs</a>::<wbr><a href="../index.html">reference_docs</a>::<wbr><a class="mod" href="#">defensive_programming</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/polkadot_sdk_docs/reference_docs/defensive_programming.rs.html#16-395">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Learn about how to write safe and defensive code in your FRAME runtime.
<a href="https://en.wikipedia.org/wiki/Defensive_programming">Defensive programming</a> is a design paradigm that enables a program to continue
running despite unexpected behavior, input, or events that may arise in runtime.
Usually, unforeseen circumstances may cause the program to stop or, in the Rust context,
panic!. Defensive practices allow for these circumstances to be accounted for ahead of time
and for them to be handled gracefully, which is in line with the intended fault-tolerant and
deterministic nature of blockchains.</p>
<p>The Polkadot SDK is built to reflect these principles and to facilitate their usage accordingly.</p>
<h3 id="general-overview"><a href="#general-overview">General Overview</a></h3>
<p>When developing within the context of the Substrate runtime, there is one golden rule:</p>
<p><em><strong>DO NOT PANIC</strong></em>. There are some exceptions, but generally, this is the default precedent.</p>
<blockquote>
<p>It’s important to differentiate between the runtime and node. The runtime refers to the core
business logic of a Substrate-based chain, whereas the node refers to the outer client, which
deals with telemetry and gossip from other nodes. For more information, read about
<a href="../wasm_meta_protocol/index.html#node-vs-runtime" title="mod polkadot_sdk_docs::reference_docs::wasm_meta_protocol">Substrate’s node
architecture</a>. It’s also important
to note that the criticality of the node is slightly lesser
than that of the runtime, which is why you may see <code>unwrap()</code> or other “non-defensive”
approaches
in a few places of the node’s code repository.</p>
</blockquote>
<p>Most of these practices fall within Rust’s
colloquial usage of proper error propagation, handling, and arithmetic-based edge cases.</p>
<p>General guidelines:</p>
<ul>
<li><strong>Avoid writing functions that could explicitly panic,</strong> such as directly using <code>unwrap()</code> on
a <a href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a>, or  accessing an out-of-bounds index on a collection. Safer methods to access
collection types, i.e., <code>get()</code> which allow defensive handling of the resulting <a href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> are
recommended to be used.</li>
<li><strong>It may be acceptable to use <code>except()</code>,</strong> but only if one is completely certain (and has
performed a check beforehand) that a value won’t panic upon unwrapping.  <em>Even this is
discouraged</em>, however, as future changes to that function could then cause that statement to
panic.  It is important to ensure all possible errors are propagated and handled effectively.</li>
<li><strong>If a function <em>can</em> panic,</strong> it usually is prefaced with <code>unchecked_</code> to indicate its
unsafety.</li>
<li><strong>If you are writing a function that could panic,</strong> <a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html#documenting-components">document it!</a></li>
<li><strong>Carefully handle mathematical operations.</strong>  Many seemingly, simplistic operations, such as
<strong>arithmetic</strong> in the runtime, could present a number of issues <a href="#integer-overflow">(see more later in this
document)</a>. Use checked arithmetic wherever possible.</li>
</ul>
<p>These guidelines could be summarized in the following example, where <code>bad_pop</code> is prone to
panicking, and <code>good_pop</code> allows for proper error handling to take place:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code> <span class="comment">// Bad pop always requires that we return something, even if vector/array is empty.
 </span><span class="kw">fn </span>bad_pop&lt;T&gt;(v: Vec&lt;T&gt;) -&gt; T {}
 <span class="comment">// Good pop allows us to return None from the Option if need be.
 </span><span class="kw">fn </span>good_pop&lt;T&gt;(v: Vec&lt;T&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;T&gt; {}</code></pre></div>
<h4 id="defensive-traits"><a href="#defensive-traits">Defensive Traits</a></h4>
<p>The <a href="../../../frame_support/traits/misc/trait.Defensive.html" title="trait frame_support::traits::misc::Defensive"><code>Defensive</code></a> trait provides a number of functions, all of which
provide an alternative to ‘vanilla’ Rust functions, e.g.,:</p>
<ul>
<li><a href="../../../frame_support/traits/misc/trait.Defensive.html#tymethod.defensive_unwrap_or" title="method frame_support::traits::misc::Defensive::defensive_unwrap_or"><code>defensive_unwrap_or()</code></a> instead of
<code>unwrap_or()</code></li>
<li><a href="../../../frame_support/traits/misc/trait.DefensiveOption.html#tymethod.defensive_ok_or" title="method frame_support::traits::misc::DefensiveOption::defensive_ok_or"><code>defensive_ok_or()</code></a> instead of <code>ok_or()</code></li>
</ul>
<p>Defensive methods use <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#debug_assertions"><code>debug_assertions</code></a>, which panic in development, but in
production/release, they will merely log an error (i.e., <code>log::error</code>).</p>
<p>The <a href="../../../frame_support/traits/misc/trait.Defensive.html" title="trait frame_support::traits::misc::Defensive"><code>Defensive</code></a> trait and its various implementations can be found
<a href="../../../frame_support/traits/misc/trait.Defensive.html" title="trait frame_support::traits::misc::Defensive">here</a>.</p>
<h3 id="integer-overflow"><a href="#integer-overflow">Integer Overflow</a></h3>
<p>The Rust compiler prevents static overflow from happening at compile time.
The compiler panics in <strong>debug</strong> mode in the event of an integer overflow. In
<strong>release</strong> mode, it resorts to silently <em>wrapping</em> the overflowed amount in a modular fashion
(from the <code>MAX</code> back to zero).</p>
<p>In runtime development, we don’t always have control over what is being supplied
as a parameter. For example, even this simple add function could present one of two outcomes
depending on whether it is in <strong>release</strong> or <strong>debug</strong> mode:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>naive_add(x: u8, y: u8) -&gt; u8 {
    x + y
}</code></pre></div>
<p>If we passed overflow-able values at runtime, this could panic (or wrap if in release).</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>naive_add(<span class="number">250u8</span>, <span class="number">10u8</span>); <span class="comment">// In debug mode, this would panic. In release, this would return 4.</span></code></pre></div>
<p>It is the silent portion of this behavior that presents a real issue. Such behavior should be
made obvious, especially in blockchain development, where unsafe arithmetic could produce
unexpected consequences like a user balance over or underflowing.</p>
<p>Fortunately, there are ways to both represent and handle these scenarios depending on our
specific use case natively built into Rust and libraries like <a href="../../../sp_arithmetic/index.html" title="mod sp_arithmetic"><code>sp_arithmetic</code></a>.</p>
<h3 id="infallible-arithmetic"><a href="#infallible-arithmetic">Infallible Arithmetic</a></h3>
<p>Both Rust and Substrate provide safe ways to deal with numbers and alternatives to floating
point arithmetic.</p>
<p>Known scenarios that could be fallible should be avoided: i.e., avoiding the possibility of
dividing/modulo by zero at any point should be mitigated. One should be opting for a
<code>checked_*</code> method to introduce safe arithmetic in their code in most cases.</p>
<p>A developer should use fixed-point instead of floating-point arithmetic to mitigate the
potential for inaccuracy, rounding errors, or other unexpected behavior.</p>
<ul>
<li><a href="../../../sp_arithmetic/fixed_point/index.html" title="mod sp_arithmetic::fixed_point">Fixed point types</a> and their associated usage can be found here.</li>
<li><a href="../../../sp_arithmetic/per_things/index.html" title="mod sp_arithmetic::per_things">PerThing</a> and its associated types can be found here.</li>
</ul>
<p>Using floating point number types (i.e., f32. f64) in the runtime should be avoided, as a single non-deterministic result could cause chaos for blockchain consensus along with the issues above. For more on the specifics of the peculiarities of floating point calculations, <a href="https://www.youtube.com/watch?v=PZRI1IfStY0">watch this video by the Computerphile</a>.</p>
<p>The following methods demonstrate different ways to handle numbers natively in Rust safely,
without fear of panic or unexpected behavior from wrapping.</p>
<h4 id="checked-arithmetic"><a href="#checked-arithmetic">Checked Arithmetic</a></h4>
<p><strong>Checked operations</strong> utilize an <code>Option&lt;T&gt;</code> as a return type. This allows for
catching any unexpected behavior in the event of an overflow through simple pattern matching.</p>
<p>This is an example of a valid operation:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>checked_add_example() {
	<span class="comment">// This is valid, as 20 is perfectly within the bounds of u32.
	</span><span class="kw">let </span>add = (<span class="number">10u32</span>).checked_add(<span class="number">10</span>);
	<span class="macro">assert_eq!</span>(add, <span class="prelude-val">Some</span>(<span class="number">20</span>))
}</code></pre></div>
<p>This is an example of an invalid operation. In this case, a simulated integer overflow, which
would simply result in <code>None</code>:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>checked_add_handle_error_example() {
	<span class="comment">// This is invalid - we are adding something to the max of u32::MAX, which would overflow.
	// Luckily, checked_add just marks this as None!
	</span><span class="kw">let </span>add = u32::MAX.checked_add(<span class="number">10</span>);
	<span class="macro">assert_eq!</span>(add, <span class="prelude-val">None</span>)
}</code></pre></div>
<p>Suppose you aren’t sure which operation to use for runtime math. In that case, checked
operations are the safest bet, presenting two predictable (and erroring) outcomes that can be
handled accordingly (Some and None).</p>
<p>The following conventions can be seen within the Polkadot SDK, where it is
handled in two ways:</p>
<ul>
<li>As an <a href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a>, using the <code>if let</code> / <code>if</code> or <code>match</code></li>
<li>As a <a href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a>, via <code>ok_or</code> (or similar conversion to <a href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a> from <a href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a>)</li>
</ul>
<h5 id="handling-via-option---more-verbose"><a href="#handling-via-option---more-verbose">Handling via Option - More Verbose</a></h5>
<p>Because wrapped operations return <code>Option&lt;T&gt;</code>, you can use a more verbose/explicit form of error
handling via <code>if</code> or <code>if let</code>:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>increase_balance(account: Address, amount: u64) -&gt; <span class="prelude-ty">Result</span>&lt;(), RuntimeError&gt; {
	<span class="comment">// Get a user&#39;s current balance
	</span><span class="kw">let </span>balance = Runtime::get_balance(account)<span class="question-mark">?</span>;
	<span class="comment">// SAFELY increase the balance by some amount
	</span><span class="kw">if let </span><span class="prelude-val">Some</span>(new_balance) = balance.checked_add(amount) {
		Runtime::set_balance(account, new_balance);
		<span class="prelude-val">Ok</span>(())
	} <span class="kw">else </span>{
		<span class="prelude-val">Err</span>(RuntimeError::Overflow)
	}
}</code></pre></div>
<p>Optionally, match may also be directly used in a more concise manner:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>increase_balance_match(account: Address, amount: u64) -&gt; <span class="prelude-ty">Result</span>&lt;(), RuntimeError&gt; {
	<span class="comment">// Get a user&#39;s current balance
	</span><span class="kw">let </span>balance = Runtime::get_balance(account)<span class="question-mark">?</span>;
	<span class="comment">// SAFELY increase the balance by some amount
	</span><span class="kw">let </span>new_balance = <span class="kw">match </span>balance.checked_add(amount) {
		<span class="prelude-val">Some</span>(balance) =&gt; balance,
		<span class="prelude-val">None </span>=&gt; {
			<span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::Overflow);
		},
	};
	Runtime::set_balance(account, new_balance);
	<span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>This is generally a useful convention for handling checked types and most types that return
<code>Option&lt;T&gt;</code>.</p>
<h5 id="handling-via-result---less-verbose"><a href="#handling-via-result---less-verbose">Handling via Result - Less Verbose</a></h5>
<p>In the Polkadot SDK codebase, checked operations are handled as a <code>Result</code> via <code>ok_or</code>. This is
a less verbose way of expressing the above. This usage often boils down to the developer’s
preference:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>increase_balance_result(account: Address, amount: u64) -&gt; <span class="prelude-ty">Result</span>&lt;(), RuntimeError&gt; {
	<span class="comment">// Get a user&#39;s current balance
	</span><span class="kw">let </span>balance = Runtime::get_balance(account)<span class="question-mark">?</span>;
	<span class="comment">// SAFELY increase the balance by some amount - this time, by using `ok_or`
	</span><span class="kw">let </span>new_balance = balance.checked_add(amount).ok_or(RuntimeError::Overflow)<span class="question-mark">?</span>;
	Runtime::set_balance(account, new_balance);
	<span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h4 id="saturating-operations"><a href="#saturating-operations">Saturating Operations</a></h4>
<p>Saturating a number limits it to the type’s upper or lower bound, even if the integer type
overflowed in runtime. For example, adding to <code>u32::MAX</code> would simply limit itself to
<code>u32::MAX</code>:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
</span><span class="kw">fn </span>saturated_add_example() {
	<span class="comment">// Saturating add simply saturates
	// to the numeric bound of that type if it overflows.
	</span><span class="kw">let </span>add = u32::MAX.saturating_add(<span class="number">10</span>);
	<span class="macro">assert_eq!</span>(add, u32::MAX)
}</code></pre></div>
<p>Saturating calculations can be used if one is very sure that something won’t overflow, but wants
to avoid introducing the notion of any potential-panic or wrapping behavior.</p>
<p>There is also a series of defensive alternatives via
<a href="../../../frame_support/traits/misc/trait.DefensiveSaturating.html" title="trait frame_support::traits::misc::DefensiveSaturating"><code>DefensiveSaturating</code></a>, which introduces the same behavior
of the <a href="../../../frame_support/traits/misc/trait.Defensive.html" title="trait frame_support::traits::misc::Defensive"><code>Defensive</code></a> trait, only with saturating, mathematical
operations:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[test]
#[cfg_attr(debug_assertions, should_panic(expected = <span class="string">&quot;Defensive failure has been triggered!&quot;</span>))]
</span><span class="kw">fn </span>saturated_defensive_example() {
	<span class="kw">let </span>saturated_defensive = u32::MAX.defensive_saturating_add(<span class="number">10</span>);
	<span class="macro">assert_eq!</span>(saturated_defensive, u32::MAX);
}</code></pre></div>
<h4 id="mathematical-operations-in-substrate-development---further-context"><a href="#mathematical-operations-in-substrate-development---further-context">Mathematical Operations in Substrate Development - Further Context</a></h4>
<p>As a recap, we covered the following concepts:</p>
<ol>
<li><strong>Checked</strong> operations - using <a href="https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> or <a href="https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a></li>
<li><strong>Saturating</strong> operations - limited to the lower and upper bounds of a number type</li>
<li><strong>Wrapped</strong> operations (the default) - wrap around to above or below the bounds of a type</li>
</ol>
<h5 id="the-problem-with-default-wrapped-operations"><a href="#the-problem-with-default-wrapped-operations">The problem with ‘default’ wrapped operations</a></h5>
<p><strong>Wrapped operations</strong> cause the overflow to wrap around to either the maximum or minimum of
that type. Imagine this in the context of a blockchain, where there are account balances, voting
counters, nonces for transactions, and other aspects of a blockchain.</p>
<p>While it may seem trivial, choosing how to handle numbers is quite important. As a thought
exercise, here are some scenarios of which will shed more light on when to use which.</p>
<h5 id="bobs-overflowed-balance"><a href="#bobs-overflowed-balance">Bob’s Overflowed Balance</a></h5>
<p><strong>Bob’s</strong> balance exceeds the <code>Balance</code> type on the <code>EduChain</code>. Because the pallet developer did
not handle the calculation to add to Bob’s balance with any regard to this overflow, <strong>Bob’s</strong>
balance is now essentially <code>0</code>, the operation <strong>wrapped</strong>.</p>
<details>
   <summary><b>Solution: Saturating or Checked</b></summary>
     For Bob's balance problems, using a `saturating_add` or `checked_add` could've mitigated
 this issue.  They simply would've reached the upper, or lower bounds, of the particular type for
 an on-chain balance.  In other words: Bob's balance would've stayed at the maximum of the
 Balance type. </details>
<h5 id="alices-underflowed-balance"><a href="#alices-underflowed-balance">Alice’s ‘Underflowed’ Balance</a></h5>
<p>Alice’s balance has reached <code>0</code> after a transfer to Bob. Suddenly, she has been slashed on
EduChain, causing her balance to reach near the limit of <code>u32::MAX</code> - a very large amount - as
wrapped operations can go both ways. Alice can now successfully vote using her new, overpowered
token balance, destroying the chain’s integrity.</p>
<details>
   <summary><b>Solution: Saturating</b></summary>
   For Alice's balance problem, using `saturated_sub` could've mitigated this issue. A saturating
 calculation would've simply limited her balance to the lower bound of u32, as having a negative
 balance is not a concept within blockchains.   In other words: Alice's balance would've stayed
 at "0", even after being slashed.
<p>This is also an example that while one system may work in isolation, shared interfaces, such
as the notion of balances, are often shared across multiple pallets - meaning these small
changes can make a big difference depending on the scenario. </details></p>
<h5 id="proposal-id-overwrite"><a href="#proposal-id-overwrite">Proposal ID Overwrite</a></h5>
<p>A <code>u8</code> parameter, called <code>proposals_count</code>, represents the type for counting the number of
proposals on-chain. Every time a new proposal is added to the system, this number increases.
With the proposal pallet’s high usage, it has reached <code>u8::MAX</code>’s limit of 255, causing
<code>proposals_count</code> to go to 0. Unfortunately, this results in new proposals overwriting old ones,
effectively erasing any notion of past proposals!</p>
<details>
  <summary><b>Solution: Checked</b></summary>
 For the proposal IDs, proper handling via `checked` math would've been suitable,
 Saturating could've been used - but it also would've 'failed' silently. Using `checked_add` to
 ensure that the next proposal ID would've been valid would've been a viable way to let the user
 know the state of their proposal:

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>next_proposal_id = current_count.checked_add(<span class="number">1</span>).ok_or_else(|| Error::TooManyProposals)<span class="question-mark">?</span>;</code></pre></div>
</details>
<p>From the above, we can clearly see the problematic nature of seemingly simple operations in the
runtime, and care should be given to ensure a defensive approach is taken.</p>
<h4 id="edge-cases-of-panic-able-instances-in-substrate"><a href="#edge-cases-of-panic-able-instances-in-substrate">Edge cases of <code>panic!</code>-able instances in Substrate</a></h4>
<p>As you traverse through the codebase (particularly in <code>substrate/frame</code>, where the majority of
runtime code lives), you may notice that there (only a few!) occurrences where <code>panic!</code> is used
explicitly. This is used when the runtime should stall, rather than keep running, as that is
considered safer. Particularly when it comes to mission-critical components, such as block
authoring, consensus, or other protocol-level dependencies, going through with an action may
actually cause harm to the network, and thus stalling would be the better option.</p>
<p>Take the example of the BABE pallet (<a href="../../../pallet_babe/index.html" title="mod pallet_babe"><code>pallet_babe</code></a>), which doesn’t allow for a validator to
participate if it is disabled (see: <a href="../../../frame_support/traits/validation/trait.DisabledValidators.html" title="trait frame_support::traits::validation::DisabledValidators"><code>frame::traits::DisabledValidators</code></a>):</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">if </span>T::DisabledValidators::is_disabled(authority_index) {
    <span class="macro">panic!</span>(
      <span class="string">&quot;Validator with index {:?} is disabled and should not be attempting to author blocks.&quot;</span>,
        authority_index,
    );
}</code></pre></div>
<p>There are other examples in various pallets, mostly those crucial to the blockchain’s
functionality. Most of the time, you will not be writing pallets which operate at this level,
but these exceptions should be noted regardless.</p>
<h3 id="other-resources"><a href="#other-resources">Other Resources</a></h3>
<ul>
<li><a href="https://polkadot-blockchain-academy.github.io/pba-book/substrate/tips-tricks/page.html?highlight=perthing#substrate-and-frame-tips-and-tricks">PBA Book - FRAME Tips &amp; Tricks</a></li>
</ul>
</div></details></section></div></main></body></html>