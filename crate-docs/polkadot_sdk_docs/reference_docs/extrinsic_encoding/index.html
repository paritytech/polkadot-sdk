<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Learn about how extrinsics are encoded to be transmitted to a node and stored in blocks."><title>polkadot_sdk_docs::reference_docs::extrinsic_encoding - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="polkadot_sdk_docs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"><script async defer src="https://apisa.parity.io/latest.js"></script><noscript><img src="https://apisa.parity.io/latest.js" alt="" referrerpolicy="no-referrer-when-downgrade" /></noscript></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../polkadot_sdk_docs/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../polkadot_sdk_docs/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module extrinsic_encoding</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">polkadot_sdk_docs</a>::<wbr><a href="../index.html">reference_docs</a>::<wbr><a class="mod" href="#">extrinsic_encoding</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/polkadot_sdk_docs/reference_docs/extrinsic_encoding.rs.html#1-277">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Learn about how extrinsics are encoded to be transmitted to a node and stored in blocks.</p>
<h2 id="constructing-and-signing-extrinsics"><a href="#constructing-and-signing-extrinsics">Constructing and Signing Extrinsics</a></h2>
<p>Extrinsics are payloads that are stored in blocks which are responsible for altering the state
of a blockchain via the <a href="../blockchain_state_machines/index.html" title="mod polkadot_sdk_docs::reference_docs::blockchain_state_machines"><em>state transition
function</em></a>.</p>
<p>Substrate is configurable enough that extrinsics can take any format. In practice, runtimes
tend to use our <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a> type to represent extrinsics,
because it’s generic enough to cater for most (if not all) use cases. In Polkadot, this is
configured <a href="https://github.com/polkadot-fellows/runtimes/blob/94b2798b69ba6779764e20a50f056e48db78ebef/relay/polkadot/src/lib.rs#L1478">here</a>
at the time of writing.</p>
<p>What follows is a description of how extrinsics based on this
<a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a> type are encoded into bytes. Specifically, we are
looking at how extrinsics with a format version of 4 are encoded. This version is itself a part
of the payload, and if it changes, it indicates that something about the encoding may have
changed.</p>
<h2 id="encoding-an-extrinsic"><a href="#encoding-an-extrinsic">Encoding an Extrinsic</a></h2>
<p>At a high level, all extrinsics compatible with <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>
are formed from concatenating some details together, as in the following pseudo-code:</p>
<div class="example-wrap"><pre class="language-text"><code>extrinsic_bytes = concat(
    compact_encoded_length,
    version_and_maybe_signature,
    call_data
)
</code></pre></div>
<p>For clarity, the actual implementation in Substrate looks like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;Address, Call, Signature, Extra&gt; Encode <span class="kw">for </span>UncheckedExtrinsic&lt;Address, Call, Signature, Extra&gt;
<span class="kw">where
	</span>Address: Encode,
	Signature: Encode,
	Call: Encode,
	Extra: SignedExtension,
{
	<span class="kw">fn </span>encode(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Vec&lt;u8&gt; {
		<span class="kw">let </span><span class="kw-2">mut </span>tmp = Vec::with_capacity(sp_std::mem::size_of::&lt;<span class="self">Self</span>&gt;());

		<span class="comment">// 1 byte version id.
		</span><span class="kw">match </span><span class="self">self</span>.signature.as_ref() {
			<span class="prelude-val">Some</span>(s) =&gt; {
				tmp.push(EXTRINSIC_FORMAT_VERSION | <span class="number">0b1000_0000</span>);
				s.encode_to(<span class="kw-2">&amp;mut </span>tmp);
			},
			<span class="prelude-val">None </span>=&gt; {
				tmp.push(EXTRINSIC_FORMAT_VERSION &amp; <span class="number">0b0111_1111</span>);
			},
		}
		<span class="self">self</span>.function.encode_to(<span class="kw-2">&amp;mut </span>tmp);

		<span class="kw">let </span>compact_len = codec::Compact::&lt;u32&gt;(tmp.len() <span class="kw">as </span>u32);

		<span class="comment">// Allocate the output buffer with the correct length
		</span><span class="kw">let </span><span class="kw-2">mut </span>output = Vec::with_capacity(compact_len.size_hint() + tmp.len());

		compact_len.encode_to(<span class="kw-2">&amp;mut </span>output);
		output.extend(tmp);

		output
	}
}</code></pre></div>
<p>Let’s look at how each of these details is constructed:</p>
<h3 id="compact_encoded_length"><a href="#compact_encoded_length">compact_encoded_length</a></h3>
<p>This is a [SCALE compact encoded][frame::deps::codec::Compact] integer which is equal to the
length, in bytes, of the rest of the extrinsic details.</p>
<p>To obtain this value, we must encode and concatenate together the rest of the extrinsic details
first, and then obtain the byte length of these. We can then compact encode that length, and
prepend it to the rest of the details.</p>
<h3 id="version_and_maybe_signature"><a href="#version_and_maybe_signature">version_and_maybe_signature</a></h3>
<p>If the extrinsic is <em>unsigned</em>, then <code>version_and_maybe_signature</code> will be just one byte
denoting the <em>transaction protocol version</em>, which is 4 (or <code>0b0000_0100</code>).</p>
<p>If the extrinsic is <em>signed</em> (all extrinsics submitted from users must be signed), then
<code>version_and_maybe_signature</code> is obtained by concatenating some details together, ie:</p>
<div class="example-wrap"><pre class="language-text"><code>version_and_maybe_signature = concat(
    version_and_signed,
    from_address,
    signature,
    signed_extensions_extra,
)
</code></pre></div>
<p>Each of the details to be concatenated together is explained below:</p>
<h4 id="version_and_signed"><a href="#version_and_signed">version_and_signed</a></h4>
<p>This is one byte, equal to <code>0x84</code> or <code>0b1000_0100</code> (i.e. an upper 1 bit to denote that it is
signed, and then the transaction version, 4, in the lower bits).</p>
<h4 id="from_address"><a href="#from_address">from_address</a></h4>
<p>This is the [SCALE encoded][frame::deps::codec] address of the sender of the extrinsic. The
address is the first generic parameter of <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>, and so
can vary from chain to chain.</p>
<p>The address type used on the Polkadot relay chain is <a href="../../../sp_runtime/multiaddress/enum.MultiAddress.html" title="enum sp_runtime::multiaddress::MultiAddress"><code>sp_runtime::MultiAddress&lt;AccountId32&gt;</code></a>,
where <code>AccountId32</code> is defined <a href="../../../sp_core/crypto/struct.AccountId32.html" title="struct sp_core::crypto::AccountId32">here</a>. When constructing a
signed extrinsic to be submitted to a Polkadot node, you’ll always use the
<a href="../../../sp_runtime/multiaddress/enum.MultiAddress.html#variant.Id" title="variant sp_runtime::multiaddress::MultiAddress::Id"><code>sp_runtime::MultiAddress::Id</code></a> variant to wrap your <code>AccountId32</code>.</p>
<h4 id="signature"><a href="#signature">signature</a></h4>
<p>This is the [SCALE encoded][frame::deps::codec] signature. The signature type is configured via
the third generic parameter of <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>, which determines the
shape of the signature and signing algorithm that should be used.</p>
<p>The signature is obtained by signing the <em>signed payload</em> bytes (see below on how this is
constructed) using the private key associated with the address and correct algorithm.</p>
<p>The signature type used on the Polkadot relay chain is <a href="../../../sp_runtime/enum.MultiSignature.html" title="enum sp_runtime::MultiSignature"><code>sp_runtime::MultiSignature</code></a>; the
variants there are the types of signature that can be provided.</p>
<h4 id="signed_extensions_extra"><a href="#signed_extensions_extra">signed_extensions_extra</a></h4>
<p>This is the concatenation of the [SCALE encoded][frame::deps::codec] bytes representing each of
the <a href="../../../sp_runtime/traits/trait.SignedExtension.html" title="trait sp_runtime::traits::SignedExtension"><em>signed extensions</em></a>, and are configured by the
fourth generic parameter of <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>. Learn more about
signed extensions <a href="../signed_extensions/index.html" title="mod polkadot_sdk_docs::reference_docs::signed_extensions">here</a>.</p>
<p>When it comes to constructing an extrinsic, each signed extension has two things that we are
interested in here:</p>
<ul>
<li>The actual SCALE encoding of the signed extension type itself; this is what will form our
<code>signed_extensions_extra</code> bytes.</li>
<li>An <code>AdditionalSigned</code> type. This is SCALE encoded into the <code>signed_extensions_additional</code> data
of the <em>signed payload</em> (see below).</li>
</ul>
<p>Either (or both) of these can encode to zero bytes.</p>
<p>Each chain configures the set of signed extensions that it uses in its runtime configuration.
At the time of writing, Polkadot configures them
<a href="https://github.com/polkadot-fellows/runtimes/blob/1dc04eb954eadf8aadb5d83990b89662dbb5a074/relay/polkadot/src/lib.rs#L1432C25-L1432C25">here</a>.
Some of the common signed extensions are defined
<a href="../../../frame_system/index.html#signed-extensions" title="mod frame_system">here</a>.</p>
<p>Information about exactly which signed extensions are present on a chain and in what order is
also a part of the metadata for the chain. For V15 metadata, it can be
[found here][frame::deps::frame_support::__private::metadata::v15::ExtrinsicMetadata].</p>
<h3 id="call_data"><a href="#call_data">call_data</a></h3>
<p>This is the main payload of the extrinsic, which is used to determine how the chain’s state is
altered. This is defined by the second generic parameter of
<a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>.</p>
<p>A call can be anything that implements [<code>Encode</code>][frame::deps::codec::Encode]. In FRAME-based
runtimes, a call is represented as an enum of enums, where the outer enum represents the FRAME
pallet being called, and the inner enum represents the call being made within that pallet, and
any arguments to it. Read more about the call enum
<a href="../frame_composite_enums/index.html" title="mod polkadot_sdk_docs::reference_docs::frame_composite_enums">here</a>.</p>
<p>FRAME <code>Call</code> enums are automatically generated, and end up looking something like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">pub mod </span>call_data {
	<span class="kw">use </span>parity_scale_codec::{Decode, Encode};

	<span class="comment">// The outer enum composes calls within
	// different pallets together. We have two
	// pallets, &quot;PalletA&quot; and &quot;PalletB&quot;.
	</span><span class="attr">#[derive(Encode, Decode)]
	</span><span class="kw">pub enum </span>Call {
		<span class="attr">#[codec(index = <span class="number">0</span>)]
		</span>PalletA(PalletACall),
		<span class="attr">#[codec(index = <span class="number">7</span>)]
		</span>PalletB(PalletBCall),
	}

	<span class="comment">// An inner enum represents the calls within
	// a specific pallet. &quot;PalletA&quot; has one call,
	// &quot;Foo&quot;.
	</span><span class="attr">#[derive(Encode, Decode)]
	</span><span class="kw">pub enum </span>PalletACall {
		<span class="attr">#[codec(index = <span class="number">0</span>)]
		</span>Foo(String),
	}

	<span class="attr">#[derive(Encode, Decode)]
	</span><span class="kw">pub enum </span>PalletBCall {
		<span class="attr">#[codec(index = <span class="number">0</span>)]
		</span>Bar(String),
	}
}</code></pre></div>
<p>In pseudo-code, this <code>Call</code> enum encodes equivalently to:</p>
<div class="example-wrap"><pre class="language-text"><code>call_data = concat(
    pallet_index,
    call_index,
    call_args
)
</code></pre></div>
<ul>
<li><code>pallet_index</code> is a single byte denoting the index of the pallet that we are calling into, and
is what the tag of the outermost enum will encode to.</li>
<li><code>call_index</code> is a single byte denoting the index of the call that we are making the pallet,
and is what the tag of the inner enum will encode to.</li>
<li><code>call_args</code> are the SCALE encoded bytes for each of the arguments that the call expects, and
are typically provided as values to the inner enum.</li>
</ul>
<p>Information about the pallets that exist for a chain (including their indexes), the calls
available in each pallet (including their indexes), and the arguments required for each call
can be found in the metadata for the chain. For V15 metadata, this information
[is here][frame::deps::frame_support::__private::metadata::v15::PalletMetadata].</p>
<h2 id="the-signed-payload-format"><a href="#the-signed-payload-format">The Signed Payload Format</a></h2>
<p>All extrinsics submitted to a node from the outside world (also known as <em>transactions</em>) need to
be <em>signed</em>. The data that needs to be signed for some extrinsic is called the <em>signed payload</em>,
and its shape is described by the following pseudo-code:</p>
<div class="example-wrap"><pre class="language-text"><code>signed_payload = concat(
    call_data,
    signed_extensions_extra,
    signed_extensions_additional,
)

if length(signed_payload) &gt; 256 {
    signed_payload = blake2_256(signed_payload)
}
</code></pre></div>
<p>The bytes representing <code>call_data</code> and <code>signed_extensions_extra</code> can be obtained as descibed
above. <code>signed_extensions_additional</code> is constructed by SCALE encoding the
<a href="../../../sp_runtime/traits/trait.SignedExtension.html#associatedtype.AdditionalSigned" title="associated type sp_runtime::traits::SignedExtension::AdditionalSigned">“additional signed” data</a> for each
signed extension that the chain is using, in order.</p>
<p>Once we’ve concatenated those together, we hash the result if it’s greater than 256 bytes in
length using a Blake2 256bit hasher.</p>
<p>The <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.SignedPayload.html" title="struct sp_runtime::generic::unchecked_extrinsic::SignedPayload"><code>sp_runtime::generic::SignedPayload</code></a> type takes care of assembling the correct payload
for us, given <code>call_data</code> and a tuple of signed extensions.</p>
<h2 id="example-encoding"><a href="#example-encoding">Example Encoding</a></h2>
<p>Using <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>, we can construct and encode an extrinsic
as follows:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">pub mod </span>encoding_example {
	<span class="kw">use </span><span class="kw">super</span>::call_data::{Call, PalletACall};
	<span class="kw">use </span><span class="kw">crate</span>::reference_docs::signed_extensions::signed_extensions_example;
	<span class="kw">use </span>parity_scale_codec::Encode;
	<span class="kw">use </span>sp_core::crypto::AccountId32;
	<span class="kw">use </span>sp_keyring::sr25519::Keyring;
	<span class="kw">use </span>sp_runtime::{
		generic::{SignedPayload, UncheckedExtrinsic},
		MultiAddress, MultiSignature,
	};

	<span class="comment">// Define some signed extensions to use. We&#39;ll use a couple of examples
	// from the signed extensions reference doc.
	</span><span class="kw">type </span>SignedExtensions =
		(signed_extensions_example::AddToPayload, signed_extensions_example::AddToSignaturePayload);

	<span class="comment">// We&#39;ll use `UncheckedExtrinsic` to encode our extrinsic for us. We set
	// the address and signature type to those used on Polkadot, use our custom
	// `Call` type, and use our custom set of `SignedExtensions`.
	</span><span class="kw">type </span>Extrinsic =
		UncheckedExtrinsic&lt;MultiAddress&lt;AccountId32, ()&gt;, Call, MultiSignature, SignedExtensions&gt;;

	<span class="kw">pub fn </span>encode_demo_extrinsic() -&gt; Vec&lt;u8&gt; {
		<span class="comment">// The &quot;from&quot; address will be our Alice dev account.
		</span><span class="kw">let </span>from_address = MultiAddress::&lt;AccountId32, ()&gt;::Id(Keyring::Alice.to_account_id());

		<span class="comment">// We provide some values for our expected signed extensions.
		</span><span class="kw">let </span>signed_extensions = (
			signed_extensions_example::AddToPayload(<span class="number">1</span>),
			signed_extensions_example::AddToSignaturePayload,
		);

		<span class="comment">// Construct our call data:
		</span><span class="kw">let </span>call_data = Call::PalletA(PalletACall::Foo(<span class="string">&quot;Hello&quot;</span>.to_string()));

		<span class="comment">// The signed payload. This takes care of encoding the call_data,
		// signed_extensions_extra and signed_extensions_additional, and hashing
		// the result if it&#39;s &gt; 256 bytes:
		</span><span class="kw">let </span>signed_payload = SignedPayload::new(<span class="kw-2">&amp;</span>call_data, signed_extensions.clone());

		<span class="comment">// Sign the signed payload with our Alice dev account&#39;s private key,
		// and wrap the signature into the expected type:
		</span><span class="kw">let </span>signature = {
			<span class="kw">let </span>sig = Keyring::Alice.sign(<span class="kw-2">&amp;</span>signed_payload.encode());
			MultiSignature::Sr25519(sig)
		};

		<span class="comment">// Now, we can build and encode our extrinsic:
		</span><span class="kw">let </span>ext = Extrinsic::new_signed(call_data, from_address, signature, signed_extensions);

		<span class="kw">let </span>encoded_ext = ext.encode();
		encoded_ext
	}
}</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="call_data/index.html" title="mod polkadot_sdk_docs::reference_docs::extrinsic_encoding::call_data">call_data</a></div></li><li><div class="item-name"><a class="mod" href="encoding_example/index.html" title="mod polkadot_sdk_docs::reference_docs::extrinsic_encoding::encoding_example">encoding_example</a></div></li></ul></section></div></main></body></html>